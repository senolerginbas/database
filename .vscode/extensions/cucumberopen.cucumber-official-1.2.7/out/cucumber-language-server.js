"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/web-tree-sitter/tree-sitter.js
var require_tree_sitter = __commonJS({
  "node_modules/web-tree-sitter/tree-sitter.js"(exports2, module2) {
    var Module = Module !== void 0 ? Module : {};
    var TreeSitter = function() {
      var e, t = typeof window == "object" ? { currentScript: window.document.currentScript } : null;
      class Parser {
        constructor() {
          this.initialize();
        }
        initialize() {
          throw new Error("cannot construct a Parser before calling `init()`");
        }
        static init(r) {
          return e || (Module = Object.assign({}, Module, r), e = new Promise((e2) => {
            var r2, n = {};
            for (r2 in Module)
              Module.hasOwnProperty(r2) && (n[r2] = Module[r2]);
            var s, o, _ = [], a = "./this.program", u = function(e3, t2) {
              throw t2;
            }, i = false, l = false;
            i = typeof window == "object", l = typeof importScripts == "function", s = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", o = !i && !s && !l;
            var d, c, m, f, p, h = "";
            s ? (h = l ? require("path").dirname(h) + "/" : __dirname + "/", d = function(e3, t2) {
              return f || (f = require("fs")), p || (p = require("path")), e3 = p.normalize(e3), f.readFileSync(e3, t2 ? null : "utf8");
            }, m = function(e3) {
              var t2 = d(e3, true);
              return t2.buffer || (t2 = new Uint8Array(t2)), k(t2.buffer), t2;
            }, process.argv.length > 1 && (a = process.argv[1].replace(/\\/g, "/")), _ = process.argv.slice(2), typeof module2 != "undefined" && (module2.exports = Module), u = function(e3) {
              process.exit(e3);
            }, Module.inspect = function() {
              return "[Emscripten Module object]";
            }) : o ? (typeof read != "undefined" && (d = function(e3) {
              return read(e3);
            }), m = function(e3) {
              var t2;
              return typeof readbuffer == "function" ? new Uint8Array(readbuffer(e3)) : (k(typeof (t2 = read(e3, "binary")) == "object"), t2);
            }, typeof scriptArgs != "undefined" ? _ = scriptArgs : arguments !== void 0 && (_ = arguments), typeof quit == "function" && (u = function(e3) {
              quit(e3);
            }), typeof print != "undefined" && (typeof console == "undefined" && (console = {}), console.log = print, console.warn = console.error = typeof printErr != "undefined" ? printErr : print)) : (i || l) && (l ? h = self.location.href : t !== void 0 && t.currentScript && (h = t.currentScript.src), h = h.indexOf("blob:") !== 0 ? h.substr(0, h.lastIndexOf("/") + 1) : "", d = function(e3) {
              var t2 = new XMLHttpRequest();
              return t2.open("GET", e3, false), t2.send(null), t2.responseText;
            }, l && (m = function(e3) {
              var t2 = new XMLHttpRequest();
              return t2.open("GET", e3, false), t2.responseType = "arraybuffer", t2.send(null), new Uint8Array(t2.response);
            }), c = function(e3, t2, r3) {
              var n2 = new XMLHttpRequest();
              n2.open("GET", e3, true), n2.responseType = "arraybuffer", n2.onload = function() {
                n2.status == 200 || n2.status == 0 && n2.response ? t2(n2.response) : r3();
              }, n2.onerror = r3, n2.send(null);
            });
            Module.print || console.log.bind(console);
            var g = Module.printErr || console.warn.bind(console);
            for (r2 in n)
              n.hasOwnProperty(r2) && (Module[r2] = n[r2]);
            n = null, Module.arguments && (_ = Module.arguments), Module.thisProgram && (a = Module.thisProgram), Module.quit && (u = Module.quit);
            var w = 16;
            var y, M = [];
            function b(e3, t2) {
              if (!y) {
                y = /* @__PURE__ */ new WeakMap();
                for (var r3 = 0; r3 < K.length; r3++) {
                  var n2 = K.get(r3);
                  n2 && y.set(n2, r3);
                }
              }
              if (y.has(e3))
                return y.get(e3);
              var s2 = function() {
                if (M.length)
                  return M.pop();
                try {
                  K.grow(1);
                } catch (e4) {
                  if (!(e4 instanceof RangeError))
                    throw e4;
                  throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
                }
                return K.length - 1;
              }();
              try {
                K.set(s2, e3);
              } catch (r4) {
                if (!(r4 instanceof TypeError))
                  throw r4;
                var o2 = function(e4, t3) {
                  if (typeof WebAssembly.Function == "function") {
                    for (var r5 = { i: "i32", j: "i64", f: "f32", d: "f64" }, n3 = { parameters: [], results: t3[0] == "v" ? [] : [r5[t3[0]]] }, s3 = 1; s3 < t3.length; ++s3)
                      n3.parameters.push(r5[t3[s3]]);
                    return new WebAssembly.Function(n3, e4);
                  }
                  var o3 = [1, 0, 1, 96], _2 = t3.slice(0, 1), a2 = t3.slice(1), u2 = { i: 127, j: 126, f: 125, d: 124 };
                  for (o3.push(a2.length), s3 = 0; s3 < a2.length; ++s3)
                    o3.push(u2[a2[s3]]);
                  _2 == "v" ? o3.push(0) : o3 = o3.concat([1, u2[_2]]), o3[1] = o3.length - 2;
                  var i2 = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(o3, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0])), l2 = new WebAssembly.Module(i2);
                  return new WebAssembly.Instance(l2, { e: { f: e4 } }).exports.f;
                }(e3, t2);
                K.set(s2, o2);
              }
              return y.set(e3, s2), s2;
            }
            var v, E = function(e3) {
              e3;
            }, I = Module.dynamicLibraries || [];
            Module.wasmBinary && (v = Module.wasmBinary);
            var A, S = Module.noExitRuntime || true;
            function x(e3, t2, r3, n2) {
              switch ((r3 = r3 || "i8").charAt(r3.length - 1) === "*" && (r3 = "i32"), r3) {
                case "i1":
                case "i8":
                  R[e3 >> 0] = t2;
                  break;
                case "i16":
                  L[e3 >> 1] = t2;
                  break;
                case "i32":
                  W[e3 >> 2] = t2;
                  break;
                case "i64":
                  ue = [t2 >>> 0, (ae = t2, +Math.abs(ae) >= 1 ? ae > 0 ? (0 | Math.min(+Math.floor(ae / 4294967296), 4294967295)) >>> 0 : ~~+Math.ceil((ae - +(~~ae >>> 0)) / 4294967296) >>> 0 : 0)], W[e3 >> 2] = ue[0], W[e3 + 4 >> 2] = ue[1];
                  break;
                case "float":
                  O[e3 >> 2] = t2;
                  break;
                case "double":
                  Z[e3 >> 3] = t2;
                  break;
                default:
                  oe("invalid type for setValue: " + r3);
              }
            }
            function N(e3, t2, r3) {
              switch ((t2 = t2 || "i8").charAt(t2.length - 1) === "*" && (t2 = "i32"), t2) {
                case "i1":
                case "i8":
                  return R[e3 >> 0];
                case "i16":
                  return L[e3 >> 1];
                case "i32":
                case "i64":
                  return W[e3 >> 2];
                case "float":
                  return O[e3 >> 2];
                case "double":
                  return Z[e3 >> 3];
                default:
                  oe("invalid type for getValue: " + t2);
              }
              return null;
            }
            typeof WebAssembly != "object" && oe("no native wasm support detected");
            var P = false;
            function k(e3, t2) {
              e3 || oe("Assertion failed: " + t2);
            }
            var C = 1;
            var q, R, T, L, W, O, Z, F = typeof TextDecoder != "undefined" ? new TextDecoder("utf8") : void 0;
            function $(e3, t2, r3) {
              for (var n2 = t2 + r3, s2 = t2; e3[s2] && !(s2 >= n2); )
                ++s2;
              if (s2 - t2 > 16 && e3.subarray && F)
                return F.decode(e3.subarray(t2, s2));
              for (var o2 = ""; t2 < s2; ) {
                var _2 = e3[t2++];
                if (128 & _2) {
                  var a2 = 63 & e3[t2++];
                  if ((224 & _2) != 192) {
                    var u2 = 63 & e3[t2++];
                    if ((_2 = (240 & _2) == 224 ? (15 & _2) << 12 | a2 << 6 | u2 : (7 & _2) << 18 | a2 << 12 | u2 << 6 | 63 & e3[t2++]) < 65536)
                      o2 += String.fromCharCode(_2);
                    else {
                      var i2 = _2 - 65536;
                      o2 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2);
                    }
                  } else
                    o2 += String.fromCharCode((31 & _2) << 6 | a2);
                } else
                  o2 += String.fromCharCode(_2);
              }
              return o2;
            }
            function j(e3, t2) {
              return e3 ? $(T, e3, t2) : "";
            }
            function U(e3, t2, r3, n2) {
              if (!(n2 > 0))
                return 0;
              for (var s2 = r3, o2 = r3 + n2 - 1, _2 = 0; _2 < e3.length; ++_2) {
                var a2 = e3.charCodeAt(_2);
                if (a2 >= 55296 && a2 <= 57343)
                  a2 = 65536 + ((1023 & a2) << 10) | 1023 & e3.charCodeAt(++_2);
                if (a2 <= 127) {
                  if (r3 >= o2)
                    break;
                  t2[r3++] = a2;
                } else if (a2 <= 2047) {
                  if (r3 + 1 >= o2)
                    break;
                  t2[r3++] = 192 | a2 >> 6, t2[r3++] = 128 | 63 & a2;
                } else if (a2 <= 65535) {
                  if (r3 + 2 >= o2)
                    break;
                  t2[r3++] = 224 | a2 >> 12, t2[r3++] = 128 | a2 >> 6 & 63, t2[r3++] = 128 | 63 & a2;
                } else {
                  if (r3 + 3 >= o2)
                    break;
                  t2[r3++] = 240 | a2 >> 18, t2[r3++] = 128 | a2 >> 12 & 63, t2[r3++] = 128 | a2 >> 6 & 63, t2[r3++] = 128 | 63 & a2;
                }
              }
              return t2[r3] = 0, r3 - s2;
            }
            function D(e3, t2, r3) {
              return U(e3, T, t2, r3);
            }
            function z(e3) {
              for (var t2 = 0, r3 = 0; r3 < e3.length; ++r3) {
                var n2 = e3.charCodeAt(r3);
                n2 >= 55296 && n2 <= 57343 && (n2 = 65536 + ((1023 & n2) << 10) | 1023 & e3.charCodeAt(++r3)), n2 <= 127 ? ++t2 : t2 += n2 <= 2047 ? 2 : n2 <= 65535 ? 3 : 4;
              }
              return t2;
            }
            function G(e3) {
              var t2 = z(e3) + 1, r3 = ze(t2);
              return U(e3, R, r3, t2), r3;
            }
            function H(e3) {
              q = e3, Module.HEAP8 = R = new Int8Array(e3), Module.HEAP16 = L = new Int16Array(e3), Module.HEAP32 = W = new Int32Array(e3), Module.HEAPU8 = T = new Uint8Array(e3), Module.HEAPU16 = new Uint16Array(e3), Module.HEAPU32 = new Uint32Array(e3), Module.HEAPF32 = O = new Float32Array(e3), Module.HEAPF64 = Z = new Float64Array(e3);
            }
            var B = Module.INITIAL_MEMORY || 33554432;
            (A = Module.wasmMemory ? Module.wasmMemory : new WebAssembly.Memory({ initial: B / 65536, maximum: 32768 })) && (q = A.buffer), B = q.byteLength, H(q);
            var K = new WebAssembly.Table({ initial: 17, element: "anyfunc" }), V = [], X = [], Q = [], J = [], Y = false;
            var ee = 0, te = null, re = null;
            function ne(e3) {
              ee++, Module.monitorRunDependencies && Module.monitorRunDependencies(ee);
            }
            function se(e3) {
              if (ee--, Module.monitorRunDependencies && Module.monitorRunDependencies(ee), ee == 0 && (te !== null && (clearInterval(te), te = null), re)) {
                var t2 = re;
                re = null, t2();
              }
            }
            function oe(e3) {
              throw Module.onAbort && Module.onAbort(e3), g(e3 += ""), P = true, 1, e3 = "abort(" + e3 + "). Build with -s ASSERTIONS=1 for more info.", new WebAssembly.RuntimeError(e3);
            }
            Module.preloadedImages = {}, Module.preloadedAudios = {}, Module.preloadedWasm = {};
            var _e, ae, ue, ie = "data:application/octet-stream;base64,";
            function le(e3) {
              return e3.startsWith(ie);
            }
            function de(e3) {
              return e3.startsWith("file://");
            }
            function ce(e3) {
              try {
                if (e3 == _e && v)
                  return new Uint8Array(v);
                if (m)
                  return m(e3);
                throw "both async and sync fetching of the wasm failed";
              } catch (e4) {
                oe(e4);
              }
            }
            le(_e = "tree-sitter.wasm") || (_e = function(e3) {
              return Module.locateFile ? Module.locateFile(e3, h) : h + e3;
            }(_e));
            var me = {}, fe = { get: function(e3, t2) {
              return me[t2] || (me[t2] = new WebAssembly.Global({ value: "i32", mutable: true })), me[t2];
            } };
            function pe(e3) {
              for (; e3.length > 0; ) {
                var t2 = e3.shift();
                if (typeof t2 != "function") {
                  var r3 = t2.func;
                  typeof r3 == "number" ? t2.arg === void 0 ? K.get(r3)() : K.get(r3)(t2.arg) : r3(t2.arg === void 0 ? null : t2.arg);
                } else
                  t2(Module);
              }
            }
            function he(e3) {
              var t2 = 0;
              function r3() {
                for (var r4 = 0, n3 = 1; ; ) {
                  var s3 = e3[t2++];
                  if (r4 += (127 & s3) * n3, n3 *= 128, !(128 & s3))
                    break;
                }
                return r4;
              }
              if (e3 instanceof WebAssembly.Module) {
                var n2 = WebAssembly.Module.customSections(e3, "dylink");
                k(n2.length != 0, "need dylink section"), e3 = new Int8Array(n2[0]);
              } else {
                k(new Uint32Array(new Uint8Array(e3.subarray(0, 24)).buffer)[0] == 1836278016, "need to see wasm magic number"), k(e3[8] === 0, "need the dylink section to be first"), t2 = 9, r3(), k(e3[t2] === 6), k(e3[++t2] === "d".charCodeAt(0)), k(e3[++t2] === "y".charCodeAt(0)), k(e3[++t2] === "l".charCodeAt(0)), k(e3[++t2] === "i".charCodeAt(0)), k(e3[++t2] === "n".charCodeAt(0)), k(e3[++t2] === "k".charCodeAt(0)), t2++;
              }
              var s2 = {};
              s2.memorySize = r3(), s2.memoryAlign = r3(), s2.tableSize = r3(), s2.tableAlign = r3();
              var o2 = r3();
              s2.neededDynlibs = [];
              for (var _2 = 0; _2 < o2; ++_2) {
                var a2 = r3(), u2 = e3.subarray(t2, t2 + a2);
                t2 += a2;
                var i2 = $(u2, 0);
                s2.neededDynlibs.push(i2);
              }
              return s2;
            }
            var ge = 0;
            function we() {
              return S || ge > 0;
            }
            function ye(e3) {
              return e3.indexOf("dynCall_") == 0 || ["stackAlloc", "stackSave", "stackRestore"].includes(e3) ? e3 : "_" + e3;
            }
            function Me(e3, t2) {
              for (var r3 in e3)
                if (e3.hasOwnProperty(r3)) {
                  Fe.hasOwnProperty(r3) || (Fe[r3] = e3[r3]);
                  var n2 = ye(r3);
                  Module.hasOwnProperty(n2) || (Module[n2] = e3[r3]);
                }
            }
            var be = { nextHandle: 1, loadedLibs: {}, loadedLibNames: {} };
            function ve(e3, t2, r3) {
              return e3.includes("j") ? function(e4, t3, r4) {
                var n2 = Module["dynCall_" + e4];
                return r4 && r4.length ? n2.apply(null, [t3].concat(r4)) : n2.call(null, t3);
              }(e3, t2, r3) : K.get(t2).apply(null, r3);
            }
            var Ee = 5250880;
            function Ie(e3) {
              return ["__cpp_exception", "__wasm_apply_data_relocs", "__dso_handle", "__set_stack_limits"].includes(e3);
            }
            function Ae(e3, t2) {
              var r3 = {};
              for (var n2 in e3) {
                var s2 = e3[n2];
                typeof s2 == "object" && (s2 = s2.value), typeof s2 == "number" && (s2 += t2), r3[n2] = s2;
              }
              return function(e4) {
                for (var t3 in e4)
                  if (!Ie(t3)) {
                    var r4 = false, n3 = e4[t3];
                    t3.startsWith("orig$") && (t3 = t3.split("$")[1], r4 = true), me[t3] || (me[t3] = new WebAssembly.Global({ value: "i32", mutable: true })), (r4 || me[t3].value == 0) && (typeof n3 == "function" ? me[t3].value = b(n3) : typeof n3 == "number" ? me[t3].value = n3 : g("unhandled export type for `" + t3 + "`: " + typeof n3));
                  }
              }(r3), r3;
            }
            function Se(e3, t2) {
              var r3, n2;
              return t2 && (r3 = Fe["orig$" + e3]), r3 || (r3 = Fe[e3]), r3 || (r3 = Module[ye(e3)]), !r3 && e3.startsWith("invoke_") && (n2 = e3.split("_")[1], r3 = function() {
                var e4 = Ue();
                try {
                  return ve(n2, arguments[0], Array.prototype.slice.call(arguments, 1));
                } catch (t3) {
                  if (De(e4), t3 !== t3 + 0 && t3 !== "longjmp")
                    throw t3;
                  Ge(1, 0);
                }
              }), r3;
            }
            function xe(e3, t2) {
              var r3 = he(e3);
              function n2() {
                var n3 = Math.pow(2, r3.memoryAlign);
                n3 = Math.max(n3, w);
                var s2, o2, _2, a2 = (s2 = function(e4) {
                  if (Y)
                    return $e(e4);
                  var t3 = Ee, r4 = t3 + e4 + 15 & -16;
                  return Ee = r4, me.__heap_base.value = r4, t3;
                }(r3.memorySize + n3), (o2 = n3) || (o2 = w), Math.ceil(s2 / o2) * o2), u2 = K.length;
                K.grow(r3.tableSize);
                for (var i2 = a2; i2 < a2 + r3.memorySize; i2++)
                  R[i2] = 0;
                for (i2 = u2; i2 < u2 + r3.tableSize; i2++)
                  K.set(i2, null);
                var l2 = new Proxy({}, { get: function(e4, t3) {
                  switch (t3) {
                    case "__memory_base":
                      return a2;
                    case "__table_base":
                      return u2;
                  }
                  if (t3 in Fe)
                    return Fe[t3];
                  var r4;
                  t3 in e4 || (e4[t3] = function() {
                    return r4 || (r4 = function(e5) {
                      var t4 = Se(e5, false);
                      return t4 || (t4 = _2[e5]), t4;
                    }(t3)), r4.apply(null, arguments);
                  });
                  return e4[t3];
                } }), d2 = { "GOT.mem": new Proxy({}, fe), "GOT.func": new Proxy({}, fe), env: l2, wasi_snapshot_preview1: l2 };
                function c2(e4) {
                  for (var n4 = 0; n4 < r3.tableSize; n4++) {
                    var s3 = K.get(u2 + n4);
                    s3 && y.set(s3, u2 + n4);
                  }
                  _2 = Ae(e4.exports, a2), t2.allowUndefined || Pe();
                  var o3 = _2.__wasm_call_ctors;
                  return o3 || (o3 = _2.__post_instantiate), o3 && (Y ? o3() : X.push(o3)), _2;
                }
                if (t2.loadAsync) {
                  if (e3 instanceof WebAssembly.Module) {
                    var m2 = new WebAssembly.Instance(e3, d2);
                    return Promise.resolve(c2(m2));
                  }
                  return WebAssembly.instantiate(e3, d2).then(function(e4) {
                    return c2(e4.instance);
                  });
                }
                var f2 = e3 instanceof WebAssembly.Module ? e3 : new WebAssembly.Module(e3);
                return c2(m2 = new WebAssembly.Instance(f2, d2));
              }
              return t2.loadAsync ? r3.neededDynlibs.reduce(function(e4, r4) {
                return e4.then(function() {
                  return Ne(r4, t2);
                });
              }, Promise.resolve()).then(function() {
                return n2();
              }) : (r3.neededDynlibs.forEach(function(e4) {
                Ne(e4, t2);
              }), n2());
            }
            function Ne(e3, t2) {
              e3 != "__main__" || be.loadedLibNames[e3] || (be.loadedLibs[-1] = { refcount: 1 / 0, name: "__main__", module: Module.asm, global: true }, be.loadedLibNames.__main__ = -1), t2 = t2 || { global: true, nodelete: true };
              var r3, n2 = be.loadedLibNames[e3];
              if (n2)
                return r3 = be.loadedLibs[n2], t2.global && !r3.global && (r3.global = true, r3.module !== "loading" && Me(r3.module)), t2.nodelete && r3.refcount !== 1 / 0 && (r3.refcount = 1 / 0), r3.refcount++, t2.loadAsync ? Promise.resolve(n2) : n2;
              function s2(e4) {
                if (t2.fs) {
                  var r4 = t2.fs.readFile(e4, { encoding: "binary" });
                  return r4 instanceof Uint8Array || (r4 = new Uint8Array(r4)), t2.loadAsync ? Promise.resolve(r4) : r4;
                }
                return t2.loadAsync ? (n3 = e4, fetch(n3, { credentials: "same-origin" }).then(function(e5) {
                  if (!e5.ok)
                    throw "failed to load binary file at '" + n3 + "'";
                  return e5.arrayBuffer();
                }).then(function(e5) {
                  return new Uint8Array(e5);
                })) : m(e4);
                var n3;
              }
              function o2() {
                if (Module.preloadedWasm !== void 0 && Module.preloadedWasm[e3] !== void 0) {
                  var r4 = Module.preloadedWasm[e3];
                  return t2.loadAsync ? Promise.resolve(r4) : r4;
                }
                return t2.loadAsync ? s2(e3).then(function(e4) {
                  return xe(e4, t2);
                }) : xe(s2(e3), t2);
              }
              function _2(e4) {
                r3.global && Me(e4), r3.module = e4;
              }
              return n2 = be.nextHandle++, r3 = { refcount: t2.nodelete ? 1 / 0 : 1, name: e3, module: "loading", global: t2.global }, be.loadedLibNames[e3] = n2, be.loadedLibs[n2] = r3, t2.loadAsync ? o2().then(function(e4) {
                return _2(e4), n2;
              }) : (_2(o2()), n2);
            }
            function Pe() {
              for (var e3 in me)
                if (me[e3].value == 0) {
                  var t2 = Se(e3, true);
                  typeof t2 == "function" ? me[e3].value = b(t2, t2.sig) : typeof t2 == "number" ? me[e3].value = t2 : k(false, "bad export type for `" + e3 + "`: " + typeof t2);
                }
            }
            Module.___heap_base = Ee;
            var ke, Ce = new WebAssembly.Global({ value: "i32", mutable: true }, 5250880);
            function qe() {
              oe();
            }
            Module._abort = qe, qe.sig = "v", ke = s ? function() {
              var e3 = process.hrtime();
              return 1e3 * e3[0] + e3[1] / 1e6;
            } : typeof dateNow != "undefined" ? dateNow : function() {
              return performance.now();
            };
            var Re = true;
            function Te(e3, t2) {
              var r3, n2;
              if (e3 === 0)
                r3 = Date.now();
              else {
                if (e3 !== 1 && e3 !== 4 || !Re)
                  return n2 = 28, W[je() >> 2] = n2, -1;
                r3 = ke();
              }
              return W[t2 >> 2] = r3 / 1e3 | 0, W[t2 + 4 >> 2] = r3 % 1e3 * 1e3 * 1e3 | 0, 0;
            }
            function Le(e3) {
              try {
                return A.grow(e3 - q.byteLength + 65535 >>> 16), H(A.buffer), 1;
              } catch (e4) {
              }
            }
            function We(e3) {
              Ve(e3);
            }
            function Oe(e3) {
              E(e3);
            }
            Te.sig = "iii", We.sig = "vi", Oe.sig = "vi";
            var Ze, Fe = { __heap_base: Ee, __indirect_function_table: K, __memory_base: 1024, __stack_pointer: Ce, __table_base: 1, abort: qe, clock_gettime: Te, emscripten_memcpy_big: function(e3, t2, r3) {
              T.copyWithin(e3, t2, t2 + r3);
            }, emscripten_resize_heap: function(e3) {
              var t2, r3, n2 = T.length;
              if ((e3 >>>= 0) > 2147483648)
                return false;
              for (var s2 = 1; s2 <= 4; s2 *= 2) {
                var o2 = n2 * (1 + 0.2 / s2);
                if (o2 = Math.min(o2, e3 + 100663296), Le(Math.min(2147483648, ((t2 = Math.max(e3, o2)) % (r3 = 65536) > 0 && (t2 += r3 - t2 % r3), t2))))
                  return true;
              }
              return false;
            }, exit: We, memory: A, setTempRet0: Oe, tree_sitter_log_callback: function(e3, t2) {
              if (ct) {
                const r3 = j(t2);
                ct(r3, e3 !== 0);
              }
            }, tree_sitter_parse_callback: function(e3, t2, r3, n2, s2) {
              var o2 = dt(t2, { row: r3, column: n2 });
              typeof o2 == "string" ? (x(s2, o2.length, "i32"), function(e4, t3, r4) {
                if (r4 === void 0 && (r4 = 2147483647), r4 < 2)
                  return 0;
                for (var n3 = (r4 -= 2) < 2 * e4.length ? r4 / 2 : e4.length, s3 = 0; s3 < n3; ++s3) {
                  var o3 = e4.charCodeAt(s3);
                  L[t3 >> 1] = o3, t3 += 2;
                }
                L[t3 >> 1] = 0;
              }(o2, e3, 10240)) : x(s2, 0, "i32");
            } }, $e = (function() {
              var e3 = { env: Fe, wasi_snapshot_preview1: Fe, "GOT.mem": new Proxy(Fe, fe), "GOT.func": new Proxy(Fe, fe) };
              function t2(e4, t3) {
                var r4 = e4.exports;
                r4 = Ae(r4, 1024), Module.asm = r4;
                var n3, s2 = he(t3);
                s2.neededDynlibs && (I = s2.neededDynlibs.concat(I)), Me(r4), n3 = Module.asm.__wasm_call_ctors, X.unshift(n3), se();
              }
              function r3(e4) {
                t2(e4.instance, e4.module);
              }
              function n2(t3) {
                return function() {
                  if (!v && (i || l)) {
                    if (typeof fetch == "function" && !de(_e))
                      return fetch(_e, { credentials: "same-origin" }).then(function(e4) {
                        if (!e4.ok)
                          throw "failed to load wasm binary file at '" + _e + "'";
                        return e4.arrayBuffer();
                      }).catch(function() {
                        return ce(_e);
                      });
                    if (c)
                      return new Promise(function(e4, t4) {
                        c(_e, function(t5) {
                          e4(new Uint8Array(t5));
                        }, t4);
                      });
                  }
                  return Promise.resolve().then(function() {
                    return ce(_e);
                  });
                }().then(function(t4) {
                  return WebAssembly.instantiate(t4, e3);
                }).then(t3, function(e4) {
                  g("failed to asynchronously prepare wasm: " + e4), oe(e4);
                });
              }
              if (ne(), Module.instantiateWasm)
                try {
                  return Module.instantiateWasm(e3, t2);
                } catch (e4) {
                  return g("Module.instantiateWasm callback failed with error: " + e4), false;
                }
              v || typeof WebAssembly.instantiateStreaming != "function" || le(_e) || de(_e) || typeof fetch != "function" ? n2(r3) : fetch(_e, { credentials: "same-origin" }).then(function(t3) {
                return WebAssembly.instantiateStreaming(t3, e3).then(r3, function(e4) {
                  return g("wasm streaming compile failed: " + e4), g("falling back to ArrayBuffer instantiation"), n2(r3);
                });
              });
            }(), Module.___wasm_call_ctors = function() {
              return (Module.___wasm_call_ctors = Module.asm.__wasm_call_ctors).apply(null, arguments);
            }, Module._malloc = function() {
              return ($e = Module._malloc = Module.asm.malloc).apply(null, arguments);
            }), je = (Module._calloc = function() {
              return (Module._calloc = Module.asm.calloc).apply(null, arguments);
            }, Module._realloc = function() {
              return (Module._realloc = Module.asm.realloc).apply(null, arguments);
            }, Module._free = function() {
              return (Module._free = Module.asm.free).apply(null, arguments);
            }, Module._ts_language_symbol_count = function() {
              return (Module._ts_language_symbol_count = Module.asm.ts_language_symbol_count).apply(null, arguments);
            }, Module._ts_language_version = function() {
              return (Module._ts_language_version = Module.asm.ts_language_version).apply(null, arguments);
            }, Module._ts_language_field_count = function() {
              return (Module._ts_language_field_count = Module.asm.ts_language_field_count).apply(null, arguments);
            }, Module._ts_language_symbol_name = function() {
              return (Module._ts_language_symbol_name = Module.asm.ts_language_symbol_name).apply(null, arguments);
            }, Module._ts_language_symbol_for_name = function() {
              return (Module._ts_language_symbol_for_name = Module.asm.ts_language_symbol_for_name).apply(null, arguments);
            }, Module._ts_language_symbol_type = function() {
              return (Module._ts_language_symbol_type = Module.asm.ts_language_symbol_type).apply(null, arguments);
            }, Module._ts_language_field_name_for_id = function() {
              return (Module._ts_language_field_name_for_id = Module.asm.ts_language_field_name_for_id).apply(null, arguments);
            }, Module._memcpy = function() {
              return (Module._memcpy = Module.asm.memcpy).apply(null, arguments);
            }, Module._ts_parser_delete = function() {
              return (Module._ts_parser_delete = Module.asm.ts_parser_delete).apply(null, arguments);
            }, Module._ts_parser_reset = function() {
              return (Module._ts_parser_reset = Module.asm.ts_parser_reset).apply(null, arguments);
            }, Module._ts_parser_set_language = function() {
              return (Module._ts_parser_set_language = Module.asm.ts_parser_set_language).apply(null, arguments);
            }, Module._ts_parser_timeout_micros = function() {
              return (Module._ts_parser_timeout_micros = Module.asm.ts_parser_timeout_micros).apply(null, arguments);
            }, Module._ts_parser_set_timeout_micros = function() {
              return (Module._ts_parser_set_timeout_micros = Module.asm.ts_parser_set_timeout_micros).apply(null, arguments);
            }, Module._memmove = function() {
              return (Module._memmove = Module.asm.memmove).apply(null, arguments);
            }, Module._memcmp = function() {
              return (Module._memcmp = Module.asm.memcmp).apply(null, arguments);
            }, Module._ts_query_new = function() {
              return (Module._ts_query_new = Module.asm.ts_query_new).apply(null, arguments);
            }, Module._ts_query_delete = function() {
              return (Module._ts_query_delete = Module.asm.ts_query_delete).apply(null, arguments);
            }, Module._iswspace = function() {
              return (Module._iswspace = Module.asm.iswspace).apply(null, arguments);
            }, Module._iswalnum = function() {
              return (Module._iswalnum = Module.asm.iswalnum).apply(null, arguments);
            }, Module._ts_query_pattern_count = function() {
              return (Module._ts_query_pattern_count = Module.asm.ts_query_pattern_count).apply(null, arguments);
            }, Module._ts_query_capture_count = function() {
              return (Module._ts_query_capture_count = Module.asm.ts_query_capture_count).apply(null, arguments);
            }, Module._ts_query_string_count = function() {
              return (Module._ts_query_string_count = Module.asm.ts_query_string_count).apply(null, arguments);
            }, Module._ts_query_capture_name_for_id = function() {
              return (Module._ts_query_capture_name_for_id = Module.asm.ts_query_capture_name_for_id).apply(null, arguments);
            }, Module._ts_query_string_value_for_id = function() {
              return (Module._ts_query_string_value_for_id = Module.asm.ts_query_string_value_for_id).apply(null, arguments);
            }, Module._ts_query_predicates_for_pattern = function() {
              return (Module._ts_query_predicates_for_pattern = Module.asm.ts_query_predicates_for_pattern).apply(null, arguments);
            }, Module._ts_tree_copy = function() {
              return (Module._ts_tree_copy = Module.asm.ts_tree_copy).apply(null, arguments);
            }, Module._ts_tree_delete = function() {
              return (Module._ts_tree_delete = Module.asm.ts_tree_delete).apply(null, arguments);
            }, Module._ts_init = function() {
              return (Module._ts_init = Module.asm.ts_init).apply(null, arguments);
            }, Module._ts_parser_new_wasm = function() {
              return (Module._ts_parser_new_wasm = Module.asm.ts_parser_new_wasm).apply(null, arguments);
            }, Module._ts_parser_enable_logger_wasm = function() {
              return (Module._ts_parser_enable_logger_wasm = Module.asm.ts_parser_enable_logger_wasm).apply(null, arguments);
            }, Module._ts_parser_parse_wasm = function() {
              return (Module._ts_parser_parse_wasm = Module.asm.ts_parser_parse_wasm).apply(null, arguments);
            }, Module._ts_language_type_is_named_wasm = function() {
              return (Module._ts_language_type_is_named_wasm = Module.asm.ts_language_type_is_named_wasm).apply(null, arguments);
            }, Module._ts_language_type_is_visible_wasm = function() {
              return (Module._ts_language_type_is_visible_wasm = Module.asm.ts_language_type_is_visible_wasm).apply(null, arguments);
            }, Module._ts_tree_root_node_wasm = function() {
              return (Module._ts_tree_root_node_wasm = Module.asm.ts_tree_root_node_wasm).apply(null, arguments);
            }, Module._ts_tree_edit_wasm = function() {
              return (Module._ts_tree_edit_wasm = Module.asm.ts_tree_edit_wasm).apply(null, arguments);
            }, Module._ts_tree_get_changed_ranges_wasm = function() {
              return (Module._ts_tree_get_changed_ranges_wasm = Module.asm.ts_tree_get_changed_ranges_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_new_wasm = function() {
              return (Module._ts_tree_cursor_new_wasm = Module.asm.ts_tree_cursor_new_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_delete_wasm = function() {
              return (Module._ts_tree_cursor_delete_wasm = Module.asm.ts_tree_cursor_delete_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_reset_wasm = function() {
              return (Module._ts_tree_cursor_reset_wasm = Module.asm.ts_tree_cursor_reset_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_first_child_wasm = function() {
              return (Module._ts_tree_cursor_goto_first_child_wasm = Module.asm.ts_tree_cursor_goto_first_child_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_next_sibling_wasm = function() {
              return (Module._ts_tree_cursor_goto_next_sibling_wasm = Module.asm.ts_tree_cursor_goto_next_sibling_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_goto_parent_wasm = function() {
              return (Module._ts_tree_cursor_goto_parent_wasm = Module.asm.ts_tree_cursor_goto_parent_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_type_id_wasm = function() {
              return (Module._ts_tree_cursor_current_node_type_id_wasm = Module.asm.ts_tree_cursor_current_node_type_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_is_named_wasm = function() {
              return (Module._ts_tree_cursor_current_node_is_named_wasm = Module.asm.ts_tree_cursor_current_node_is_named_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_is_missing_wasm = function() {
              return (Module._ts_tree_cursor_current_node_is_missing_wasm = Module.asm.ts_tree_cursor_current_node_is_missing_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_id_wasm = function() {
              return (Module._ts_tree_cursor_current_node_id_wasm = Module.asm.ts_tree_cursor_current_node_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_start_position_wasm = function() {
              return (Module._ts_tree_cursor_start_position_wasm = Module.asm.ts_tree_cursor_start_position_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_end_position_wasm = function() {
              return (Module._ts_tree_cursor_end_position_wasm = Module.asm.ts_tree_cursor_end_position_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_start_index_wasm = function() {
              return (Module._ts_tree_cursor_start_index_wasm = Module.asm.ts_tree_cursor_start_index_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_end_index_wasm = function() {
              return (Module._ts_tree_cursor_end_index_wasm = Module.asm.ts_tree_cursor_end_index_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_field_id_wasm = function() {
              return (Module._ts_tree_cursor_current_field_id_wasm = Module.asm.ts_tree_cursor_current_field_id_wasm).apply(null, arguments);
            }, Module._ts_tree_cursor_current_node_wasm = function() {
              return (Module._ts_tree_cursor_current_node_wasm = Module.asm.ts_tree_cursor_current_node_wasm).apply(null, arguments);
            }, Module._ts_node_symbol_wasm = function() {
              return (Module._ts_node_symbol_wasm = Module.asm.ts_node_symbol_wasm).apply(null, arguments);
            }, Module._ts_node_child_count_wasm = function() {
              return (Module._ts_node_child_count_wasm = Module.asm.ts_node_child_count_wasm).apply(null, arguments);
            }, Module._ts_node_named_child_count_wasm = function() {
              return (Module._ts_node_named_child_count_wasm = Module.asm.ts_node_named_child_count_wasm).apply(null, arguments);
            }, Module._ts_node_child_wasm = function() {
              return (Module._ts_node_child_wasm = Module.asm.ts_node_child_wasm).apply(null, arguments);
            }, Module._ts_node_named_child_wasm = function() {
              return (Module._ts_node_named_child_wasm = Module.asm.ts_node_named_child_wasm).apply(null, arguments);
            }, Module._ts_node_child_by_field_id_wasm = function() {
              return (Module._ts_node_child_by_field_id_wasm = Module.asm.ts_node_child_by_field_id_wasm).apply(null, arguments);
            }, Module._ts_node_next_sibling_wasm = function() {
              return (Module._ts_node_next_sibling_wasm = Module.asm.ts_node_next_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_prev_sibling_wasm = function() {
              return (Module._ts_node_prev_sibling_wasm = Module.asm.ts_node_prev_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_next_named_sibling_wasm = function() {
              return (Module._ts_node_next_named_sibling_wasm = Module.asm.ts_node_next_named_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_prev_named_sibling_wasm = function() {
              return (Module._ts_node_prev_named_sibling_wasm = Module.asm.ts_node_prev_named_sibling_wasm).apply(null, arguments);
            }, Module._ts_node_parent_wasm = function() {
              return (Module._ts_node_parent_wasm = Module.asm.ts_node_parent_wasm).apply(null, arguments);
            }, Module._ts_node_descendant_for_index_wasm = function() {
              return (Module._ts_node_descendant_for_index_wasm = Module.asm.ts_node_descendant_for_index_wasm).apply(null, arguments);
            }, Module._ts_node_named_descendant_for_index_wasm = function() {
              return (Module._ts_node_named_descendant_for_index_wasm = Module.asm.ts_node_named_descendant_for_index_wasm).apply(null, arguments);
            }, Module._ts_node_descendant_for_position_wasm = function() {
              return (Module._ts_node_descendant_for_position_wasm = Module.asm.ts_node_descendant_for_position_wasm).apply(null, arguments);
            }, Module._ts_node_named_descendant_for_position_wasm = function() {
              return (Module._ts_node_named_descendant_for_position_wasm = Module.asm.ts_node_named_descendant_for_position_wasm).apply(null, arguments);
            }, Module._ts_node_start_point_wasm = function() {
              return (Module._ts_node_start_point_wasm = Module.asm.ts_node_start_point_wasm).apply(null, arguments);
            }, Module._ts_node_end_point_wasm = function() {
              return (Module._ts_node_end_point_wasm = Module.asm.ts_node_end_point_wasm).apply(null, arguments);
            }, Module._ts_node_start_index_wasm = function() {
              return (Module._ts_node_start_index_wasm = Module.asm.ts_node_start_index_wasm).apply(null, arguments);
            }, Module._ts_node_end_index_wasm = function() {
              return (Module._ts_node_end_index_wasm = Module.asm.ts_node_end_index_wasm).apply(null, arguments);
            }, Module._ts_node_to_string_wasm = function() {
              return (Module._ts_node_to_string_wasm = Module.asm.ts_node_to_string_wasm).apply(null, arguments);
            }, Module._ts_node_children_wasm = function() {
              return (Module._ts_node_children_wasm = Module.asm.ts_node_children_wasm).apply(null, arguments);
            }, Module._ts_node_named_children_wasm = function() {
              return (Module._ts_node_named_children_wasm = Module.asm.ts_node_named_children_wasm).apply(null, arguments);
            }, Module._ts_node_descendants_of_type_wasm = function() {
              return (Module._ts_node_descendants_of_type_wasm = Module.asm.ts_node_descendants_of_type_wasm).apply(null, arguments);
            }, Module._ts_node_is_named_wasm = function() {
              return (Module._ts_node_is_named_wasm = Module.asm.ts_node_is_named_wasm).apply(null, arguments);
            }, Module._ts_node_has_changes_wasm = function() {
              return (Module._ts_node_has_changes_wasm = Module.asm.ts_node_has_changes_wasm).apply(null, arguments);
            }, Module._ts_node_has_error_wasm = function() {
              return (Module._ts_node_has_error_wasm = Module.asm.ts_node_has_error_wasm).apply(null, arguments);
            }, Module._ts_node_is_missing_wasm = function() {
              return (Module._ts_node_is_missing_wasm = Module.asm.ts_node_is_missing_wasm).apply(null, arguments);
            }, Module._ts_query_matches_wasm = function() {
              return (Module._ts_query_matches_wasm = Module.asm.ts_query_matches_wasm).apply(null, arguments);
            }, Module._ts_query_captures_wasm = function() {
              return (Module._ts_query_captures_wasm = Module.asm.ts_query_captures_wasm).apply(null, arguments);
            }, Module._iswdigit = function() {
              return (Module._iswdigit = Module.asm.iswdigit).apply(null, arguments);
            }, Module._iswalpha = function() {
              return (Module._iswalpha = Module.asm.iswalpha).apply(null, arguments);
            }, Module._iswlower = function() {
              return (Module._iswlower = Module.asm.iswlower).apply(null, arguments);
            }, Module._towupper = function() {
              return (Module._towupper = Module.asm.towupper).apply(null, arguments);
            }, Module.___errno_location = function() {
              return (je = Module.___errno_location = Module.asm.__errno_location).apply(null, arguments);
            }), Ue = (Module._memchr = function() {
              return (Module._memchr = Module.asm.memchr).apply(null, arguments);
            }, Module._strlen = function() {
              return (Module._strlen = Module.asm.strlen).apply(null, arguments);
            }, Module.stackSave = function() {
              return (Ue = Module.stackSave = Module.asm.stackSave).apply(null, arguments);
            }), De = Module.stackRestore = function() {
              return (De = Module.stackRestore = Module.asm.stackRestore).apply(null, arguments);
            }, ze = Module.stackAlloc = function() {
              return (ze = Module.stackAlloc = Module.asm.stackAlloc).apply(null, arguments);
            }, Ge = Module._setThrew = function() {
              return (Ge = Module._setThrew = Module.asm.setThrew).apply(null, arguments);
            };
            Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEED2Ev).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9__grow_byEmmmmmm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE6__initEPKcm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE7reserveEm).apply(null, arguments);
            }, Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = function() {
              return (Module.__ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm = Module.asm._ZNKSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE4copyEPcmm).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = function() {
              return (Module.__ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc = Module.asm._ZNSt3__212basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEE9push_backEc).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = function() {
              return (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEED2Ev).apply(null, arguments);
            }, Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = function() {
              return (Module.__ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw = Module.asm._ZNSt3__212basic_stringIwNS_11char_traitsIwEENS_9allocatorIwEEE9push_backEw).apply(null, arguments);
            }, Module.__Znwm = function() {
              return (Module.__Znwm = Module.asm._Znwm).apply(null, arguments);
            }, Module.__ZdlPv = function() {
              return (Module.__ZdlPv = Module.asm._ZdlPv).apply(null, arguments);
            }, Module.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = function() {
              return (Module.__ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv = Module.asm._ZNKSt3__220__vector_base_commonILb1EE20__throw_length_errorEv).apply(null, arguments);
            }, Module._orig$ts_parser_timeout_micros = function() {
              return (Module._orig$ts_parser_timeout_micros = Module.asm.orig$ts_parser_timeout_micros).apply(null, arguments);
            }, Module._orig$ts_parser_set_timeout_micros = function() {
              return (Module._orig$ts_parser_set_timeout_micros = Module.asm.orig$ts_parser_set_timeout_micros).apply(null, arguments);
            };
            function He(e3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + e3 + ")", this.status = e3;
            }
            Module.allocate = function(e3, t2) {
              var r3;
              return r3 = t2 == C ? ze(e3.length) : $e(e3.length), e3.subarray || e3.slice ? T.set(e3, r3) : T.set(new Uint8Array(e3), r3), r3;
            };
            re = function e3() {
              Ze || Ke(), Ze || (re = e3);
            };
            var Be = false;
            function Ke(e3) {
              function t2() {
                Ze || (Ze = true, Module.calledRun = true, P || (Y = true, pe(X), pe(Q), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), Xe && function(e4) {
                  var t3 = Module._main;
                  if (t3) {
                    var r3 = (e4 = e4 || []).length + 1, n2 = ze(4 * (r3 + 1));
                    W[n2 >> 2] = G(a);
                    for (var s2 = 1; s2 < r3; s2++)
                      W[(n2 >> 2) + s2] = G(e4[s2 - 1]);
                    W[(n2 >> 2) + r3] = 0;
                    try {
                      Ve(t3(r3, n2), true);
                    } catch (e5) {
                      if (e5 instanceof He)
                        return;
                      if (e5 == "unwind")
                        return;
                      var o2 = e5;
                      e5 && typeof e5 == "object" && e5.stack && (o2 = [e5, e5.stack]), g("exception thrown: " + o2), u(1, e5);
                    } finally {
                    }
                  }
                }(e3), function() {
                  if (Module.postRun)
                    for (typeof Module.postRun == "function" && (Module.postRun = [Module.postRun]); Module.postRun.length; )
                      e4 = Module.postRun.shift(), J.unshift(e4);
                  var e4;
                  pe(J);
                }()));
              }
              e3 = e3 || _, ee > 0 || !Be && (function() {
                if (I.length) {
                  if (!m)
                    return ne(), void I.reduce(function(e4, t3) {
                      return e4.then(function() {
                        return Ne(t3, { loadAsync: true, global: true, nodelete: true, allowUndefined: true });
                      });
                    }, Promise.resolve()).then(function() {
                      se(), Pe();
                    });
                  I.forEach(function(e4) {
                    Ne(e4, { global: true, nodelete: true, allowUndefined: true });
                  }), Pe();
                } else
                  Pe();
              }(), Be = true, ee > 0) || (!function() {
                if (Module.preRun)
                  for (typeof Module.preRun == "function" && (Module.preRun = [Module.preRun]); Module.preRun.length; )
                    e4 = Module.preRun.shift(), V.unshift(e4);
                var e4;
                pe(V);
              }(), ee > 0 || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout(function() {
                setTimeout(function() {
                  Module.setStatus("");
                }, 1), t2();
              }, 1)) : t2()));
            }
            function Ve(e3, t2) {
              e3, t2 && we() && e3 === 0 || (we() || (true, Module.onExit && Module.onExit(e3), P = true), u(e3, new He(e3)));
            }
            if (Module.run = Ke, Module.preInit)
              for (typeof Module.preInit == "function" && (Module.preInit = [Module.preInit]); Module.preInit.length > 0; )
                Module.preInit.pop()();
            var Xe = true;
            Module.noInitialRun && (Xe = false), Ke();
            const Qe = Module, Je = {}, Ye = 4, et = 5 * Ye, tt = 2 * Ye, rt = 2 * Ye + 2 * tt, nt = { row: 0, column: 0 }, st = /[\w-.]*/g, ot = 1, _t = 2, at = /^_?tree_sitter_\w+/;
            var ut, it, lt, dt, ct;
            class ParserImpl {
              static init() {
                lt = Qe._ts_init(), ut = N(lt, "i32"), it = N(lt + Ye, "i32");
              }
              initialize() {
                Qe._ts_parser_new_wasm(), this[0] = N(lt, "i32"), this[1] = N(lt + Ye, "i32");
              }
              delete() {
                Qe._ts_parser_delete(this[0]), Qe._free(this[1]), this[0] = 0, this[1] = 0;
              }
              setLanguage(e3) {
                let t2;
                if (e3) {
                  if (e3.constructor !== Language)
                    throw new Error("Argument must be a Language");
                  {
                    t2 = e3[0];
                    const r3 = Qe._ts_language_version(t2);
                    if (r3 < it || ut < r3)
                      throw new Error(`Incompatible language version ${r3}. Compatibility range ${it} through ${ut}.`);
                  }
                } else
                  t2 = 0, e3 = null;
                return this.language = e3, Qe._ts_parser_set_language(this[0], t2), this;
              }
              getLanguage() {
                return this.language;
              }
              parse(e3, t2, r3) {
                if (typeof e3 == "string")
                  dt = (t3, r4, n3) => e3.slice(t3, n3);
                else {
                  if (typeof e3 != "function")
                    throw new Error("Argument must be a string or a function");
                  dt = e3;
                }
                this.logCallback ? (ct = this.logCallback, Qe._ts_parser_enable_logger_wasm(this[0], 1)) : (ct = null, Qe._ts_parser_enable_logger_wasm(this[0], 0));
                let n2 = 0, s2 = 0;
                if (r3 && r3.includedRanges) {
                  n2 = r3.includedRanges.length;
                  let e4 = s2 = Qe._calloc(n2, rt);
                  for (let t3 = 0; t3 < n2; t3++)
                    Et(e4, r3.includedRanges[t3]), e4 += rt;
                }
                const o2 = Qe._ts_parser_parse_wasm(this[0], this[1], t2 ? t2[0] : 0, s2, n2);
                if (!o2)
                  throw dt = null, ct = null, new Error("Parsing failed");
                const _2 = new Tree(Je, o2, this.language, dt);
                return dt = null, ct = null, _2;
              }
              reset() {
                Qe._ts_parser_reset(this[0]);
              }
              setTimeoutMicros(e3) {
                Qe._ts_parser_set_timeout_micros(this[0], e3);
              }
              getTimeoutMicros() {
                return Qe._ts_parser_timeout_micros(this[0]);
              }
              setLogger(e3) {
                if (e3) {
                  if (typeof e3 != "function")
                    throw new Error("Logger callback must be a function");
                } else
                  e3 = null;
                return this.logCallback = e3, this;
              }
              getLogger() {
                return this.logCallback;
              }
            }
            class Tree {
              constructor(e3, t2, r3, n2) {
                pt(e3), this[0] = t2, this.language = r3, this.textCallback = n2;
              }
              copy() {
                const e3 = Qe._ts_tree_copy(this[0]);
                return new Tree(Je, e3, this.language, this.textCallback);
              }
              delete() {
                Qe._ts_tree_delete(this[0]), this[0] = 0;
              }
              edit(e3) {
                !function(e4) {
                  let t2 = lt;
                  bt(t2, e4.startPosition), bt(t2 += tt, e4.oldEndPosition), bt(t2 += tt, e4.newEndPosition), x(t2 += tt, e4.startIndex, "i32"), x(t2 += Ye, e4.oldEndIndex, "i32"), x(t2 += Ye, e4.newEndIndex, "i32"), t2 += Ye;
                }(e3), Qe._ts_tree_edit_wasm(this[0]);
              }
              get rootNode() {
                return Qe._ts_tree_root_node_wasm(this[0]), wt(this);
              }
              getLanguage() {
                return this.language;
              }
              walk() {
                return this.rootNode.walk();
              }
              getChangedRanges(e3) {
                if (e3.constructor !== Tree)
                  throw new TypeError("Argument must be a Tree");
                Qe._ts_tree_get_changed_ranges_wasm(this[0], e3[0]);
                const t2 = N(lt, "i32"), r3 = N(lt + Ye, "i32"), n2 = new Array(t2);
                if (t2 > 0) {
                  let e4 = r3;
                  for (let r4 = 0; r4 < t2; r4++)
                    n2[r4] = It(e4), e4 += rt;
                  Qe._free(r3);
                }
                return n2;
              }
            }
            class Node {
              constructor(e3, t2) {
                pt(e3), this.tree = t2;
              }
              get typeId() {
                return gt(this), Qe._ts_node_symbol_wasm(this.tree[0]);
              }
              get type() {
                return this.tree.language.types[this.typeId] || "ERROR";
              }
              get endPosition() {
                return gt(this), Qe._ts_node_end_point_wasm(this.tree[0]), vt(lt);
              }
              get endIndex() {
                return gt(this), Qe._ts_node_end_index_wasm(this.tree[0]);
              }
              get text() {
                return mt(this.tree, this.startIndex, this.endIndex);
              }
              isNamed() {
                return gt(this), Qe._ts_node_is_named_wasm(this.tree[0]) === 1;
              }
              hasError() {
                return gt(this), Qe._ts_node_has_error_wasm(this.tree[0]) === 1;
              }
              hasChanges() {
                return gt(this), Qe._ts_node_has_changes_wasm(this.tree[0]) === 1;
              }
              isMissing() {
                return gt(this), Qe._ts_node_is_missing_wasm(this.tree[0]) === 1;
              }
              equals(e3) {
                return this.id === e3.id;
              }
              child(e3) {
                return gt(this), Qe._ts_node_child_wasm(this.tree[0], e3), wt(this.tree);
              }
              namedChild(e3) {
                return gt(this), Qe._ts_node_named_child_wasm(this.tree[0], e3), wt(this.tree);
              }
              childForFieldId(e3) {
                return gt(this), Qe._ts_node_child_by_field_id_wasm(this.tree[0], e3), wt(this.tree);
              }
              childForFieldName(e3) {
                const t2 = this.tree.language.fields.indexOf(e3);
                if (t2 !== -1)
                  return this.childForFieldId(t2);
              }
              get childCount() {
                return gt(this), Qe._ts_node_child_count_wasm(this.tree[0]);
              }
              get namedChildCount() {
                return gt(this), Qe._ts_node_named_child_count_wasm(this.tree[0]);
              }
              get firstChild() {
                return this.child(0);
              }
              get firstNamedChild() {
                return this.namedChild(0);
              }
              get lastChild() {
                return this.child(this.childCount - 1);
              }
              get lastNamedChild() {
                return this.namedChild(this.namedChildCount - 1);
              }
              get children() {
                if (!this._children) {
                  gt(this), Qe._ts_node_children_wasm(this.tree[0]);
                  const e3 = N(lt, "i32"), t2 = N(lt + Ye, "i32");
                  if (this._children = new Array(e3), e3 > 0) {
                    let r3 = t2;
                    for (let t3 = 0; t3 < e3; t3++)
                      this._children[t3] = wt(this.tree, r3), r3 += et;
                    Qe._free(t2);
                  }
                }
                return this._children;
              }
              get namedChildren() {
                if (!this._namedChildren) {
                  gt(this), Qe._ts_node_named_children_wasm(this.tree[0]);
                  const e3 = N(lt, "i32"), t2 = N(lt + Ye, "i32");
                  if (this._namedChildren = new Array(e3), e3 > 0) {
                    let r3 = t2;
                    for (let t3 = 0; t3 < e3; t3++)
                      this._namedChildren[t3] = wt(this.tree, r3), r3 += et;
                    Qe._free(t2);
                  }
                }
                return this._namedChildren;
              }
              descendantsOfType(e3, t2, r3) {
                Array.isArray(e3) || (e3 = [e3]), t2 || (t2 = nt), r3 || (r3 = nt);
                const n2 = [], s2 = this.tree.language.types;
                for (let t3 = 0, r4 = s2.length; t3 < r4; t3++)
                  e3.includes(s2[t3]) && n2.push(t3);
                const o2 = Qe._malloc(Ye * n2.length);
                for (let e4 = 0, t3 = n2.length; e4 < t3; e4++)
                  x(o2 + e4 * Ye, n2[e4], "i32");
                gt(this), Qe._ts_node_descendants_of_type_wasm(this.tree[0], o2, n2.length, t2.row, t2.column, r3.row, r3.column);
                const _2 = N(lt, "i32"), a2 = N(lt + Ye, "i32"), u2 = new Array(_2);
                if (_2 > 0) {
                  let e4 = a2;
                  for (let t3 = 0; t3 < _2; t3++)
                    u2[t3] = wt(this.tree, e4), e4 += et;
                }
                return Qe._free(a2), Qe._free(o2), u2;
              }
              get nextSibling() {
                return gt(this), Qe._ts_node_next_sibling_wasm(this.tree[0]), wt(this.tree);
              }
              get previousSibling() {
                return gt(this), Qe._ts_node_prev_sibling_wasm(this.tree[0]), wt(this.tree);
              }
              get nextNamedSibling() {
                return gt(this), Qe._ts_node_next_named_sibling_wasm(this.tree[0]), wt(this.tree);
              }
              get previousNamedSibling() {
                return gt(this), Qe._ts_node_prev_named_sibling_wasm(this.tree[0]), wt(this.tree);
              }
              get parent() {
                return gt(this), Qe._ts_node_parent_wasm(this.tree[0]), wt(this.tree);
              }
              descendantForIndex(e3, t2 = e3) {
                if (typeof e3 != "number" || typeof t2 != "number")
                  throw new Error("Arguments must be numbers");
                gt(this);
                let r3 = lt + et;
                return x(r3, e3, "i32"), x(r3 + Ye, t2, "i32"), Qe._ts_node_descendant_for_index_wasm(this.tree[0]), wt(this.tree);
              }
              namedDescendantForIndex(e3, t2 = e3) {
                if (typeof e3 != "number" || typeof t2 != "number")
                  throw new Error("Arguments must be numbers");
                gt(this);
                let r3 = lt + et;
                return x(r3, e3, "i32"), x(r3 + Ye, t2, "i32"), Qe._ts_node_named_descendant_for_index_wasm(this.tree[0]), wt(this.tree);
              }
              descendantForPosition(e3, t2 = e3) {
                if (!ht(e3) || !ht(t2))
                  throw new Error("Arguments must be {row, column} objects");
                gt(this);
                let r3 = lt + et;
                return bt(r3, e3), bt(r3 + tt, t2), Qe._ts_node_descendant_for_position_wasm(this.tree[0]), wt(this.tree);
              }
              namedDescendantForPosition(e3, t2 = e3) {
                if (!ht(e3) || !ht(t2))
                  throw new Error("Arguments must be {row, column} objects");
                gt(this);
                let r3 = lt + et;
                return bt(r3, e3), bt(r3 + tt, t2), Qe._ts_node_named_descendant_for_position_wasm(this.tree[0]), wt(this.tree);
              }
              walk() {
                return gt(this), Qe._ts_tree_cursor_new_wasm(this.tree[0]), new TreeCursor(Je, this.tree);
              }
              toString() {
                gt(this);
                const e3 = Qe._ts_node_to_string_wasm(this.tree[0]), t2 = function(e4) {
                  for (var t3 = ""; ; ) {
                    var r3 = T[e4++ >> 0];
                    if (!r3)
                      return t3;
                    t3 += String.fromCharCode(r3);
                  }
                }(e3);
                return Qe._free(e3), t2;
              }
            }
            class TreeCursor {
              constructor(e3, t2) {
                pt(e3), this.tree = t2, Mt(this);
              }
              delete() {
                yt(this), Qe._ts_tree_cursor_delete_wasm(this.tree[0]), this[0] = this[1] = this[2] = 0;
              }
              reset(e3) {
                gt(e3), yt(this, lt + et), Qe._ts_tree_cursor_reset_wasm(this.tree[0]), Mt(this);
              }
              get nodeType() {
                return this.tree.language.types[this.nodeTypeId] || "ERROR";
              }
              get nodeTypeId() {
                return yt(this), Qe._ts_tree_cursor_current_node_type_id_wasm(this.tree[0]);
              }
              get nodeId() {
                return yt(this), Qe._ts_tree_cursor_current_node_id_wasm(this.tree[0]);
              }
              get nodeIsNamed() {
                return yt(this), Qe._ts_tree_cursor_current_node_is_named_wasm(this.tree[0]) === 1;
              }
              get nodeIsMissing() {
                return yt(this), Qe._ts_tree_cursor_current_node_is_missing_wasm(this.tree[0]) === 1;
              }
              get nodeText() {
                yt(this);
                const e3 = Qe._ts_tree_cursor_start_index_wasm(this.tree[0]), t2 = Qe._ts_tree_cursor_end_index_wasm(this.tree[0]);
                return mt(this.tree, e3, t2);
              }
              get startPosition() {
                return yt(this), Qe._ts_tree_cursor_start_position_wasm(this.tree[0]), vt(lt);
              }
              get endPosition() {
                return yt(this), Qe._ts_tree_cursor_end_position_wasm(this.tree[0]), vt(lt);
              }
              get startIndex() {
                return yt(this), Qe._ts_tree_cursor_start_index_wasm(this.tree[0]);
              }
              get endIndex() {
                return yt(this), Qe._ts_tree_cursor_end_index_wasm(this.tree[0]);
              }
              currentNode() {
                return yt(this), Qe._ts_tree_cursor_current_node_wasm(this.tree[0]), wt(this.tree);
              }
              currentFieldId() {
                return yt(this), Qe._ts_tree_cursor_current_field_id_wasm(this.tree[0]);
              }
              currentFieldName() {
                return this.tree.language.fields[this.currentFieldId()];
              }
              gotoFirstChild() {
                yt(this);
                const e3 = Qe._ts_tree_cursor_goto_first_child_wasm(this.tree[0]);
                return Mt(this), e3 === 1;
              }
              gotoNextSibling() {
                yt(this);
                const e3 = Qe._ts_tree_cursor_goto_next_sibling_wasm(this.tree[0]);
                return Mt(this), e3 === 1;
              }
              gotoParent() {
                yt(this);
                const e3 = Qe._ts_tree_cursor_goto_parent_wasm(this.tree[0]);
                return Mt(this), e3 === 1;
              }
            }
            class Language {
              constructor(e3, t2) {
                pt(e3), this[0] = t2, this.types = new Array(Qe._ts_language_symbol_count(this[0]));
                for (let e4 = 0, t3 = this.types.length; e4 < t3; e4++)
                  Qe._ts_language_symbol_type(this[0], e4) < 2 && (this.types[e4] = j(Qe._ts_language_symbol_name(this[0], e4)));
                this.fields = new Array(Qe._ts_language_field_count(this[0]) + 1);
                for (let e4 = 0, t3 = this.fields.length; e4 < t3; e4++) {
                  const t4 = Qe._ts_language_field_name_for_id(this[0], e4);
                  this.fields[e4] = t4 !== 0 ? j(t4) : null;
                }
              }
              get version() {
                return Qe._ts_language_version(this[0]);
              }
              get fieldCount() {
                return this.fields.length - 1;
              }
              fieldIdForName(e3) {
                const t2 = this.fields.indexOf(e3);
                return t2 !== -1 ? t2 : null;
              }
              fieldNameForId(e3) {
                return this.fields[e3] || null;
              }
              idForNodeType(e3, t2) {
                const r3 = z(e3), n2 = Qe._malloc(r3 + 1);
                D(e3, n2, r3 + 1);
                const s2 = Qe._ts_language_symbol_for_name(this[0], n2, r3, t2);
                return Qe._free(n2), s2 || null;
              }
              get nodeTypeCount() {
                return Qe._ts_language_symbol_count(this[0]);
              }
              nodeTypeForId(e3) {
                const t2 = Qe._ts_language_symbol_name(this[0], e3);
                return t2 ? j(t2) : null;
              }
              nodeTypeIsNamed(e3) {
                return !!Qe._ts_language_type_is_named_wasm(this[0], e3);
              }
              nodeTypeIsVisible(e3) {
                return !!Qe._ts_language_type_is_visible_wasm(this[0], e3);
              }
              query(e3) {
                const t2 = z(e3), r3 = Qe._malloc(t2 + 1);
                D(e3, r3, t2 + 1);
                const n2 = Qe._ts_query_new(this[0], r3, t2, lt, lt + Ye);
                if (!n2) {
                  const t3 = N(lt + Ye, "i32"), n3 = j(r3, N(lt, "i32")).length, s3 = e3.substr(n3, 100).split("\n")[0];
                  let o3, _3 = s3.match(st)[0];
                  switch (t3) {
                    case 2:
                      o3 = new RangeError(`Bad node name '${_3}'`);
                      break;
                    case 3:
                      o3 = new RangeError(`Bad field name '${_3}'`);
                      break;
                    case 4:
                      o3 = new RangeError(`Bad capture name @${_3}`);
                      break;
                    case 5:
                      o3 = new TypeError(`Bad pattern structure at offset ${n3}: '${s3}'...`), _3 = "";
                      break;
                    default:
                      o3 = new SyntaxError(`Bad syntax at offset ${n3}: '${s3}'...`), _3 = "";
                  }
                  throw o3.index = n3, o3.length = _3.length, Qe._free(r3), o3;
                }
                const s2 = Qe._ts_query_string_count(n2), o2 = Qe._ts_query_capture_count(n2), _2 = Qe._ts_query_pattern_count(n2), a2 = new Array(o2), u2 = new Array(s2);
                for (let e4 = 0; e4 < o2; e4++) {
                  const t3 = Qe._ts_query_capture_name_for_id(n2, e4, lt), r4 = N(lt, "i32");
                  a2[e4] = j(t3, r4);
                }
                for (let e4 = 0; e4 < s2; e4++) {
                  const t3 = Qe._ts_query_string_value_for_id(n2, e4, lt), r4 = N(lt, "i32");
                  u2[e4] = j(t3, r4);
                }
                const i2 = new Array(_2), l2 = new Array(_2), d2 = new Array(_2), c2 = new Array(_2), m2 = new Array(_2);
                for (let e4 = 0; e4 < _2; e4++) {
                  const t3 = Qe._ts_query_predicates_for_pattern(n2, e4, lt), r4 = N(lt, "i32");
                  c2[e4] = [], m2[e4] = [];
                  const s3 = [];
                  let o3 = t3;
                  for (let t4 = 0; t4 < r4; t4++) {
                    const t5 = N(o3, "i32"), r5 = N(o3 += Ye, "i32");
                    if (o3 += Ye, t5 === ot)
                      s3.push({ type: "capture", name: a2[r5] });
                    else if (t5 === _t)
                      s3.push({ type: "string", value: u2[r5] });
                    else if (s3.length > 0) {
                      if (s3[0].type !== "string")
                        throw new Error("Predicates must begin with a literal value");
                      const t6 = s3[0].value;
                      let r6 = true;
                      switch (t6) {
                        case "not-eq?":
                          r6 = false;
                        case "eq?":
                          if (s3.length !== 3)
                            throw new Error(`Wrong number of arguments to \`#eq?\` predicate. Expected 2, got ${s3.length - 1}`);
                          if (s3[1].type !== "capture")
                            throw new Error(`First argument of \`#eq?\` predicate must be a capture. Got "${s3[1].value}"`);
                          if (s3[2].type === "capture") {
                            const t7 = s3[1].name, n4 = s3[2].name;
                            m2[e4].push(function(e5) {
                              let s4, o5;
                              for (const r7 of e5)
                                r7.name === t7 && (s4 = r7.node), r7.name === n4 && (o5 = r7.node);
                              return s4 === void 0 || o5 === void 0 || s4.text === o5.text === r6;
                            });
                          } else {
                            const t7 = s3[1].name, n4 = s3[2].value;
                            m2[e4].push(function(e5) {
                              for (const s4 of e5)
                                if (s4.name === t7)
                                  return s4.node.text === n4 === r6;
                              return true;
                            });
                          }
                          break;
                        case "not-match?":
                          r6 = false;
                        case "match?":
                          if (s3.length !== 3)
                            throw new Error(`Wrong number of arguments to \`#match?\` predicate. Expected 2, got ${s3.length - 1}.`);
                          if (s3[1].type !== "capture")
                            throw new Error(`First argument of \`#match?\` predicate must be a capture. Got "${s3[1].value}".`);
                          if (s3[2].type !== "string")
                            throw new Error(`Second argument of \`#match?\` predicate must be a string. Got @${s3[2].value}.`);
                          const n3 = s3[1].name, o4 = new RegExp(s3[2].value);
                          m2[e4].push(function(e5) {
                            for (const t7 of e5)
                              if (t7.name === n3)
                                return o4.test(t7.node.text) === r6;
                            return true;
                          });
                          break;
                        case "set!":
                          if (s3.length < 2 || s3.length > 3)
                            throw new Error(`Wrong number of arguments to \`#set!\` predicate. Expected 1 or 2. Got ${s3.length - 1}.`);
                          if (s3.some((e5) => e5.type !== "string"))
                            throw new Error('Arguments to `#set!` predicate must be a strings.".');
                          i2[e4] || (i2[e4] = {}), i2[e4][s3[1].value] = s3[2] ? s3[2].value : null;
                          break;
                        case "is?":
                        case "is-not?":
                          if (s3.length < 2 || s3.length > 3)
                            throw new Error(`Wrong number of arguments to \`#${t6}\` predicate. Expected 1 or 2. Got ${s3.length - 1}.`);
                          if (s3.some((e5) => e5.type !== "string"))
                            throw new Error(`Arguments to \`#${t6}\` predicate must be a strings.".`);
                          const _3 = t6 === "is?" ? l2 : d2;
                          _3[e4] || (_3[e4] = {}), _3[e4][s3[1].value] = s3[2] ? s3[2].value : null;
                          break;
                        default:
                          c2[e4].push({ operator: t6, operands: s3.slice(1) });
                      }
                      s3.length = 0;
                    }
                  }
                  Object.freeze(i2[e4]), Object.freeze(l2[e4]), Object.freeze(d2[e4]);
                }
                return Qe._free(r3), new Query(Je, n2, a2, m2, c2, Object.freeze(i2), Object.freeze(l2), Object.freeze(d2));
              }
              static load(e3) {
                let t2;
                if (e3 instanceof Uint8Array)
                  t2 = Promise.resolve(e3);
                else {
                  const r4 = e3;
                  if (typeof process != "undefined" && process.versions && process.versions.node) {
                    const e4 = require("fs");
                    t2 = Promise.resolve(e4.readFileSync(r4));
                  } else
                    t2 = fetch(r4).then((e4) => e4.arrayBuffer().then((t3) => {
                      if (e4.ok)
                        return new Uint8Array(t3);
                      {
                        const r5 = new TextDecoder("utf-8").decode(t3);
                        throw new Error(`Language.load failed with status ${e4.status}.

${r5}`);
                      }
                    }));
                }
                const r3 = typeof loadSideModule == "function" ? loadSideModule : xe;
                return t2.then((e4) => r3(e4, { loadAsync: true })).then((e4) => {
                  const t3 = Object.keys(e4), r4 = t3.find((e5) => at.test(e5) && !e5.includes("external_scanner_"));
                  r4 || console.log(`Couldn't find language function in WASM file. Symbols:
${JSON.stringify(t3, null, 2)}`);
                  const n2 = e4[r4]();
                  return new Language(Je, n2);
                });
              }
            }
            class Query {
              constructor(e3, t2, r3, n2, s2, o2, _2, a2) {
                pt(e3), this[0] = t2, this.captureNames = r3, this.textPredicates = n2, this.predicates = s2, this.setProperties = o2, this.assertedProperties = _2, this.refutedProperties = a2, this.exceededMatchLimit = false;
              }
              delete() {
                Qe._ts_query_delete(this[0]), this[0] = 0;
              }
              matches(e3, t2, r3, n2) {
                t2 || (t2 = nt), r3 || (r3 = nt), n2 || (n2 = {});
                let s2 = n2.matchLimit;
                if (s2 === void 0)
                  s2 = 0;
                else if (typeof s2 != "number")
                  throw new Error("Arguments must be numbers");
                gt(e3), Qe._ts_query_matches_wasm(this[0], e3.tree[0], t2.row, t2.column, r3.row, r3.column, s2);
                const o2 = N(lt, "i32"), _2 = N(lt + Ye, "i32"), a2 = N(lt + 2 * Ye, "i32"), u2 = new Array(o2);
                this.exceededMatchLimit = !!a2;
                let i2 = 0, l2 = _2;
                for (let t3 = 0; t3 < o2; t3++) {
                  const r4 = N(l2, "i32"), n3 = N(l2 += Ye, "i32");
                  l2 += Ye;
                  const s3 = new Array(n3);
                  if (l2 = ft(this, e3.tree, l2, s3), this.textPredicates[r4].every((e4) => e4(s3))) {
                    u2[i2++] = { pattern: r4, captures: s3 };
                    const e4 = this.setProperties[r4];
                    e4 && (u2[t3].setProperties = e4);
                    const n4 = this.assertedProperties[r4];
                    n4 && (u2[t3].assertedProperties = n4);
                    const o3 = this.refutedProperties[r4];
                    o3 && (u2[t3].refutedProperties = o3);
                  }
                }
                return u2.length = i2, Qe._free(_2), u2;
              }
              captures(e3, t2, r3, n2) {
                t2 || (t2 = nt), r3 || (r3 = nt), n2 || (n2 = {});
                let s2 = n2.matchLimit;
                if (s2 === void 0)
                  s2 = 0;
                else if (typeof s2 != "number")
                  throw new Error("Arguments must be numbers");
                gt(e3), Qe._ts_query_captures_wasm(this[0], e3.tree[0], t2.row, t2.column, r3.row, r3.column, s2);
                const o2 = N(lt, "i32"), _2 = N(lt + Ye, "i32"), a2 = N(lt + 2 * Ye, "i32"), u2 = [];
                this.exceededMatchLimit = !!a2;
                const i2 = [];
                let l2 = _2;
                for (let t3 = 0; t3 < o2; t3++) {
                  const t4 = N(l2, "i32"), r4 = N(l2 += Ye, "i32"), n3 = N(l2 += Ye, "i32");
                  if (l2 += Ye, i2.length = r4, l2 = ft(this, e3.tree, l2, i2), this.textPredicates[t4].every((e4) => e4(i2))) {
                    const e4 = i2[n3], r5 = this.setProperties[t4];
                    r5 && (e4.setProperties = r5);
                    const s3 = this.assertedProperties[t4];
                    s3 && (e4.assertedProperties = s3);
                    const o3 = this.refutedProperties[t4];
                    o3 && (e4.refutedProperties = o3), u2.push(e4);
                  }
                }
                return Qe._free(_2), u2;
              }
              predicatesForPattern(e3) {
                return this.predicates[e3];
              }
              didExceedMatchLimit() {
                return this.exceededMatchLimit;
              }
            }
            function mt(e3, t2, r3) {
              const n2 = r3 - t2;
              let s2 = e3.textCallback(t2, null, r3);
              for (t2 += s2.length; t2 < r3; ) {
                const n3 = e3.textCallback(t2, null, r3);
                if (!(n3 && n3.length > 0))
                  break;
                t2 += n3.length, s2 += n3;
              }
              return t2 > r3 && (s2 = s2.slice(0, n2)), s2;
            }
            function ft(e3, t2, r3, n2) {
              for (let s2 = 0, o2 = n2.length; s2 < o2; s2++) {
                const o3 = N(r3, "i32"), _2 = wt(t2, r3 += Ye);
                r3 += et, n2[s2] = { name: e3.captureNames[o3], node: _2 };
              }
              return r3;
            }
            function pt(e3) {
              if (e3 !== Je)
                throw new Error("Illegal constructor");
            }
            function ht(e3) {
              return e3 && typeof e3.row == "number" && typeof e3.column == "number";
            }
            function gt(e3) {
              let t2 = lt;
              x(t2, e3.id, "i32"), x(t2 += Ye, e3.startIndex, "i32"), x(t2 += Ye, e3.startPosition.row, "i32"), x(t2 += Ye, e3.startPosition.column, "i32"), x(t2 += Ye, e3[0], "i32");
            }
            function wt(e3, t2 = lt) {
              const r3 = N(t2, "i32");
              if (r3 === 0)
                return null;
              const n2 = N(t2 += Ye, "i32"), s2 = N(t2 += Ye, "i32"), o2 = N(t2 += Ye, "i32"), _2 = N(t2 += Ye, "i32"), a2 = new Node(Je, e3);
              return a2.id = r3, a2.startIndex = n2, a2.startPosition = { row: s2, column: o2 }, a2[0] = _2, a2;
            }
            function yt(e3, t2 = lt) {
              x(t2 + 0 * Ye, e3[0], "i32"), x(t2 + 1 * Ye, e3[1], "i32"), x(t2 + 2 * Ye, e3[2], "i32");
            }
            function Mt(e3) {
              e3[0] = N(lt + 0 * Ye, "i32"), e3[1] = N(lt + 1 * Ye, "i32"), e3[2] = N(lt + 2 * Ye, "i32");
            }
            function bt(e3, t2) {
              x(e3, t2.row, "i32"), x(e3 + Ye, t2.column, "i32");
            }
            function vt(e3) {
              return { row: N(e3, "i32"), column: N(e3 + Ye, "i32") };
            }
            function Et(e3, t2) {
              bt(e3, t2.startPosition), bt(e3 += tt, t2.endPosition), x(e3 += tt, t2.startIndex, "i32"), x(e3 += Ye, t2.endIndex, "i32"), e3 += Ye;
            }
            function It(e3) {
              const t2 = {};
              return t2.startPosition = vt(e3), e3 += tt, t2.endPosition = vt(e3), e3 += tt, t2.startIndex = N(e3, "i32"), e3 += Ye, t2.endIndex = N(e3, "i32"), t2;
            }
            for (const e3 of Object.getOwnPropertyNames(ParserImpl.prototype))
              Object.defineProperty(Parser.prototype, e3, { value: ParserImpl.prototype[e3], enumerable: false, writable: false });
            Parser.Language = Language, Module.onRuntimeInitialized = () => {
              ParserImpl.init(), e2();
            };
          }));
        }
      }
      return Parser;
    }();
    typeof exports2 == "object" && (module2.exports = TreeSitter);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/types.js
var require_types = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LanguageNames = void 0;
    exports2.LanguageNames = ["java", "typescript", "c_sharp", "php", "ruby"];
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/tree-sitter-wasm/WasmParserAdapter.js
var require_WasmParserAdapter = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/tree-sitter-wasm/WasmParserAdapter.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WasmParserAdapter = void 0;
    var web_tree_sitter_1 = __importDefault(require_tree_sitter());
    var types_js_1 = require_types();
    var WasmParserAdapter = function() {
      function WasmParserAdapter2(wasmBaseUrl) {
        this.wasmBaseUrl = wasmBaseUrl;
      }
      WasmParserAdapter2.prototype.init = function() {
        return __awaiter(this, void 0, void 0, function() {
          var languages;
          var _this = this;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                return [4, web_tree_sitter_1.default.init()];
              case 1:
                _a.sent();
                this.parser = new web_tree_sitter_1.default();
                return [
                  4,
                  Promise.all(types_js_1.LanguageNames.map(function(languageName) {
                    var wasmUrl = "".concat(_this.wasmBaseUrl, "/").concat(languageName, ".wasm");
                    try {
                      return web_tree_sitter_1.default.Language.load(wasmUrl);
                    } catch (err) {
                      console.error("Failed to load ".concat(wasmUrl, ": ").concat(err.message));
                    }
                  }))
                ];
              case 2:
                languages = _a.sent();
                this.languages = Object.fromEntries(types_js_1.LanguageNames.map(function(languageName, i) {
                  return [languageName, languages[i]];
                }));
                return [2];
            }
          });
        });
      };
      WasmParserAdapter2.prototype.query = function(source) {
        return this.parser.getLanguage().query(source);
      };
      WasmParserAdapter2.prototype.setLanguageName = function(languageName) {
        this.parser.setLanguage(this.languages[languageName]);
      };
      return WasmParserAdapter2;
    }();
    exports2.WasmParserAdapter = WasmParserAdapter;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/is.js
var require_is = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.thenable = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function thenable(value) {
      return value && func(value.then);
    }
    exports2.thenable = thenable;
  }
});

// node_modules/vscode-jsonrpc/lib/common/ral.js
var require_ral = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/ral.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _ral;
    function RAL() {
      if (_ral === void 0) {
        throw new Error(`No runtime abstraction layer installed`);
      }
      return _ral;
    }
    (function(RAL2) {
      function install(ral) {
        if (ral === void 0) {
          throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
      }
      RAL2.install = install;
    })(RAL || (RAL = {}));
    exports2.default = RAL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/disposable.js
var require_disposable = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/disposable.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Disposable = void 0;
    var Disposable;
    (function(Disposable2) {
      function create(func) {
        return {
          dispose: func
        };
      }
      Disposable2.create = create;
    })(Disposable = exports2.Disposable || (exports2.Disposable = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageBuffer.js
var require_messageBuffer = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageBuffer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractMessageBuffer = void 0;
    var CR = 13;
    var LF = 10;
    var CRLF = "\r\n";
    var AbstractMessageBuffer = class {
      constructor(encoding = "utf-8") {
        this._encoding = encoding;
        this._chunks = [];
        this._totalLength = 0;
      }
      get encoding() {
        return this._encoding;
      }
      append(chunk) {
        const toAppend = typeof chunk === "string" ? this.fromString(chunk, this._encoding) : chunk;
        this._chunks.push(toAppend);
        this._totalLength += toAppend.byteLength;
      }
      tryReadHeaders() {
        if (this._chunks.length === 0) {
          return void 0;
        }
        let state = 0;
        let chunkIndex = 0;
        let offset = 0;
        let chunkBytesRead = 0;
        row:
          while (chunkIndex < this._chunks.length) {
            const chunk = this._chunks[chunkIndex];
            offset = 0;
            column:
              while (offset < chunk.length) {
                const value = chunk[offset];
                switch (value) {
                  case CR:
                    switch (state) {
                      case 0:
                        state = 1;
                        break;
                      case 2:
                        state = 3;
                        break;
                      default:
                        state = 0;
                    }
                    break;
                  case LF:
                    switch (state) {
                      case 1:
                        state = 2;
                        break;
                      case 3:
                        state = 4;
                        offset++;
                        break row;
                      default:
                        state = 0;
                    }
                    break;
                  default:
                    state = 0;
                }
                offset++;
              }
            chunkBytesRead += chunk.byteLength;
            chunkIndex++;
          }
        if (state !== 4) {
          return void 0;
        }
        const buffer = this._read(chunkBytesRead + offset);
        const result = /* @__PURE__ */ new Map();
        const headers = this.toString(buffer, "ascii").split(CRLF);
        if (headers.length < 2) {
          return result;
        }
        for (let i = 0; i < headers.length - 2; i++) {
          const header = headers[i];
          const index = header.indexOf(":");
          if (index === -1) {
            throw new Error("Message header must separate key and value using :");
          }
          const key = header.substr(0, index);
          const value = header.substr(index + 1).trim();
          result.set(key, value);
        }
        return result;
      }
      tryReadBody(length) {
        if (this._totalLength < length) {
          return void 0;
        }
        return this._read(length);
      }
      get numberOfBytes() {
        return this._totalLength;
      }
      _read(byteCount) {
        if (byteCount === 0) {
          return this.emptyBuffer();
        }
        if (byteCount > this._totalLength) {
          throw new Error(`Cannot read so many bytes!`);
        }
        if (this._chunks[0].byteLength === byteCount) {
          const chunk = this._chunks[0];
          this._chunks.shift();
          this._totalLength -= byteCount;
          return this.asNative(chunk);
        }
        if (this._chunks[0].byteLength > byteCount) {
          const chunk = this._chunks[0];
          const result2 = this.asNative(chunk, byteCount);
          this._chunks[0] = chunk.slice(byteCount);
          this._totalLength -= byteCount;
          return result2;
        }
        const result = this.allocNative(byteCount);
        let resultOffset = 0;
        let chunkIndex = 0;
        while (byteCount > 0) {
          const chunk = this._chunks[chunkIndex];
          if (chunk.byteLength > byteCount) {
            const chunkPart = chunk.slice(0, byteCount);
            result.set(chunkPart, resultOffset);
            resultOffset += byteCount;
            this._chunks[chunkIndex] = chunk.slice(byteCount);
            this._totalLength -= byteCount;
            byteCount -= byteCount;
          } else {
            result.set(chunk, resultOffset);
            resultOffset += chunk.byteLength;
            this._chunks.shift();
            this._totalLength -= chunk.byteLength;
            byteCount -= chunk.byteLength;
          }
        }
        return result;
      }
    };
    exports2.AbstractMessageBuffer = AbstractMessageBuffer;
  }
});

// node_modules/vscode-jsonrpc/lib/node/ril.js
var require_ril = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/ril.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ral_1 = require_ral();
    var util_1 = require("util");
    var disposable_1 = require_disposable();
    var messageBuffer_1 = require_messageBuffer();
    var MessageBuffer = class extends messageBuffer_1.AbstractMessageBuffer {
      constructor(encoding = "utf-8") {
        super(encoding);
      }
      emptyBuffer() {
        return MessageBuffer.emptyBuffer;
      }
      fromString(value, encoding) {
        return Buffer.from(value, encoding);
      }
      toString(value, encoding) {
        if (value instanceof Buffer) {
          return value.toString(encoding);
        } else {
          return new util_1.TextDecoder(encoding).decode(value);
        }
      }
      asNative(buffer, length) {
        if (length === void 0) {
          return buffer instanceof Buffer ? buffer : Buffer.from(buffer);
        } else {
          return buffer instanceof Buffer ? buffer.slice(0, length) : Buffer.from(buffer, 0, length);
        }
      }
      allocNative(length) {
        return Buffer.allocUnsafe(length);
      }
    };
    MessageBuffer.emptyBuffer = Buffer.allocUnsafe(0);
    var ReadableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      onData(listener) {
        this.stream.on("data", listener);
        return disposable_1.Disposable.create(() => this.stream.off("data", listener));
      }
    };
    var WritableStreamWrapper = class {
      constructor(stream) {
        this.stream = stream;
      }
      onClose(listener) {
        this.stream.on("close", listener);
        return disposable_1.Disposable.create(() => this.stream.off("close", listener));
      }
      onError(listener) {
        this.stream.on("error", listener);
        return disposable_1.Disposable.create(() => this.stream.off("error", listener));
      }
      onEnd(listener) {
        this.stream.on("end", listener);
        return disposable_1.Disposable.create(() => this.stream.off("end", listener));
      }
      write(data, encoding) {
        return new Promise((resolve, reject) => {
          const callback = (error) => {
            if (error === void 0 || error === null) {
              resolve();
            } else {
              reject(error);
            }
          };
          if (typeof data === "string") {
            this.stream.write(data, encoding, callback);
          } else {
            this.stream.write(data, callback);
          }
        });
      }
      end() {
        this.stream.end();
      }
    };
    var _ril = Object.freeze({
      messageBuffer: Object.freeze({
        create: (encoding) => new MessageBuffer(encoding)
      }),
      applicationJson: Object.freeze({
        encoder: Object.freeze({
          name: "application/json",
          encode: (msg, options) => {
            try {
              return Promise.resolve(Buffer.from(JSON.stringify(msg, void 0, 0), options.charset));
            } catch (err) {
              return Promise.reject(err);
            }
          }
        }),
        decoder: Object.freeze({
          name: "application/json",
          decode: (buffer, options) => {
            try {
              if (buffer instanceof Buffer) {
                return Promise.resolve(JSON.parse(buffer.toString(options.charset)));
              } else {
                return Promise.resolve(JSON.parse(new util_1.TextDecoder(options.charset).decode(buffer)));
              }
            } catch (err) {
              return Promise.reject(err);
            }
          }
        })
      }),
      stream: Object.freeze({
        asReadableStream: (stream) => new ReadableStreamWrapper(stream),
        asWritableStream: (stream) => new WritableStreamWrapper(stream)
      }),
      console,
      timer: Object.freeze({
        setTimeout(callback, ms, ...args) {
          const handle = setTimeout(callback, ms, ...args);
          return { dispose: () => clearTimeout(handle) };
        },
        setImmediate(callback, ...args) {
          const handle = setImmediate(callback, ...args);
          return { dispose: () => clearImmediate(handle) };
        },
        setInterval(callback, ms, ...args) {
          const handle = setInterval(callback, ms, ...args);
          return { dispose: () => clearInterval(handle) };
        }
      })
    });
    function RIL() {
      return _ril;
    }
    (function(RIL2) {
      function install() {
        ral_1.default.install(_ril);
      }
      RIL2.install = install;
    })(RIL || (RIL = {}));
    exports2.default = RIL;
  }
});

// node_modules/vscode-jsonrpc/lib/common/is.js
var require_is2 = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messages.js
var require_messages = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Message = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType = exports2.RequestType0 = exports2.AbstractMessageSignature = exports2.ParameterStructures = exports2.ResponseError = exports2.ErrorCodes = void 0;
    var is = require_is2();
    var ErrorCodes;
    (function(ErrorCodes2) {
      ErrorCodes2.ParseError = -32700;
      ErrorCodes2.InvalidRequest = -32600;
      ErrorCodes2.MethodNotFound = -32601;
      ErrorCodes2.InvalidParams = -32602;
      ErrorCodes2.InternalError = -32603;
      ErrorCodes2.jsonrpcReservedErrorRangeStart = -32099;
      ErrorCodes2.serverErrorStart = -32099;
      ErrorCodes2.MessageWriteError = -32099;
      ErrorCodes2.MessageReadError = -32098;
      ErrorCodes2.PendingResponseRejected = -32097;
      ErrorCodes2.ConnectionInactive = -32096;
      ErrorCodes2.ServerNotInitialized = -32002;
      ErrorCodes2.UnknownErrorCode = -32001;
      ErrorCodes2.jsonrpcReservedErrorRangeEnd = -32e3;
      ErrorCodes2.serverErrorEnd = -32e3;
    })(ErrorCodes = exports2.ErrorCodes || (exports2.ErrorCodes = {}));
    var ResponseError = class extends Error {
      constructor(code, message, data) {
        super(message);
        this.code = is.number(code) ? code : ErrorCodes.UnknownErrorCode;
        this.data = data;
        Object.setPrototypeOf(this, ResponseError.prototype);
      }
      toJson() {
        const result = {
          code: this.code,
          message: this.message
        };
        if (this.data !== void 0) {
          result.data = this.data;
        }
        return result;
      }
    };
    exports2.ResponseError = ResponseError;
    var ParameterStructures = class {
      constructor(kind) {
        this.kind = kind;
      }
      static is(value) {
        return value === ParameterStructures.auto || value === ParameterStructures.byName || value === ParameterStructures.byPosition;
      }
      toString() {
        return this.kind;
      }
    };
    exports2.ParameterStructures = ParameterStructures;
    ParameterStructures.auto = new ParameterStructures("auto");
    ParameterStructures.byPosition = new ParameterStructures("byPosition");
    ParameterStructures.byName = new ParameterStructures("byName");
    var AbstractMessageSignature = class {
      constructor(method, numberOfParams) {
        this.method = method;
        this.numberOfParams = numberOfParams;
      }
      get parameterStructures() {
        return ParameterStructures.auto;
      }
    };
    exports2.AbstractMessageSignature = AbstractMessageSignature;
    var RequestType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.RequestType0 = RequestType0;
    var RequestType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType = RequestType;
    var RequestType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.RequestType1 = RequestType1;
    var RequestType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.RequestType2 = RequestType2;
    var RequestType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.RequestType3 = RequestType3;
    var RequestType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.RequestType4 = RequestType4;
    var RequestType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.RequestType5 = RequestType5;
    var RequestType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.RequestType6 = RequestType6;
    var RequestType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.RequestType7 = RequestType7;
    var RequestType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.RequestType8 = RequestType8;
    var RequestType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.RequestType9 = RequestType9;
    var NotificationType = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType = NotificationType;
    var NotificationType0 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 0);
      }
    };
    exports2.NotificationType0 = NotificationType0;
    var NotificationType1 = class extends AbstractMessageSignature {
      constructor(method, _parameterStructures = ParameterStructures.auto) {
        super(method, 1);
        this._parameterStructures = _parameterStructures;
      }
      get parameterStructures() {
        return this._parameterStructures;
      }
    };
    exports2.NotificationType1 = NotificationType1;
    var NotificationType2 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 2);
      }
    };
    exports2.NotificationType2 = NotificationType2;
    var NotificationType3 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 3);
      }
    };
    exports2.NotificationType3 = NotificationType3;
    var NotificationType4 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 4);
      }
    };
    exports2.NotificationType4 = NotificationType4;
    var NotificationType5 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 5);
      }
    };
    exports2.NotificationType5 = NotificationType5;
    var NotificationType6 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 6);
      }
    };
    exports2.NotificationType6 = NotificationType6;
    var NotificationType7 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 7);
      }
    };
    exports2.NotificationType7 = NotificationType7;
    var NotificationType8 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 8);
      }
    };
    exports2.NotificationType8 = NotificationType8;
    var NotificationType9 = class extends AbstractMessageSignature {
      constructor(method) {
        super(method, 9);
      }
    };
    exports2.NotificationType9 = NotificationType9;
    var Message;
    (function(Message2) {
      function isRequest(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && (is.string(candidate.id) || is.number(candidate.id));
      }
      Message2.isRequest = isRequest;
      function isNotification(message) {
        const candidate = message;
        return candidate && is.string(candidate.method) && message.id === void 0;
      }
      Message2.isNotification = isNotification;
      function isResponse(message) {
        const candidate = message;
        return candidate && (candidate.result !== void 0 || !!candidate.error) && (is.string(candidate.id) || is.number(candidate.id) || candidate.id === null);
      }
      Message2.isResponse = isResponse;
    })(Message = exports2.Message || (exports2.Message = {}));
  }
});

// node_modules/vscode-jsonrpc/lib/common/linkedMap.js
var require_linkedMap = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/linkedMap.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LRUCache = exports2.LinkedMap = exports2.Touch = void 0;
    var Touch;
    (function(Touch2) {
      Touch2.None = 0;
      Touch2.First = 1;
      Touch2.AsOld = Touch2.First;
      Touch2.Last = 2;
      Touch2.AsNew = Touch2.Last;
    })(Touch = exports2.Touch || (exports2.Touch = {}));
    var LinkedMap = class {
      constructor() {
        this[_a] = "LinkedMap";
        this._map = /* @__PURE__ */ new Map();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state = 0;
      }
      clear() {
        this._map.clear();
        this._head = void 0;
        this._tail = void 0;
        this._size = 0;
        this._state++;
      }
      isEmpty() {
        return !this._head && !this._tail;
      }
      get size() {
        return this._size;
      }
      get first() {
        return this._head?.value;
      }
      get last() {
        return this._tail?.value;
      }
      has(key) {
        return this._map.has(key);
      }
      get(key, touch = Touch.None) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        if (touch !== Touch.None) {
          this.touch(item, touch);
        }
        return item.value;
      }
      set(key, value, touch = Touch.None) {
        let item = this._map.get(key);
        if (item) {
          item.value = value;
          if (touch !== Touch.None) {
            this.touch(item, touch);
          }
        } else {
          item = { key, value, next: void 0, previous: void 0 };
          switch (touch) {
            case Touch.None:
              this.addItemLast(item);
              break;
            case Touch.First:
              this.addItemFirst(item);
              break;
            case Touch.Last:
              this.addItemLast(item);
              break;
            default:
              this.addItemLast(item);
              break;
          }
          this._map.set(key, item);
          this._size++;
        }
        return this;
      }
      delete(key) {
        return !!this.remove(key);
      }
      remove(key) {
        const item = this._map.get(key);
        if (!item) {
          return void 0;
        }
        this._map.delete(key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      shift() {
        if (!this._head && !this._tail) {
          return void 0;
        }
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        const item = this._head;
        this._map.delete(item.key);
        this.removeItem(item);
        this._size--;
        return item.value;
      }
      forEach(callbackfn, thisArg) {
        const state = this._state;
        let current = this._head;
        while (current) {
          if (thisArg) {
            callbackfn.bind(thisArg)(current.value, current.key, this);
          } else {
            callbackfn(current.value, current.key, this);
          }
          if (this._state !== state) {
            throw new Error(`LinkedMap got modified during iteration.`);
          }
          current = current.next;
        }
      }
      keys() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.key, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      values() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: current.value, done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      entries() {
        const state = this._state;
        let current = this._head;
        const iterator = {
          [Symbol.iterator]: () => {
            return iterator;
          },
          next: () => {
            if (this._state !== state) {
              throw new Error(`LinkedMap got modified during iteration.`);
            }
            if (current) {
              const result = { value: [current.key, current.value], done: false };
              current = current.next;
              return result;
            } else {
              return { value: void 0, done: true };
            }
          }
        };
        return iterator;
      }
      [(_a = Symbol.toStringTag, Symbol.iterator)]() {
        return this.entries();
      }
      trimOld(newSize) {
        if (newSize >= this.size) {
          return;
        }
        if (newSize === 0) {
          this.clear();
          return;
        }
        let current = this._head;
        let currentSize = this.size;
        while (current && currentSize > newSize) {
          this._map.delete(current.key);
          current = current.next;
          currentSize--;
        }
        this._head = current;
        this._size = currentSize;
        if (current) {
          current.previous = void 0;
        }
        this._state++;
      }
      addItemFirst(item) {
        if (!this._head && !this._tail) {
          this._tail = item;
        } else if (!this._head) {
          throw new Error("Invalid list");
        } else {
          item.next = this._head;
          this._head.previous = item;
        }
        this._head = item;
        this._state++;
      }
      addItemLast(item) {
        if (!this._head && !this._tail) {
          this._head = item;
        } else if (!this._tail) {
          throw new Error("Invalid list");
        } else {
          item.previous = this._tail;
          this._tail.next = item;
        }
        this._tail = item;
        this._state++;
      }
      removeItem(item) {
        if (item === this._head && item === this._tail) {
          this._head = void 0;
          this._tail = void 0;
        } else if (item === this._head) {
          if (!item.next) {
            throw new Error("Invalid list");
          }
          item.next.previous = void 0;
          this._head = item.next;
        } else if (item === this._tail) {
          if (!item.previous) {
            throw new Error("Invalid list");
          }
          item.previous.next = void 0;
          this._tail = item.previous;
        } else {
          const next = item.next;
          const previous = item.previous;
          if (!next || !previous) {
            throw new Error("Invalid list");
          }
          next.previous = previous;
          previous.next = next;
        }
        item.next = void 0;
        item.previous = void 0;
        this._state++;
      }
      touch(item, touch) {
        if (!this._head || !this._tail) {
          throw new Error("Invalid list");
        }
        if (touch !== Touch.First && touch !== Touch.Last) {
          return;
        }
        if (touch === Touch.First) {
          if (item === this._head) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._tail) {
            previous.next = void 0;
            this._tail = previous;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.previous = void 0;
          item.next = this._head;
          this._head.previous = item;
          this._head = item;
          this._state++;
        } else if (touch === Touch.Last) {
          if (item === this._tail) {
            return;
          }
          const next = item.next;
          const previous = item.previous;
          if (item === this._head) {
            next.previous = void 0;
            this._head = next;
          } else {
            next.previous = previous;
            previous.next = next;
          }
          item.next = void 0;
          item.previous = this._tail;
          this._tail.next = item;
          this._tail = item;
          this._state++;
        }
      }
      toJSON() {
        const data = [];
        this.forEach((value, key) => {
          data.push([key, value]);
        });
        return data;
      }
      fromJSON(data) {
        this.clear();
        for (const [key, value] of data) {
          this.set(key, value);
        }
      }
    };
    exports2.LinkedMap = LinkedMap;
    var LRUCache = class extends LinkedMap {
      constructor(limit, ratio = 1) {
        super();
        this._limit = limit;
        this._ratio = Math.min(Math.max(0, ratio), 1);
      }
      get limit() {
        return this._limit;
      }
      set limit(limit) {
        this._limit = limit;
        this.checkTrim();
      }
      get ratio() {
        return this._ratio;
      }
      set ratio(ratio) {
        this._ratio = Math.min(Math.max(0, ratio), 1);
        this.checkTrim();
      }
      get(key, touch = Touch.AsNew) {
        return super.get(key, touch);
      }
      peek(key) {
        return super.get(key, Touch.None);
      }
      set(key, value) {
        super.set(key, value, Touch.Last);
        this.checkTrim();
        return this;
      }
      checkTrim() {
        if (this.size > this._limit) {
          this.trimOld(Math.round(this._limit * this._ratio));
        }
      }
    };
    exports2.LRUCache = LRUCache;
  }
});

// node_modules/vscode-jsonrpc/lib/common/events.js
var require_events = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/events.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Emitter = exports2.Event = void 0;
    var ral_1 = require_ral();
    var Event;
    (function(Event2) {
      const _disposable = { dispose() {
      } };
      Event2.None = function() {
        return _disposable;
      };
    })(Event = exports2.Event || (exports2.Event = {}));
    var CallbackList = class {
      add(callback, context = null, bucket) {
        if (!this._callbacks) {
          this._callbacks = [];
          this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
          bucket.push({ dispose: () => this.remove(callback, context) });
        }
      }
      remove(callback, context = null) {
        if (!this._callbacks) {
          return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
          if (this._callbacks[i] === callback) {
            if (this._contexts[i] === context) {
              this._callbacks.splice(i, 1);
              this._contexts.splice(i, 1);
              return;
            } else {
              foundCallbackWithDifferentContext = true;
            }
          }
        }
        if (foundCallbackWithDifferentContext) {
          throw new Error("When adding a listener with a context, you should remove it with the same context");
        }
      }
      invoke(...args) {
        if (!this._callbacks) {
          return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
          try {
            ret.push(callbacks[i].apply(contexts[i], args));
          } catch (e) {
            (0, ral_1.default)().console.error(e);
          }
        }
        return ret;
      }
      isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
      }
      dispose() {
        this._callbacks = void 0;
        this._contexts = void 0;
      }
    };
    var Emitter = class {
      constructor(_options) {
        this._options = _options;
      }
      get event() {
        if (!this._event) {
          this._event = (listener, thisArgs, disposables) => {
            if (!this._callbacks) {
              this._callbacks = new CallbackList();
            }
            if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
              this._options.onFirstListenerAdd(this);
            }
            this._callbacks.add(listener, thisArgs);
            const result = {
              dispose: () => {
                if (!this._callbacks) {
                  return;
                }
                this._callbacks.remove(listener, thisArgs);
                result.dispose = Emitter._noop;
                if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                  this._options.onLastListenerRemove(this);
                }
              }
            };
            if (Array.isArray(disposables)) {
              disposables.push(result);
            }
            return result;
          };
        }
        return this._event;
      }
      fire(event) {
        if (this._callbacks) {
          this._callbacks.invoke.call(this._callbacks, event);
        }
      }
      dispose() {
        if (this._callbacks) {
          this._callbacks.dispose();
          this._callbacks = void 0;
        }
      }
    };
    exports2.Emitter = Emitter;
    Emitter._noop = function() {
    };
  }
});

// node_modules/vscode-jsonrpc/lib/common/cancellation.js
var require_cancellation = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/cancellation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CancellationTokenSource = exports2.CancellationToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var CancellationToken;
    (function(CancellationToken2) {
      CancellationToken2.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
      });
      CancellationToken2.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
      });
      function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken2.None || candidate === CancellationToken2.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
      }
      CancellationToken2.is = is;
    })(CancellationToken = exports2.CancellationToken || (exports2.CancellationToken = {}));
    var shortcutEvent = Object.freeze(function(callback, context) {
      const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
      return { dispose() {
        handle.dispose();
      } };
    });
    var MutableToken = class {
      constructor() {
        this._isCancelled = false;
      }
      cancel() {
        if (!this._isCancelled) {
          this._isCancelled = true;
          if (this._emitter) {
            this._emitter.fire(void 0);
            this.dispose();
          }
        }
      }
      get isCancellationRequested() {
        return this._isCancelled;
      }
      get onCancellationRequested() {
        if (this._isCancelled) {
          return shortcutEvent;
        }
        if (!this._emitter) {
          this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
      }
      dispose() {
        if (this._emitter) {
          this._emitter.dispose();
          this._emitter = void 0;
        }
      }
    };
    var CancellationTokenSource = class {
      get token() {
        if (!this._token) {
          this._token = new MutableToken();
        }
        return this._token;
      }
      cancel() {
        if (!this._token) {
          this._token = CancellationToken.Cancelled;
        } else {
          this._token.cancel();
        }
      }
      dispose() {
        if (!this._token) {
          this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
          this._token.dispose();
        }
      }
    };
    exports2.CancellationTokenSource = CancellationTokenSource;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageReader.js
var require_messageReader = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageReader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var events_1 = require_events();
    var MessageReader;
    (function(MessageReader2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.listen) && Is.func(candidate.dispose) && Is.func(candidate.onError) && Is.func(candidate.onClose) && Is.func(candidate.onPartialMessage);
      }
      MessageReader2.is = is;
    })(MessageReader = exports2.MessageReader || (exports2.MessageReader = {}));
    var AbstractMessageReader = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
        this.partialMessageEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error) {
        this.errorEmitter.fire(this.asError(error));
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      get onPartialMessage() {
        return this.partialMessageEmitter.event;
      }
      firePartialMessage(info) {
        this.partialMessageEmitter.fire(info);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Reader received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageReader = AbstractMessageReader;
    var ResolvedMessageReaderOptions;
    (function(ResolvedMessageReaderOptions2) {
      function fromOptions(options) {
        let charset;
        let result;
        let contentDecoder;
        const contentDecoders = /* @__PURE__ */ new Map();
        let contentTypeDecoder;
        const contentTypeDecoders = /* @__PURE__ */ new Map();
        if (options === void 0 || typeof options === "string") {
          charset = options ?? "utf-8";
        } else {
          charset = options.charset ?? "utf-8";
          if (options.contentDecoder !== void 0) {
            contentDecoder = options.contentDecoder;
            contentDecoders.set(contentDecoder.name, contentDecoder);
          }
          if (options.contentDecoders !== void 0) {
            for (const decoder of options.contentDecoders) {
              contentDecoders.set(decoder.name, decoder);
            }
          }
          if (options.contentTypeDecoder !== void 0) {
            contentTypeDecoder = options.contentTypeDecoder;
            contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
          }
          if (options.contentTypeDecoders !== void 0) {
            for (const decoder of options.contentTypeDecoders) {
              contentTypeDecoders.set(decoder.name, decoder);
            }
          }
        }
        if (contentTypeDecoder === void 0) {
          contentTypeDecoder = (0, ral_1.default)().applicationJson.decoder;
          contentTypeDecoders.set(contentTypeDecoder.name, contentTypeDecoder);
        }
        return { charset, contentDecoder, contentDecoders, contentTypeDecoder, contentTypeDecoders };
      }
      ResolvedMessageReaderOptions2.fromOptions = fromOptions;
    })(ResolvedMessageReaderOptions || (ResolvedMessageReaderOptions = {}));
    var ReadableStreamMessageReader = class extends AbstractMessageReader {
      constructor(readable, options) {
        super();
        this.readable = readable;
        this.options = ResolvedMessageReaderOptions.fromOptions(options);
        this.buffer = (0, ral_1.default)().messageBuffer.create(this.options.charset);
        this._partialMessageTimeout = 1e4;
        this.nextMessageLength = -1;
        this.messageToken = 0;
      }
      set partialMessageTimeout(timeout) {
        this._partialMessageTimeout = timeout;
      }
      get partialMessageTimeout() {
        return this._partialMessageTimeout;
      }
      listen(callback) {
        this.nextMessageLength = -1;
        this.messageToken = 0;
        this.partialMessageTimer = void 0;
        this.callback = callback;
        const result = this.readable.onData((data) => {
          this.onData(data);
        });
        this.readable.onError((error) => this.fireError(error));
        this.readable.onClose(() => this.fireClose());
        return result;
      }
      onData(data) {
        this.buffer.append(data);
        while (true) {
          if (this.nextMessageLength === -1) {
            const headers = this.buffer.tryReadHeaders();
            if (!headers) {
              return;
            }
            const contentLength = headers.get("Content-Length");
            if (!contentLength) {
              throw new Error("Header must provide a Content-Length property.");
            }
            const length = parseInt(contentLength);
            if (isNaN(length)) {
              throw new Error("Content-Length value must be a number.");
            }
            this.nextMessageLength = length;
          }
          const body = this.buffer.tryReadBody(this.nextMessageLength);
          if (body === void 0) {
            this.setPartialMessageTimer();
            return;
          }
          this.clearPartialMessageTimer();
          this.nextMessageLength = -1;
          let p;
          if (this.options.contentDecoder !== void 0) {
            p = this.options.contentDecoder.decode(body);
          } else {
            p = Promise.resolve(body);
          }
          p.then((value) => {
            this.options.contentTypeDecoder.decode(value, this.options).then((msg) => {
              this.callback(msg);
            }, (error) => {
              this.fireError(error);
            });
          }, (error) => {
            this.fireError(error);
          });
        }
      }
      clearPartialMessageTimer() {
        if (this.partialMessageTimer) {
          this.partialMessageTimer.dispose();
          this.partialMessageTimer = void 0;
        }
      }
      setPartialMessageTimer() {
        this.clearPartialMessageTimer();
        if (this._partialMessageTimeout <= 0) {
          return;
        }
        this.partialMessageTimer = (0, ral_1.default)().timer.setTimeout((token, timeout) => {
          this.partialMessageTimer = void 0;
          if (token === this.messageToken) {
            this.firePartialMessage({ messageToken: token, waitingTime: timeout });
            this.setPartialMessageTimer();
          }
        }, this._partialMessageTimeout, this.messageToken, this._partialMessageTimeout);
      }
    };
    exports2.ReadableStreamMessageReader = ReadableStreamMessageReader;
  }
});

// node_modules/vscode-jsonrpc/lib/common/semaphore.js
var require_semaphore = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/semaphore.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Semaphore = void 0;
    var ral_1 = require_ral();
    var Semaphore = class {
      constructor(capacity = 1) {
        if (capacity <= 0) {
          throw new Error("Capacity must be greater than 0");
        }
        this._capacity = capacity;
        this._active = 0;
        this._waiting = [];
      }
      lock(thunk) {
        return new Promise((resolve, reject) => {
          this._waiting.push({ thunk, resolve, reject });
          this.runNext();
        });
      }
      get active() {
        return this._active;
      }
      runNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        (0, ral_1.default)().timer.setImmediate(() => this.doRunNext());
      }
      doRunNext() {
        if (this._waiting.length === 0 || this._active === this._capacity) {
          return;
        }
        const next = this._waiting.shift();
        this._active++;
        if (this._active > this._capacity) {
          throw new Error(`To many thunks active`);
        }
        try {
          const result = next.thunk();
          if (result instanceof Promise) {
            result.then((value) => {
              this._active--;
              next.resolve(value);
              this.runNext();
            }, (err) => {
              this._active--;
              next.reject(err);
              this.runNext();
            });
          } else {
            this._active--;
            next.resolve(result);
            this.runNext();
          }
        } catch (err) {
          this._active--;
          next.reject(err);
          this.runNext();
        }
      }
    };
    exports2.Semaphore = Semaphore;
  }
});

// node_modules/vscode-jsonrpc/lib/common/messageWriter.js
var require_messageWriter = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/messageWriter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var semaphore_1 = require_semaphore();
    var events_1 = require_events();
    var ContentLength = "Content-Length: ";
    var CRLF = "\r\n";
    var MessageWriter;
    (function(MessageWriter2) {
      function is(value) {
        let candidate = value;
        return candidate && Is.func(candidate.dispose) && Is.func(candidate.onClose) && Is.func(candidate.onError) && Is.func(candidate.write);
      }
      MessageWriter2.is = is;
    })(MessageWriter = exports2.MessageWriter || (exports2.MessageWriter = {}));
    var AbstractMessageWriter = class {
      constructor() {
        this.errorEmitter = new events_1.Emitter();
        this.closeEmitter = new events_1.Emitter();
      }
      dispose() {
        this.errorEmitter.dispose();
        this.closeEmitter.dispose();
      }
      get onError() {
        return this.errorEmitter.event;
      }
      fireError(error, message, count) {
        this.errorEmitter.fire([this.asError(error), message, count]);
      }
      get onClose() {
        return this.closeEmitter.event;
      }
      fireClose() {
        this.closeEmitter.fire(void 0);
      }
      asError(error) {
        if (error instanceof Error) {
          return error;
        } else {
          return new Error(`Writer received error. Reason: ${Is.string(error.message) ? error.message : "unknown"}`);
        }
      }
    };
    exports2.AbstractMessageWriter = AbstractMessageWriter;
    var ResolvedMessageWriterOptions;
    (function(ResolvedMessageWriterOptions2) {
      function fromOptions(options) {
        if (options === void 0 || typeof options === "string") {
          return { charset: options ?? "utf-8", contentTypeEncoder: (0, ral_1.default)().applicationJson.encoder };
        } else {
          return { charset: options.charset ?? "utf-8", contentEncoder: options.contentEncoder, contentTypeEncoder: options.contentTypeEncoder ?? (0, ral_1.default)().applicationJson.encoder };
        }
      }
      ResolvedMessageWriterOptions2.fromOptions = fromOptions;
    })(ResolvedMessageWriterOptions || (ResolvedMessageWriterOptions = {}));
    var WriteableStreamMessageWriter = class extends AbstractMessageWriter {
      constructor(writable, options) {
        super();
        this.writable = writable;
        this.options = ResolvedMessageWriterOptions.fromOptions(options);
        this.errorCount = 0;
        this.writeSemaphore = new semaphore_1.Semaphore(1);
        this.writable.onError((error) => this.fireError(error));
        this.writable.onClose(() => this.fireClose());
      }
      async write(msg) {
        return this.writeSemaphore.lock(async () => {
          const payload = this.options.contentTypeEncoder.encode(msg, this.options).then((buffer) => {
            if (this.options.contentEncoder !== void 0) {
              return this.options.contentEncoder.encode(buffer);
            } else {
              return buffer;
            }
          });
          return payload.then((buffer) => {
            const headers = [];
            headers.push(ContentLength, buffer.byteLength.toString(), CRLF);
            headers.push(CRLF);
            return this.doWrite(msg, headers, buffer);
          }, (error) => {
            this.fireError(error);
            throw error;
          });
        });
      }
      async doWrite(msg, headers, data) {
        try {
          await this.writable.write(headers.join(""), "ascii");
          return this.writable.write(data);
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
        this.writable.end();
      }
    };
    exports2.WriteableStreamMessageWriter = WriteableStreamMessageWriter;
  }
});

// node_modules/vscode-jsonrpc/lib/common/connection.js
var require_connection = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.ConnectionOptions = exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.NullLogger = exports2.ProgressType = exports2.ProgressToken = void 0;
    var ral_1 = require_ral();
    var Is = require_is2();
    var messages_1 = require_messages();
    var linkedMap_1 = require_linkedMap();
    var events_1 = require_events();
    var cancellation_1 = require_cancellation();
    var CancelNotification;
    (function(CancelNotification2) {
      CancelNotification2.type = new messages_1.NotificationType("$/cancelRequest");
    })(CancelNotification || (CancelNotification = {}));
    var ProgressToken;
    (function(ProgressToken2) {
      function is(value) {
        return typeof value === "string" || typeof value === "number";
      }
      ProgressToken2.is = is;
    })(ProgressToken = exports2.ProgressToken || (exports2.ProgressToken = {}));
    var ProgressNotification;
    (function(ProgressNotification2) {
      ProgressNotification2.type = new messages_1.NotificationType("$/progress");
    })(ProgressNotification || (ProgressNotification = {}));
    var ProgressType = class {
      constructor() {
      }
    };
    exports2.ProgressType = ProgressType;
    var StarRequestHandler;
    (function(StarRequestHandler2) {
      function is(value) {
        return Is.func(value);
      }
      StarRequestHandler2.is = is;
    })(StarRequestHandler || (StarRequestHandler = {}));
    exports2.NullLogger = Object.freeze({
      error: () => {
      },
      warn: () => {
      },
      info: () => {
      },
      log: () => {
      }
    });
    var Trace;
    (function(Trace2) {
      Trace2[Trace2["Off"] = 0] = "Off";
      Trace2[Trace2["Messages"] = 1] = "Messages";
      Trace2[Trace2["Compact"] = 2] = "Compact";
      Trace2[Trace2["Verbose"] = 3] = "Verbose";
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    (function(Trace2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return Trace2.Off;
        }
        value = value.toLowerCase();
        switch (value) {
          case "off":
            return Trace2.Off;
          case "messages":
            return Trace2.Messages;
          case "compact":
            return Trace2.Compact;
          case "verbose":
            return Trace2.Verbose;
          default:
            return Trace2.Off;
        }
      }
      Trace2.fromString = fromString;
      function toString(value) {
        switch (value) {
          case Trace2.Off:
            return "off";
          case Trace2.Messages:
            return "messages";
          case Trace2.Compact:
            return "compact";
          case Trace2.Verbose:
            return "verbose";
          default:
            return "off";
        }
      }
      Trace2.toString = toString;
    })(Trace = exports2.Trace || (exports2.Trace = {}));
    var TraceFormat;
    (function(TraceFormat2) {
      TraceFormat2["Text"] = "text";
      TraceFormat2["JSON"] = "json";
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    (function(TraceFormat2) {
      function fromString(value) {
        if (!Is.string(value)) {
          return TraceFormat2.Text;
        }
        value = value.toLowerCase();
        if (value === "json") {
          return TraceFormat2.JSON;
        } else {
          return TraceFormat2.Text;
        }
      }
      TraceFormat2.fromString = fromString;
    })(TraceFormat = exports2.TraceFormat || (exports2.TraceFormat = {}));
    var SetTraceNotification;
    (function(SetTraceNotification2) {
      SetTraceNotification2.type = new messages_1.NotificationType("$/setTrace");
    })(SetTraceNotification = exports2.SetTraceNotification || (exports2.SetTraceNotification = {}));
    var LogTraceNotification;
    (function(LogTraceNotification2) {
      LogTraceNotification2.type = new messages_1.NotificationType("$/logTrace");
    })(LogTraceNotification = exports2.LogTraceNotification || (exports2.LogTraceNotification = {}));
    var ConnectionErrors;
    (function(ConnectionErrors2) {
      ConnectionErrors2[ConnectionErrors2["Closed"] = 1] = "Closed";
      ConnectionErrors2[ConnectionErrors2["Disposed"] = 2] = "Disposed";
      ConnectionErrors2[ConnectionErrors2["AlreadyListening"] = 3] = "AlreadyListening";
    })(ConnectionErrors = exports2.ConnectionErrors || (exports2.ConnectionErrors = {}));
    var ConnectionError = class extends Error {
      constructor(code, message) {
        super(message);
        this.code = code;
        Object.setPrototypeOf(this, ConnectionError.prototype);
      }
    };
    exports2.ConnectionError = ConnectionError;
    var ConnectionStrategy;
    (function(ConnectionStrategy2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.cancelUndispatched);
      }
      ConnectionStrategy2.is = is;
    })(ConnectionStrategy = exports2.ConnectionStrategy || (exports2.ConnectionStrategy = {}));
    var CancellationReceiverStrategy;
    (function(CancellationReceiverStrategy2) {
      CancellationReceiverStrategy2.Message = Object.freeze({
        createCancellationTokenSource(_) {
          return new cancellation_1.CancellationTokenSource();
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.createCancellationTokenSource);
      }
      CancellationReceiverStrategy2.is = is;
    })(CancellationReceiverStrategy = exports2.CancellationReceiverStrategy || (exports2.CancellationReceiverStrategy = {}));
    var CancellationSenderStrategy;
    (function(CancellationSenderStrategy2) {
      CancellationSenderStrategy2.Message = Object.freeze({
        sendCancellation(conn, id) {
          return conn.sendNotification(CancelNotification.type, { id });
        },
        cleanup(_) {
        }
      });
      function is(value) {
        const candidate = value;
        return candidate && Is.func(candidate.sendCancellation) && Is.func(candidate.cleanup);
      }
      CancellationSenderStrategy2.is = is;
    })(CancellationSenderStrategy = exports2.CancellationSenderStrategy || (exports2.CancellationSenderStrategy = {}));
    var CancellationStrategy;
    (function(CancellationStrategy2) {
      CancellationStrategy2.Message = Object.freeze({
        receiver: CancellationReceiverStrategy.Message,
        sender: CancellationSenderStrategy.Message
      });
      function is(value) {
        const candidate = value;
        return candidate && CancellationReceiverStrategy.is(candidate.receiver) && CancellationSenderStrategy.is(candidate.sender);
      }
      CancellationStrategy2.is = is;
    })(CancellationStrategy = exports2.CancellationStrategy || (exports2.CancellationStrategy = {}));
    var ConnectionOptions;
    (function(ConnectionOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (CancellationStrategy.is(candidate.cancellationStrategy) || ConnectionStrategy.is(candidate.connectionStrategy));
      }
      ConnectionOptions2.is = is;
    })(ConnectionOptions = exports2.ConnectionOptions || (exports2.ConnectionOptions = {}));
    var ConnectionState;
    (function(ConnectionState2) {
      ConnectionState2[ConnectionState2["New"] = 1] = "New";
      ConnectionState2[ConnectionState2["Listening"] = 2] = "Listening";
      ConnectionState2[ConnectionState2["Closed"] = 3] = "Closed";
      ConnectionState2[ConnectionState2["Disposed"] = 4] = "Disposed";
    })(ConnectionState || (ConnectionState = {}));
    function createMessageConnection(messageReader, messageWriter, _logger, options) {
      const logger = _logger !== void 0 ? _logger : exports2.NullLogger;
      let sequenceNumber = 0;
      let notificationSequenceNumber = 0;
      let unknownResponseSequenceNumber = 0;
      const version = "2.0";
      let starRequestHandler = void 0;
      const requestHandlers = /* @__PURE__ */ new Map();
      let starNotificationHandler = void 0;
      const notificationHandlers = /* @__PURE__ */ new Map();
      const progressHandlers = /* @__PURE__ */ new Map();
      let timer;
      let messageQueue = new linkedMap_1.LinkedMap();
      let responsePromises = /* @__PURE__ */ new Map();
      let knownCanceledRequests = /* @__PURE__ */ new Set();
      let requestTokens = /* @__PURE__ */ new Map();
      let trace = Trace.Off;
      let traceFormat = TraceFormat.Text;
      let tracer;
      let state = ConnectionState.New;
      const errorEmitter = new events_1.Emitter();
      const closeEmitter = new events_1.Emitter();
      const unhandledNotificationEmitter = new events_1.Emitter();
      const unhandledProgressEmitter = new events_1.Emitter();
      const disposeEmitter = new events_1.Emitter();
      const cancellationStrategy = options && options.cancellationStrategy ? options.cancellationStrategy : CancellationStrategy.Message;
      function createRequestQueueKey(id) {
        if (id === null) {
          throw new Error(`Can't send requests with id null since the response can't be correlated.`);
        }
        return "req-" + id.toString();
      }
      function createResponseQueueKey(id) {
        if (id === null) {
          return "res-unknown-" + (++unknownResponseSequenceNumber).toString();
        } else {
          return "res-" + id.toString();
        }
      }
      function createNotificationQueueKey() {
        return "not-" + (++notificationSequenceNumber).toString();
      }
      function addMessageToQueue(queue, message) {
        if (messages_1.Message.isRequest(message)) {
          queue.set(createRequestQueueKey(message.id), message);
        } else if (messages_1.Message.isResponse(message)) {
          queue.set(createResponseQueueKey(message.id), message);
        } else {
          queue.set(createNotificationQueueKey(), message);
        }
      }
      function cancelUndispatched(_message) {
        return void 0;
      }
      function isListening() {
        return state === ConnectionState.Listening;
      }
      function isClosed() {
        return state === ConnectionState.Closed;
      }
      function isDisposed() {
        return state === ConnectionState.Disposed;
      }
      function closeHandler() {
        if (state === ConnectionState.New || state === ConnectionState.Listening) {
          state = ConnectionState.Closed;
          closeEmitter.fire(void 0);
        }
      }
      function readErrorHandler(error) {
        errorEmitter.fire([error, void 0, void 0]);
      }
      function writeErrorHandler(data) {
        errorEmitter.fire(data);
      }
      messageReader.onClose(closeHandler);
      messageReader.onError(readErrorHandler);
      messageWriter.onClose(closeHandler);
      messageWriter.onError(writeErrorHandler);
      function triggerMessageQueue() {
        if (timer || messageQueue.size === 0) {
          return;
        }
        timer = (0, ral_1.default)().timer.setImmediate(() => {
          timer = void 0;
          processMessageQueue();
        });
      }
      function processMessageQueue() {
        if (messageQueue.size === 0) {
          return;
        }
        const message = messageQueue.shift();
        try {
          if (messages_1.Message.isRequest(message)) {
            handleRequest(message);
          } else if (messages_1.Message.isNotification(message)) {
            handleNotification(message);
          } else if (messages_1.Message.isResponse(message)) {
            handleResponse(message);
          } else {
            handleInvalidMessage(message);
          }
        } finally {
          triggerMessageQueue();
        }
      }
      const callback = (message) => {
        try {
          if (messages_1.Message.isNotification(message) && message.method === CancelNotification.type.method) {
            const cancelId = message.params.id;
            const key = createRequestQueueKey(cancelId);
            const toCancel = messageQueue.get(key);
            if (messages_1.Message.isRequest(toCancel)) {
              const strategy = options?.connectionStrategy;
              const response = strategy && strategy.cancelUndispatched ? strategy.cancelUndispatched(toCancel, cancelUndispatched) : cancelUndispatched(toCancel);
              if (response && (response.error !== void 0 || response.result !== void 0)) {
                messageQueue.delete(key);
                requestTokens.delete(cancelId);
                response.id = toCancel.id;
                traceSendingResponse(response, message.method, Date.now());
                messageWriter.write(response).catch(() => logger.error(`Sending response for canceled message failed.`));
                return;
              }
            }
            const cancellationToken = requestTokens.get(cancelId);
            if (cancellationToken !== void 0) {
              cancellationToken.cancel();
              traceReceivedNotification(message);
              return;
            } else {
              knownCanceledRequests.add(cancelId);
            }
          }
          addMessageToQueue(messageQueue, message);
        } finally {
          triggerMessageQueue();
        }
      };
      function handleRequest(requestMessage) {
        if (isDisposed()) {
          return;
        }
        function reply(resultOrError, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id
          };
          if (resultOrError instanceof messages_1.ResponseError) {
            message.error = resultOrError.toJson();
          } else {
            message.result = resultOrError === void 0 ? null : resultOrError;
          }
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replyError(error, method, startTime2) {
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            error: error.toJson()
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        function replySuccess(result, method, startTime2) {
          if (result === void 0) {
            result = null;
          }
          const message = {
            jsonrpc: version,
            id: requestMessage.id,
            result
          };
          traceSendingResponse(message, method, startTime2);
          messageWriter.write(message).catch(() => logger.error(`Sending response failed.`));
        }
        traceReceivedRequest(requestMessage);
        const element = requestHandlers.get(requestMessage.method);
        let type;
        let requestHandler;
        if (element) {
          type = element.type;
          requestHandler = element.handler;
        }
        const startTime = Date.now();
        if (requestHandler || starRequestHandler) {
          const tokenKey = requestMessage.id ?? String(Date.now());
          const cancellationSource = cancellationStrategy.receiver.createCancellationTokenSource(tokenKey);
          if (requestMessage.id !== null && knownCanceledRequests.has(requestMessage.id)) {
            cancellationSource.cancel();
          }
          if (requestMessage.id !== null) {
            requestTokens.set(tokenKey, cancellationSource);
          }
          try {
            let handlerResult;
            if (requestHandler) {
              if (requestMessage.params === void 0) {
                if (type !== void 0 && type.numberOfParams !== 0) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines ${type.numberOfParams} params but received none.`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(cancellationSource.token);
              } else if (Array.isArray(requestMessage.params)) {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byName) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by name but received parameters by position`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(...requestMessage.params, cancellationSource.token);
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InvalidParams, `Request ${requestMessage.method} defines parameters by position but received parameters by name`), requestMessage.method, startTime);
                  return;
                }
                handlerResult = requestHandler(requestMessage.params, cancellationSource.token);
              }
            } else if (starRequestHandler) {
              handlerResult = starRequestHandler(requestMessage.method, requestMessage.params, cancellationSource.token);
            }
            const promise = handlerResult;
            if (!handlerResult) {
              requestTokens.delete(tokenKey);
              replySuccess(handlerResult, requestMessage.method, startTime);
            } else if (promise.then) {
              promise.then((resultOrError) => {
                requestTokens.delete(tokenKey);
                reply(resultOrError, requestMessage.method, startTime);
              }, (error) => {
                requestTokens.delete(tokenKey);
                if (error instanceof messages_1.ResponseError) {
                  replyError(error, requestMessage.method, startTime);
                } else if (error && Is.string(error.message)) {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
                } else {
                  replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
                }
              });
            } else {
              requestTokens.delete(tokenKey);
              reply(handlerResult, requestMessage.method, startTime);
            }
          } catch (error) {
            requestTokens.delete(tokenKey);
            if (error instanceof messages_1.ResponseError) {
              reply(error, requestMessage.method, startTime);
            } else if (error && Is.string(error.message)) {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed with message: ${error.message}`), requestMessage.method, startTime);
            } else {
              replyError(new messages_1.ResponseError(messages_1.ErrorCodes.InternalError, `Request ${requestMessage.method} failed unexpectedly without providing any details.`), requestMessage.method, startTime);
            }
          }
        } else {
          replyError(new messages_1.ResponseError(messages_1.ErrorCodes.MethodNotFound, `Unhandled method ${requestMessage.method}`), requestMessage.method, startTime);
        }
      }
      function handleResponse(responseMessage) {
        if (isDisposed()) {
          return;
        }
        if (responseMessage.id === null) {
          if (responseMessage.error) {
            logger.error(`Received response message without id: Error is: 
${JSON.stringify(responseMessage.error, void 0, 4)}`);
          } else {
            logger.error(`Received response message without id. No further error information provided.`);
          }
        } else {
          const key = responseMessage.id;
          const responsePromise = responsePromises.get(key);
          traceReceivedResponse(responseMessage, responsePromise);
          if (responsePromise !== void 0) {
            responsePromises.delete(key);
            try {
              if (responseMessage.error) {
                const error = responseMessage.error;
                responsePromise.reject(new messages_1.ResponseError(error.code, error.message, error.data));
              } else if (responseMessage.result !== void 0) {
                responsePromise.resolve(responseMessage.result);
              } else {
                throw new Error("Should never happen.");
              }
            } catch (error) {
              if (error.message) {
                logger.error(`Response handler '${responsePromise.method}' failed with message: ${error.message}`);
              } else {
                logger.error(`Response handler '${responsePromise.method}' failed unexpectedly.`);
              }
            }
          }
        }
      }
      function handleNotification(message) {
        if (isDisposed()) {
          return;
        }
        let type = void 0;
        let notificationHandler;
        if (message.method === CancelNotification.type.method) {
          const cancelId = message.params.id;
          knownCanceledRequests.delete(cancelId);
          traceReceivedNotification(message);
          return;
        } else {
          const element = notificationHandlers.get(message.method);
          if (element) {
            notificationHandler = element.handler;
            type = element.type;
          }
        }
        if (notificationHandler || starNotificationHandler) {
          try {
            traceReceivedNotification(message);
            if (notificationHandler) {
              if (message.params === void 0) {
                if (type !== void 0) {
                  if (type.numberOfParams !== 0 && type.parameterStructures !== messages_1.ParameterStructures.byName) {
                    logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received none.`);
                  }
                }
                notificationHandler();
              } else if (Array.isArray(message.params)) {
                const params = message.params;
                if (message.method === ProgressNotification.type.method && params.length === 2 && ProgressToken.is(params[0])) {
                  notificationHandler({ token: params[0], value: params[1] });
                } else {
                  if (type !== void 0) {
                    if (type.parameterStructures === messages_1.ParameterStructures.byName) {
                      logger.error(`Notification ${message.method} defines parameters by name but received parameters by position`);
                    }
                    if (type.numberOfParams !== message.params.length) {
                      logger.error(`Notification ${message.method} defines ${type.numberOfParams} params but received ${params.length} arguments`);
                    }
                  }
                  notificationHandler(...params);
                }
              } else {
                if (type !== void 0 && type.parameterStructures === messages_1.ParameterStructures.byPosition) {
                  logger.error(`Notification ${message.method} defines parameters by position but received parameters by name`);
                }
                notificationHandler(message.params);
              }
            } else if (starNotificationHandler) {
              starNotificationHandler(message.method, message.params);
            }
          } catch (error) {
            if (error.message) {
              logger.error(`Notification handler '${message.method}' failed with message: ${error.message}`);
            } else {
              logger.error(`Notification handler '${message.method}' failed unexpectedly.`);
            }
          }
        } else {
          unhandledNotificationEmitter.fire(message);
        }
      }
      function handleInvalidMessage(message) {
        if (!message) {
          logger.error("Received empty message.");
          return;
        }
        logger.error(`Received message which is neither a response nor a notification message:
${JSON.stringify(message, null, 4)}`);
        const responseMessage = message;
        if (Is.string(responseMessage.id) || Is.number(responseMessage.id)) {
          const key = responseMessage.id;
          const responseHandler = responsePromises.get(key);
          if (responseHandler) {
            responseHandler.reject(new Error("The received response has neither a result nor an error property."));
          }
        }
      }
      function stringifyTrace(params) {
        if (params === void 0 || params === null) {
          return void 0;
        }
        switch (trace) {
          case Trace.Verbose:
            return JSON.stringify(params, null, 4);
          case Trace.Compact:
            return JSON.stringify(params);
          default:
            return void 0;
        }
      }
      function traceSendingRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Sending request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("send-request", message);
        }
      }
      function traceSendingNotification(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Sending notification '${message.method}'.`, data);
        } else {
          logLSPMessage("send-notification", message);
        }
      }
      function traceSendingResponse(message, method, startTime) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          tracer.log(`Sending response '${method} - (${message.id})'. Processing request took ${Date.now() - startTime}ms`, data);
        } else {
          logLSPMessage("send-response", message);
        }
      }
      function traceReceivedRequest(message) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if ((trace === Trace.Verbose || trace === Trace.Compact) && message.params) {
            data = `Params: ${stringifyTrace(message.params)}

`;
          }
          tracer.log(`Received request '${message.method} - (${message.id})'.`, data);
        } else {
          logLSPMessage("receive-request", message);
        }
      }
      function traceReceivedNotification(message) {
        if (trace === Trace.Off || !tracer || message.method === LogTraceNotification.type.method) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.params) {
              data = `Params: ${stringifyTrace(message.params)}

`;
            } else {
              data = "No parameters provided.\n\n";
            }
          }
          tracer.log(`Received notification '${message.method}'.`, data);
        } else {
          logLSPMessage("receive-notification", message);
        }
      }
      function traceReceivedResponse(message, responsePromise) {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        if (traceFormat === TraceFormat.Text) {
          let data = void 0;
          if (trace === Trace.Verbose || trace === Trace.Compact) {
            if (message.error && message.error.data) {
              data = `Error data: ${stringifyTrace(message.error.data)}

`;
            } else {
              if (message.result) {
                data = `Result: ${stringifyTrace(message.result)}

`;
              } else if (message.error === void 0) {
                data = "No result returned.\n\n";
              }
            }
          }
          if (responsePromise) {
            const error = message.error ? ` Request failed: ${message.error.message} (${message.error.code}).` : "";
            tracer.log(`Received response '${responsePromise.method} - (${message.id})' in ${Date.now() - responsePromise.timerStart}ms.${error}`, data);
          } else {
            tracer.log(`Received response ${message.id} without active response promise.`, data);
          }
        } else {
          logLSPMessage("receive-response", message);
        }
      }
      function logLSPMessage(type, message) {
        if (!tracer || trace === Trace.Off) {
          return;
        }
        const lspMessage = {
          isLSPMessage: true,
          type,
          message,
          timestamp: Date.now()
        };
        tracer.log(lspMessage);
      }
      function throwIfClosedOrDisposed() {
        if (isClosed()) {
          throw new ConnectionError(ConnectionErrors.Closed, "Connection is closed.");
        }
        if (isDisposed()) {
          throw new ConnectionError(ConnectionErrors.Disposed, "Connection is disposed.");
        }
      }
      function throwIfListening() {
        if (isListening()) {
          throw new ConnectionError(ConnectionErrors.AlreadyListening, "Connection is already listening");
        }
      }
      function throwIfNotListening() {
        if (!isListening()) {
          throw new Error("Call listen() first.");
        }
      }
      function undefinedToNull(param) {
        if (param === void 0) {
          return null;
        } else {
          return param;
        }
      }
      function nullToUndefined(param) {
        if (param === null) {
          return void 0;
        } else {
          return param;
        }
      }
      function isNamedParam(param) {
        return param !== void 0 && param !== null && !Array.isArray(param) && typeof param === "object";
      }
      function computeSingleParam(parameterStructures, param) {
        switch (parameterStructures) {
          case messages_1.ParameterStructures.auto:
            if (isNamedParam(param)) {
              return nullToUndefined(param);
            } else {
              return [undefinedToNull(param)];
            }
          case messages_1.ParameterStructures.byName:
            if (!isNamedParam(param)) {
              throw new Error(`Received parameters by name but param is not an object literal.`);
            }
            return nullToUndefined(param);
          case messages_1.ParameterStructures.byPosition:
            return [undefinedToNull(param)];
          default:
            throw new Error(`Unknown parameter structure ${parameterStructures.toString()}`);
        }
      }
      function computeMessageParams(type, params) {
        let result;
        const numberOfParams = type.numberOfParams;
        switch (numberOfParams) {
          case 0:
            result = void 0;
            break;
          case 1:
            result = computeSingleParam(type.parameterStructures, params[0]);
            break;
          default:
            result = [];
            for (let i = 0; i < params.length && i < numberOfParams; i++) {
              result.push(undefinedToNull(params[i]));
            }
            if (params.length < numberOfParams) {
              for (let i = params.length; i < numberOfParams; i++) {
                result.push(null);
              }
            }
            break;
        }
        return result;
      }
      const connection = {
        sendNotification: (type, ...args) => {
          throwIfClosedOrDisposed();
          let method;
          let messageParams;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' notification parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
          }
          const notificationMessage = {
            jsonrpc: version,
            method,
            params: messageParams
          };
          traceSendingNotification(notificationMessage);
          return messageWriter.write(notificationMessage).catch(() => logger.error(`Sending notification failed.`));
        },
        onNotification: (type, handler) => {
          throwIfClosedOrDisposed();
          let method;
          if (Is.func(type)) {
            starNotificationHandler = type;
          } else if (handler) {
            if (Is.string(type)) {
              method = type;
              notificationHandlers.set(type, { type: void 0, handler });
            } else {
              method = type.method;
              notificationHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method !== void 0) {
                notificationHandlers.delete(method);
              } else {
                starNotificationHandler = void 0;
              }
            }
          };
        },
        onProgress: (_type, token, handler) => {
          if (progressHandlers.has(token)) {
            throw new Error(`Progress handler for token ${token} already registered`);
          }
          progressHandlers.set(token, handler);
          return {
            dispose: () => {
              progressHandlers.delete(token);
            }
          };
        },
        sendProgress: (_type, token, value) => {
          return connection.sendNotification(ProgressNotification.type, { token, value });
        },
        onUnhandledProgress: unhandledProgressEmitter.event,
        sendRequest: (type, ...args) => {
          throwIfClosedOrDisposed();
          throwIfNotListening();
          let method;
          let messageParams;
          let token = void 0;
          if (Is.string(type)) {
            method = type;
            const first = args[0];
            const last = args[args.length - 1];
            let paramStart = 0;
            let parameterStructures = messages_1.ParameterStructures.auto;
            if (messages_1.ParameterStructures.is(first)) {
              paramStart = 1;
              parameterStructures = first;
            }
            let paramEnd = args.length;
            if (cancellation_1.CancellationToken.is(last)) {
              paramEnd = paramEnd - 1;
              token = last;
            }
            const numberOfParams = paramEnd - paramStart;
            switch (numberOfParams) {
              case 0:
                messageParams = void 0;
                break;
              case 1:
                messageParams = computeSingleParam(parameterStructures, args[paramStart]);
                break;
              default:
                if (parameterStructures === messages_1.ParameterStructures.byName) {
                  throw new Error(`Received ${numberOfParams} parameters for 'by Name' request parameter structure.`);
                }
                messageParams = args.slice(paramStart, paramEnd).map((value) => undefinedToNull(value));
                break;
            }
          } else {
            const params = args;
            method = type.method;
            messageParams = computeMessageParams(type, params);
            const numberOfParams = type.numberOfParams;
            token = cancellation_1.CancellationToken.is(params[numberOfParams]) ? params[numberOfParams] : void 0;
          }
          const id = sequenceNumber++;
          let disposable;
          if (token) {
            disposable = token.onCancellationRequested(() => {
              const p = cancellationStrategy.sender.sendCancellation(connection, id);
              if (p === void 0) {
                logger.log(`Received no promise from cancellation strategy when cancelling id ${id}`);
                return Promise.resolve();
              } else {
                return p.catch(() => {
                  logger.log(`Sending cancellation messages for id ${id} failed`);
                });
              }
            });
          }
          const result = new Promise((resolve, reject) => {
            const requestMessage = {
              jsonrpc: version,
              id,
              method,
              params: messageParams
            };
            const resolveWithCleanup = (r) => {
              resolve(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            const rejectWithCleanup = (r) => {
              reject(r);
              cancellationStrategy.sender.cleanup(id);
              disposable?.dispose();
            };
            let responsePromise = { method, timerStart: Date.now(), resolve: resolveWithCleanup, reject: rejectWithCleanup };
            traceSendingRequest(requestMessage);
            try {
              messageWriter.write(requestMessage).catch(() => logger.error(`Sending request failed.`));
            } catch (e) {
              responsePromise.reject(new messages_1.ResponseError(messages_1.ErrorCodes.MessageWriteError, e.message ? e.message : "Unknown reason"));
              responsePromise = null;
            }
            if (responsePromise) {
              responsePromises.set(id, responsePromise);
            }
          });
          return result;
        },
        onRequest: (type, handler) => {
          throwIfClosedOrDisposed();
          let method = null;
          if (StarRequestHandler.is(type)) {
            method = void 0;
            starRequestHandler = type;
          } else if (Is.string(type)) {
            method = null;
            if (handler !== void 0) {
              method = type;
              requestHandlers.set(type, { handler, type: void 0 });
            }
          } else {
            if (handler !== void 0) {
              method = type.method;
              requestHandlers.set(type.method, { type, handler });
            }
          }
          return {
            dispose: () => {
              if (method === null) {
                return;
              }
              if (method !== void 0) {
                requestHandlers.delete(method);
              } else {
                starRequestHandler = void 0;
              }
            }
          };
        },
        hasPendingResponse: () => {
          return responsePromises.size > 0;
        },
        trace: async (_value, _tracer, sendNotificationOrTraceOptions) => {
          let _sendNotification = false;
          let _traceFormat = TraceFormat.Text;
          if (sendNotificationOrTraceOptions !== void 0) {
            if (Is.boolean(sendNotificationOrTraceOptions)) {
              _sendNotification = sendNotificationOrTraceOptions;
            } else {
              _sendNotification = sendNotificationOrTraceOptions.sendNotification || false;
              _traceFormat = sendNotificationOrTraceOptions.traceFormat || TraceFormat.Text;
            }
          }
          trace = _value;
          traceFormat = _traceFormat;
          if (trace === Trace.Off) {
            tracer = void 0;
          } else {
            tracer = _tracer;
          }
          if (_sendNotification && !isClosed() && !isDisposed()) {
            await connection.sendNotification(SetTraceNotification.type, { value: Trace.toString(_value) });
          }
        },
        onError: errorEmitter.event,
        onClose: closeEmitter.event,
        onUnhandledNotification: unhandledNotificationEmitter.event,
        onDispose: disposeEmitter.event,
        end: () => {
          messageWriter.end();
        },
        dispose: () => {
          if (isDisposed()) {
            return;
          }
          state = ConnectionState.Disposed;
          disposeEmitter.fire(void 0);
          const error = new messages_1.ResponseError(messages_1.ErrorCodes.PendingResponseRejected, "Pending response rejected since connection got disposed");
          for (const promise of responsePromises.values()) {
            promise.reject(error);
          }
          responsePromises = /* @__PURE__ */ new Map();
          requestTokens = /* @__PURE__ */ new Map();
          knownCanceledRequests = /* @__PURE__ */ new Set();
          messageQueue = new linkedMap_1.LinkedMap();
          if (Is.func(messageWriter.dispose)) {
            messageWriter.dispose();
          }
          if (Is.func(messageReader.dispose)) {
            messageReader.dispose();
          }
        },
        listen: () => {
          throwIfClosedOrDisposed();
          throwIfListening();
          state = ConnectionState.Listening;
          messageReader.listen(callback);
        },
        inspect: () => {
          (0, ral_1.default)().console.log("inspect");
        }
      };
      connection.onNotification(LogTraceNotification.type, (params) => {
        if (trace === Trace.Off || !tracer) {
          return;
        }
        const verbose = trace === Trace.Verbose || trace === Trace.Compact;
        tracer.log(params.message, verbose ? params.verbose : void 0);
      });
      connection.onNotification(ProgressNotification.type, (params) => {
        const handler = progressHandlers.get(params.token);
        if (handler) {
          handler(params.value);
        } else {
          unhandledProgressEmitter.fire(params);
        }
      });
      return connection;
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/lib/common/api.js
var require_api = __commonJS({
  "node_modules/vscode-jsonrpc/lib/common/api.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetTraceNotification = exports2.TraceFormat = exports2.Trace = exports2.ProgressType = exports2.ProgressToken = exports2.createMessageConnection = exports2.NullLogger = exports2.ConnectionOptions = exports2.ConnectionStrategy = exports2.WriteableStreamMessageWriter = exports2.AbstractMessageWriter = exports2.MessageWriter = exports2.ReadableStreamMessageReader = exports2.AbstractMessageReader = exports2.MessageReader = exports2.CancellationToken = exports2.CancellationTokenSource = exports2.Emitter = exports2.Event = exports2.Disposable = exports2.LRUCache = exports2.Touch = exports2.LinkedMap = exports2.ParameterStructures = exports2.NotificationType9 = exports2.NotificationType8 = exports2.NotificationType7 = exports2.NotificationType6 = exports2.NotificationType5 = exports2.NotificationType4 = exports2.NotificationType3 = exports2.NotificationType2 = exports2.NotificationType1 = exports2.NotificationType0 = exports2.NotificationType = exports2.ErrorCodes = exports2.ResponseError = exports2.RequestType9 = exports2.RequestType8 = exports2.RequestType7 = exports2.RequestType6 = exports2.RequestType5 = exports2.RequestType4 = exports2.RequestType3 = exports2.RequestType2 = exports2.RequestType1 = exports2.RequestType0 = exports2.RequestType = exports2.Message = exports2.RAL = void 0;
    exports2.CancellationStrategy = exports2.CancellationSenderStrategy = exports2.CancellationReceiverStrategy = exports2.ConnectionError = exports2.ConnectionErrors = exports2.LogTraceNotification = void 0;
    var messages_1 = require_messages();
    Object.defineProperty(exports2, "Message", { enumerable: true, get: function() {
      return messages_1.Message;
    } });
    Object.defineProperty(exports2, "RequestType", { enumerable: true, get: function() {
      return messages_1.RequestType;
    } });
    Object.defineProperty(exports2, "RequestType0", { enumerable: true, get: function() {
      return messages_1.RequestType0;
    } });
    Object.defineProperty(exports2, "RequestType1", { enumerable: true, get: function() {
      return messages_1.RequestType1;
    } });
    Object.defineProperty(exports2, "RequestType2", { enumerable: true, get: function() {
      return messages_1.RequestType2;
    } });
    Object.defineProperty(exports2, "RequestType3", { enumerable: true, get: function() {
      return messages_1.RequestType3;
    } });
    Object.defineProperty(exports2, "RequestType4", { enumerable: true, get: function() {
      return messages_1.RequestType4;
    } });
    Object.defineProperty(exports2, "RequestType5", { enumerable: true, get: function() {
      return messages_1.RequestType5;
    } });
    Object.defineProperty(exports2, "RequestType6", { enumerable: true, get: function() {
      return messages_1.RequestType6;
    } });
    Object.defineProperty(exports2, "RequestType7", { enumerable: true, get: function() {
      return messages_1.RequestType7;
    } });
    Object.defineProperty(exports2, "RequestType8", { enumerable: true, get: function() {
      return messages_1.RequestType8;
    } });
    Object.defineProperty(exports2, "RequestType9", { enumerable: true, get: function() {
      return messages_1.RequestType9;
    } });
    Object.defineProperty(exports2, "ResponseError", { enumerable: true, get: function() {
      return messages_1.ResponseError;
    } });
    Object.defineProperty(exports2, "ErrorCodes", { enumerable: true, get: function() {
      return messages_1.ErrorCodes;
    } });
    Object.defineProperty(exports2, "NotificationType", { enumerable: true, get: function() {
      return messages_1.NotificationType;
    } });
    Object.defineProperty(exports2, "NotificationType0", { enumerable: true, get: function() {
      return messages_1.NotificationType0;
    } });
    Object.defineProperty(exports2, "NotificationType1", { enumerable: true, get: function() {
      return messages_1.NotificationType1;
    } });
    Object.defineProperty(exports2, "NotificationType2", { enumerable: true, get: function() {
      return messages_1.NotificationType2;
    } });
    Object.defineProperty(exports2, "NotificationType3", { enumerable: true, get: function() {
      return messages_1.NotificationType3;
    } });
    Object.defineProperty(exports2, "NotificationType4", { enumerable: true, get: function() {
      return messages_1.NotificationType4;
    } });
    Object.defineProperty(exports2, "NotificationType5", { enumerable: true, get: function() {
      return messages_1.NotificationType5;
    } });
    Object.defineProperty(exports2, "NotificationType6", { enumerable: true, get: function() {
      return messages_1.NotificationType6;
    } });
    Object.defineProperty(exports2, "NotificationType7", { enumerable: true, get: function() {
      return messages_1.NotificationType7;
    } });
    Object.defineProperty(exports2, "NotificationType8", { enumerable: true, get: function() {
      return messages_1.NotificationType8;
    } });
    Object.defineProperty(exports2, "NotificationType9", { enumerable: true, get: function() {
      return messages_1.NotificationType9;
    } });
    Object.defineProperty(exports2, "ParameterStructures", { enumerable: true, get: function() {
      return messages_1.ParameterStructures;
    } });
    var linkedMap_1 = require_linkedMap();
    Object.defineProperty(exports2, "LinkedMap", { enumerable: true, get: function() {
      return linkedMap_1.LinkedMap;
    } });
    Object.defineProperty(exports2, "LRUCache", { enumerable: true, get: function() {
      return linkedMap_1.LRUCache;
    } });
    Object.defineProperty(exports2, "Touch", { enumerable: true, get: function() {
      return linkedMap_1.Touch;
    } });
    var disposable_1 = require_disposable();
    Object.defineProperty(exports2, "Disposable", { enumerable: true, get: function() {
      return disposable_1.Disposable;
    } });
    var events_1 = require_events();
    Object.defineProperty(exports2, "Event", { enumerable: true, get: function() {
      return events_1.Event;
    } });
    Object.defineProperty(exports2, "Emitter", { enumerable: true, get: function() {
      return events_1.Emitter;
    } });
    var cancellation_1 = require_cancellation();
    Object.defineProperty(exports2, "CancellationTokenSource", { enumerable: true, get: function() {
      return cancellation_1.CancellationTokenSource;
    } });
    Object.defineProperty(exports2, "CancellationToken", { enumerable: true, get: function() {
      return cancellation_1.CancellationToken;
    } });
    var messageReader_1 = require_messageReader();
    Object.defineProperty(exports2, "MessageReader", { enumerable: true, get: function() {
      return messageReader_1.MessageReader;
    } });
    Object.defineProperty(exports2, "AbstractMessageReader", { enumerable: true, get: function() {
      return messageReader_1.AbstractMessageReader;
    } });
    Object.defineProperty(exports2, "ReadableStreamMessageReader", { enumerable: true, get: function() {
      return messageReader_1.ReadableStreamMessageReader;
    } });
    var messageWriter_1 = require_messageWriter();
    Object.defineProperty(exports2, "MessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.MessageWriter;
    } });
    Object.defineProperty(exports2, "AbstractMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.AbstractMessageWriter;
    } });
    Object.defineProperty(exports2, "WriteableStreamMessageWriter", { enumerable: true, get: function() {
      return messageWriter_1.WriteableStreamMessageWriter;
    } });
    var connection_1 = require_connection();
    Object.defineProperty(exports2, "ConnectionStrategy", { enumerable: true, get: function() {
      return connection_1.ConnectionStrategy;
    } });
    Object.defineProperty(exports2, "ConnectionOptions", { enumerable: true, get: function() {
      return connection_1.ConnectionOptions;
    } });
    Object.defineProperty(exports2, "NullLogger", { enumerable: true, get: function() {
      return connection_1.NullLogger;
    } });
    Object.defineProperty(exports2, "createMessageConnection", { enumerable: true, get: function() {
      return connection_1.createMessageConnection;
    } });
    Object.defineProperty(exports2, "ProgressToken", { enumerable: true, get: function() {
      return connection_1.ProgressToken;
    } });
    Object.defineProperty(exports2, "ProgressType", { enumerable: true, get: function() {
      return connection_1.ProgressType;
    } });
    Object.defineProperty(exports2, "Trace", { enumerable: true, get: function() {
      return connection_1.Trace;
    } });
    Object.defineProperty(exports2, "TraceFormat", { enumerable: true, get: function() {
      return connection_1.TraceFormat;
    } });
    Object.defineProperty(exports2, "SetTraceNotification", { enumerable: true, get: function() {
      return connection_1.SetTraceNotification;
    } });
    Object.defineProperty(exports2, "LogTraceNotification", { enumerable: true, get: function() {
      return connection_1.LogTraceNotification;
    } });
    Object.defineProperty(exports2, "ConnectionErrors", { enumerable: true, get: function() {
      return connection_1.ConnectionErrors;
    } });
    Object.defineProperty(exports2, "ConnectionError", { enumerable: true, get: function() {
      return connection_1.ConnectionError;
    } });
    Object.defineProperty(exports2, "CancellationReceiverStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationReceiverStrategy;
    } });
    Object.defineProperty(exports2, "CancellationSenderStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationSenderStrategy;
    } });
    Object.defineProperty(exports2, "CancellationStrategy", { enumerable: true, get: function() {
      return connection_1.CancellationStrategy;
    } });
    var ral_1 = require_ral();
    exports2.RAL = ral_1.default;
  }
});

// node_modules/vscode-jsonrpc/lib/node/main.js
var require_main = __commonJS({
  "node_modules/vscode-jsonrpc/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createMessageConnection = exports2.createServerSocketTransport = exports2.createClientSocketTransport = exports2.createServerPipeTransport = exports2.createClientPipeTransport = exports2.generateRandomPipeName = exports2.StreamMessageWriter = exports2.StreamMessageReader = exports2.SocketMessageWriter = exports2.SocketMessageReader = exports2.IPCMessageWriter = exports2.IPCMessageReader = void 0;
    var ril_1 = require_ril();
    ril_1.default.install();
    var api_1 = require_api();
    var path = require("path");
    var os = require("os");
    var crypto_1 = require("crypto");
    var net_1 = require("net");
    __exportStar(require_api(), exports2);
    var IPCMessageReader = class extends api_1.AbstractMessageReader {
      constructor(process2) {
        super();
        this.process = process2;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose());
      }
      listen(callback) {
        this.process.on("message", callback);
        return api_1.Disposable.create(() => this.process.off("message", callback));
      }
    };
    exports2.IPCMessageReader = IPCMessageReader;
    var IPCMessageWriter = class extends api_1.AbstractMessageWriter {
      constructor(process2) {
        super();
        this.process = process2;
        this.errorCount = 0;
        let eventEmitter = this.process;
        eventEmitter.on("error", (error) => this.fireError(error));
        eventEmitter.on("close", () => this.fireClose);
      }
      write(msg) {
        try {
          if (typeof this.process.send === "function") {
            this.process.send(msg, void 0, void 0, (error) => {
              if (error) {
                this.errorCount++;
                this.handleError(error, msg);
              } else {
                this.errorCount = 0;
              }
            });
          }
          return Promise.resolve();
        } catch (error) {
          this.handleError(error, msg);
          return Promise.reject(error);
        }
      }
      handleError(error, msg) {
        this.errorCount++;
        this.fireError(error, msg, this.errorCount);
      }
      end() {
      }
    };
    exports2.IPCMessageWriter = IPCMessageWriter;
    var SocketMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(socket, encoding = "utf-8") {
        super((0, ril_1.default)().stream.asReadableStream(socket), encoding);
      }
    };
    exports2.SocketMessageReader = SocketMessageReader;
    var SocketMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(socket, options) {
        super((0, ril_1.default)().stream.asWritableStream(socket), options);
        this.socket = socket;
      }
      dispose() {
        super.dispose();
        this.socket.destroy();
      }
    };
    exports2.SocketMessageWriter = SocketMessageWriter;
    var StreamMessageReader = class extends api_1.ReadableStreamMessageReader {
      constructor(readble, encoding) {
        super((0, ril_1.default)().stream.asReadableStream(readble), encoding);
      }
    };
    exports2.StreamMessageReader = StreamMessageReader;
    var StreamMessageWriter = class extends api_1.WriteableStreamMessageWriter {
      constructor(writable, options) {
        super((0, ril_1.default)().stream.asWritableStream(writable), options);
      }
    };
    exports2.StreamMessageWriter = StreamMessageWriter;
    var XDG_RUNTIME_DIR = process.env["XDG_RUNTIME_DIR"];
    var safeIpcPathLengths = /* @__PURE__ */ new Map([
      ["linux", 107],
      ["darwin", 103]
    ]);
    function generateRandomPipeName() {
      const randomSuffix = (0, crypto_1.randomBytes)(21).toString("hex");
      if (process.platform === "win32") {
        return `\\\\.\\pipe\\vscode-jsonrpc-${randomSuffix}-sock`;
      }
      let result;
      if (XDG_RUNTIME_DIR) {
        result = path.join(XDG_RUNTIME_DIR, `vscode-ipc-${randomSuffix}.sock`);
      } else {
        result = path.join(os.tmpdir(), `vscode-${randomSuffix}.sock`);
      }
      const limit = safeIpcPathLengths.get(process.platform);
      if (limit !== void 0 && result.length >= limit) {
        (0, ril_1.default)().console.warn(`WARNING: IPC handle "${result}" is longer than ${limit} characters.`);
      }
      return result;
    }
    exports2.generateRandomPipeName = generateRandomPipeName;
    function createClientPipeTransport(pipeName, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        let server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(pipeName, () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientPipeTransport = createClientPipeTransport;
    function createServerPipeTransport(pipeName, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(pipeName);
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerPipeTransport = createServerPipeTransport;
    function createClientSocketTransport(port, encoding = "utf-8") {
      let connectResolve;
      const connected = new Promise((resolve, _reject) => {
        connectResolve = resolve;
      });
      return new Promise((resolve, reject) => {
        const server = (0, net_1.createServer)((socket) => {
          server.close();
          connectResolve([
            new SocketMessageReader(socket, encoding),
            new SocketMessageWriter(socket, encoding)
          ]);
        });
        server.on("error", reject);
        server.listen(port, "127.0.0.1", () => {
          server.removeListener("error", reject);
          resolve({
            onConnected: () => {
              return connected;
            }
          });
        });
      });
    }
    exports2.createClientSocketTransport = createClientSocketTransport;
    function createServerSocketTransport(port, encoding = "utf-8") {
      const socket = (0, net_1.createConnection)(port, "127.0.0.1");
      return [
        new SocketMessageReader(socket, encoding),
        new SocketMessageWriter(socket, encoding)
      ];
    }
    exports2.createServerSocketTransport = createServerSocketTransport;
    function isReadableStream(value) {
      const candidate = value;
      return candidate.read !== void 0 && candidate.addListener !== void 0;
    }
    function isWritableStream(value) {
      const candidate = value;
      return candidate.write !== void 0 && candidate.addListener !== void 0;
    }
    function createMessageConnection(input, output, logger, options) {
      if (!logger) {
        logger = api_1.NullLogger;
      }
      const reader = isReadableStream(input) ? new StreamMessageReader(input) : input;
      const writer = isWritableStream(output) ? new StreamMessageWriter(output) : output;
      if (api_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, api_1.createMessageConnection)(reader, writer, logger, options);
    }
    exports2.createMessageConnection = createMessageConnection;
  }
});

// node_modules/vscode-jsonrpc/node.js
var require_node = __commonJS({
  "node_modules/vscode-jsonrpc/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main();
  }
});

// node_modules/vscode-languageserver-types/lib/umd/main.js
var require_main2 = __commonJS({
  "node_modules/vscode-languageserver-types/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = exports3.EOL = exports3.WorkspaceFolder = exports3.InlayHint = exports3.InlayHintLabelPart = exports3.InlayHintKind = exports3.InlineValueContext = exports3.InlineValueEvaluatableExpression = exports3.InlineValueVariableLookup = exports3.InlineValueText = exports3.SemanticTokens = exports3.SemanticTokenModifiers = exports3.SemanticTokenTypes = exports3.SelectionRange = exports3.DocumentLink = exports3.FormattingOptions = exports3.CodeLens = exports3.CodeAction = exports3.CodeActionContext = exports3.CodeActionTriggerKind = exports3.CodeActionKind = exports3.DocumentSymbol = exports3.WorkspaceSymbol = exports3.SymbolInformation = exports3.SymbolTag = exports3.SymbolKind = exports3.DocumentHighlight = exports3.DocumentHighlightKind = exports3.SignatureInformation = exports3.ParameterInformation = exports3.Hover = exports3.MarkedString = exports3.CompletionList = exports3.CompletionItem = exports3.CompletionItemLabelDetails = exports3.InsertTextMode = exports3.InsertReplaceEdit = exports3.CompletionItemTag = exports3.InsertTextFormat = exports3.CompletionItemKind = exports3.MarkupContent = exports3.MarkupKind = exports3.TextDocumentItem = exports3.OptionalVersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier = exports3.TextDocumentIdentifier = exports3.WorkspaceChange = exports3.WorkspaceEdit = exports3.DeleteFile = exports3.RenameFile = exports3.CreateFile = exports3.TextDocumentEdit = exports3.AnnotatedTextEdit = exports3.ChangeAnnotationIdentifier = exports3.ChangeAnnotation = exports3.TextEdit = exports3.Command = exports3.Diagnostic = exports3.CodeDescription = exports3.DiagnosticTag = exports3.DiagnosticSeverity = exports3.DiagnosticRelatedInformation = exports3.FoldingRange = exports3.FoldingRangeKind = exports3.ColorPresentation = exports3.ColorInformation = exports3.Color = exports3.LocationLink = exports3.Location = exports3.Range = exports3.Position = exports3.uinteger = exports3.integer = exports3.URI = exports3.DocumentUri = void 0;
      var DocumentUri;
      (function(DocumentUri2) {
        function is(value) {
          return typeof value === "string";
        }
        DocumentUri2.is = is;
      })(DocumentUri = exports3.DocumentUri || (exports3.DocumentUri = {}));
      var URI;
      (function(URI2) {
        function is(value) {
          return typeof value === "string";
        }
        URI2.is = is;
      })(URI = exports3.URI || (exports3.URI = {}));
      var integer;
      (function(integer2) {
        integer2.MIN_VALUE = -2147483648;
        integer2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && integer2.MIN_VALUE <= value && value <= integer2.MAX_VALUE;
        }
        integer2.is = is;
      })(integer = exports3.integer || (exports3.integer = {}));
      var uinteger;
      (function(uinteger2) {
        uinteger2.MIN_VALUE = 0;
        uinteger2.MAX_VALUE = 2147483647;
        function is(value) {
          return typeof value === "number" && uinteger2.MIN_VALUE <= value && value <= uinteger2.MAX_VALUE;
        }
        uinteger2.is = is;
      })(uinteger = exports3.uinteger || (exports3.uinteger = {}));
      var Position;
      (function(Position2) {
        function create(line, character) {
          if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
          }
          if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
          }
          return { line, character };
        }
        Position2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position2.is = is;
      })(Position = exports3.Position || (exports3.Position = {}));
      var Range;
      (function(Range2) {
        function create(one, two, three, four) {
          if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
          } else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
          } else {
            throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
          }
        }
        Range2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range2.is = is;
      })(Range = exports3.Range || (exports3.Range = {}));
      var Location;
      (function(Location2) {
        function create(uri, range) {
          return { uri, range };
        }
        Location2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location2.is = is;
      })(Location = exports3.Location || (exports3.Location = {}));
      var LocationLink;
      (function(LocationLink2) {
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
          return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
        }
        LocationLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink2.is = is;
      })(LocationLink = exports3.LocationLink || (exports3.LocationLink = {}));
      var Color;
      (function(Color2) {
        function create(red, green, blue, alpha) {
          return {
            red,
            green,
            blue,
            alpha
          };
        }
        Color2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color2.is = is;
      })(Color = exports3.Color || (exports3.Color = {}));
      var ColorInformation;
      (function(ColorInformation2) {
        function create(range, color) {
          return {
            range,
            color
          };
        }
        ColorInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation2.is = is;
      })(ColorInformation = exports3.ColorInformation || (exports3.ColorInformation = {}));
      var ColorPresentation;
      (function(ColorPresentation2) {
        function create(label, textEdit, additionalTextEdits) {
          return {
            label,
            textEdit,
            additionalTextEdits
          };
        }
        ColorPresentation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation2.is = is;
      })(ColorPresentation = exports3.ColorPresentation || (exports3.ColorPresentation = {}));
      var FoldingRangeKind;
      (function(FoldingRangeKind2) {
        FoldingRangeKind2.Comment = "comment";
        FoldingRangeKind2.Imports = "imports";
        FoldingRangeKind2.Region = "region";
      })(FoldingRangeKind = exports3.FoldingRangeKind || (exports3.FoldingRangeKind = {}));
      var FoldingRange;
      (function(FoldingRange2) {
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
          var result = {
            startLine,
            endLine
          };
          if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
          }
          if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
          }
          if (Is.defined(kind)) {
            result.kind = kind;
          }
          if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
          }
          return result;
        }
        FoldingRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange2.is = is;
      })(FoldingRange = exports3.FoldingRange || (exports3.FoldingRange = {}));
      var DiagnosticRelatedInformation;
      (function(DiagnosticRelatedInformation2) {
        function create(location, message) {
          return {
            location,
            message
          };
        }
        DiagnosticRelatedInformation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation2.is = is;
      })(DiagnosticRelatedInformation = exports3.DiagnosticRelatedInformation || (exports3.DiagnosticRelatedInformation = {}));
      var DiagnosticSeverity;
      (function(DiagnosticSeverity2) {
        DiagnosticSeverity2.Error = 1;
        DiagnosticSeverity2.Warning = 2;
        DiagnosticSeverity2.Information = 3;
        DiagnosticSeverity2.Hint = 4;
      })(DiagnosticSeverity = exports3.DiagnosticSeverity || (exports3.DiagnosticSeverity = {}));
      var DiagnosticTag;
      (function(DiagnosticTag2) {
        DiagnosticTag2.Unnecessary = 1;
        DiagnosticTag2.Deprecated = 2;
      })(DiagnosticTag = exports3.DiagnosticTag || (exports3.DiagnosticTag = {}));
      var CodeDescription;
      (function(CodeDescription2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription2.is = is;
      })(CodeDescription = exports3.CodeDescription || (exports3.CodeDescription = {}));
      var Diagnostic;
      (function(Diagnostic2) {
        function create(range, message, severity, code, source, relatedInformation) {
          var result = { range, message };
          if (Is.defined(severity)) {
            result.severity = severity;
          }
          if (Is.defined(code)) {
            result.code = code;
          }
          if (Is.defined(source)) {
            result.source = source;
          }
          if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
          }
          return result;
        }
        Diagnostic2.create = create;
        function is(value) {
          var _a;
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic2.is = is;
      })(Diagnostic = exports3.Diagnostic || (exports3.Diagnostic = {}));
      var Command;
      (function(Command2) {
        function create(title, command) {
          var args = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
          }
          var result = { title, command };
          if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
          }
          return result;
        }
        Command2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command2.is = is;
      })(Command = exports3.Command || (exports3.Command = {}));
      var TextEdit;
      (function(TextEdit2) {
        function replace(range, newText) {
          return { range, newText };
        }
        TextEdit2.replace = replace;
        function insert(position, newText) {
          return { range: { start: position, end: position }, newText };
        }
        TextEdit2.insert = insert;
        function del(range) {
          return { range, newText: "" };
        }
        TextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
        }
        TextEdit2.is = is;
      })(TextEdit = exports3.TextEdit || (exports3.TextEdit = {}));
      var ChangeAnnotation;
      (function(ChangeAnnotation2) {
        function create(label, needsConfirmation, description) {
          var result = { label };
          if (needsConfirmation !== void 0) {
            result.needsConfirmation = needsConfirmation;
          }
          if (description !== void 0) {
            result.description = description;
          }
          return result;
        }
        ChangeAnnotation2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        ChangeAnnotation2.is = is;
      })(ChangeAnnotation = exports3.ChangeAnnotation || (exports3.ChangeAnnotation = {}));
      var ChangeAnnotationIdentifier;
      (function(ChangeAnnotationIdentifier2) {
        function is(value) {
          var candidate = value;
          return Is.string(candidate);
        }
        ChangeAnnotationIdentifier2.is = is;
      })(ChangeAnnotationIdentifier = exports3.ChangeAnnotationIdentifier || (exports3.ChangeAnnotationIdentifier = {}));
      var AnnotatedTextEdit;
      (function(AnnotatedTextEdit2) {
        function replace(range, newText, annotation) {
          return { range, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.replace = replace;
        function insert(position, newText, annotation) {
          return { range: { start: position, end: position }, newText, annotationId: annotation };
        }
        AnnotatedTextEdit2.insert = insert;
        function del(range, annotation) {
          return { range, newText: "", annotationId: annotation };
        }
        AnnotatedTextEdit2.del = del;
        function is(value) {
          var candidate = value;
          return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit2.is = is;
      })(AnnotatedTextEdit = exports3.AnnotatedTextEdit || (exports3.AnnotatedTextEdit = {}));
      var TextDocumentEdit;
      (function(TextDocumentEdit2) {
        function create(textDocument, edits) {
          return { textDocument, edits };
        }
        TextDocumentEdit2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
        }
        TextDocumentEdit2.is = is;
      })(TextDocumentEdit = exports3.TextDocumentEdit || (exports3.TextDocumentEdit = {}));
      var CreateFile;
      (function(CreateFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "create",
            uri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        CreateFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile2.is = is;
      })(CreateFile = exports3.CreateFile || (exports3.CreateFile = {}));
      var RenameFile;
      (function(RenameFile2) {
        function create(oldUri, newUri, options, annotation) {
          var result = {
            kind: "rename",
            oldUri,
            newUri
          };
          if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        RenameFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile2.is = is;
      })(RenameFile = exports3.RenameFile || (exports3.RenameFile = {}));
      var DeleteFile;
      (function(DeleteFile2) {
        function create(uri, options, annotation) {
          var result = {
            kind: "delete",
            uri
          };
          if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
          }
          if (annotation !== void 0) {
            result.annotationId = annotation;
          }
          return result;
        }
        DeleteFile2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile2.is = is;
      })(DeleteFile = exports3.DeleteFile || (exports3.DeleteFile = {}));
      var WorkspaceEdit;
      (function(WorkspaceEdit2) {
        function is(value) {
          var candidate = value;
          return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
            if (Is.string(change.kind)) {
              return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
              return TextDocumentEdit.is(change);
            }
          }));
        }
        WorkspaceEdit2.is = is;
      })(WorkspaceEdit = exports3.WorkspaceEdit || (exports3.WorkspaceEdit = {}));
      var TextEditChangeImpl = function() {
        function TextEditChangeImpl2(edits, changeAnnotations) {
          this.edits = edits;
          this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.insert(position, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.replace = function(range, newText, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.replace(range, newText);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.delete = function(range, annotation) {
          var edit;
          var id;
          if (annotation === void 0) {
            edit = TextEdit.del(range);
          } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
          } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
          }
          this.edits.push(edit);
          if (id !== void 0) {
            return id;
          }
        };
        TextEditChangeImpl2.prototype.add = function(edit) {
          this.edits.push(edit);
        };
        TextEditChangeImpl2.prototype.all = function() {
          return this.edits;
        };
        TextEditChangeImpl2.prototype.clear = function() {
          this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value) {
          if (value === void 0) {
            throw new Error("Text edit change is not configured to manage change annotations.");
          }
        };
        return TextEditChangeImpl2;
      }();
      var ChangeAnnotations = function() {
        function ChangeAnnotations2(annotations) {
          this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
          this._counter = 0;
          this._size = 0;
        }
        ChangeAnnotations2.prototype.all = function() {
          return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations2.prototype, "size", {
          get: function() {
            return this._size;
          },
          enumerable: false,
          configurable: true
        });
        ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
          var id;
          if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
          } else {
            id = this.nextId();
            annotation = idOrAnnotation;
          }
          if (this._annotations[id] !== void 0) {
            throw new Error("Id ".concat(id, " is already in use."));
          }
          if (annotation === void 0) {
            throw new Error("No annotation provided for id ".concat(id));
          }
          this._annotations[id] = annotation;
          this._size++;
          return id;
        };
        ChangeAnnotations2.prototype.nextId = function() {
          this._counter++;
          return this._counter.toString();
        };
        return ChangeAnnotations2;
      }();
      var WorkspaceChange = function() {
        function WorkspaceChange2(workspaceEdit) {
          var _this = this;
          this._textEditChanges = /* @__PURE__ */ Object.create(null);
          if (workspaceEdit !== void 0) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
              this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
              workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              workspaceEdit.documentChanges.forEach(function(change) {
                if (TextDocumentEdit.is(change)) {
                  var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                  _this._textEditChanges[change.textDocument.uri] = textEditChange;
                }
              });
            } else if (workspaceEdit.changes) {
              Object.keys(workspaceEdit.changes).forEach(function(key) {
                var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                _this._textEditChanges[key] = textEditChange;
              });
            }
          } else {
            this._workspaceEdit = {};
          }
        }
        Object.defineProperty(WorkspaceChange2.prototype, "edit", {
          get: function() {
            this.initDocumentChanges();
            if (this._changeAnnotations !== void 0) {
              if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = void 0;
              } else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
              }
            }
            return this._workspaceEdit;
          },
          enumerable: false,
          configurable: true
        });
        WorkspaceChange2.prototype.getTextEditChange = function(key) {
          if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === void 0) {
              throw new Error("Workspace edit is not configured for document changes.");
            }
            var textDocument = { uri: key.uri, version: key.version };
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
              var edits = [];
              var textDocumentEdit = {
                textDocument,
                edits
              };
              this._workspaceEdit.documentChanges.push(textDocumentEdit);
              result = new TextEditChangeImpl(edits, this._changeAnnotations);
              this._textEditChanges[textDocument.uri] = result;
            }
            return result;
          } else {
            this.initChanges();
            if (this._workspaceEdit.changes === void 0) {
              throw new Error("Workspace edit is not configured for normal text edit changes.");
            }
            var result = this._textEditChanges[key];
            if (!result) {
              var edits = [];
              this._workspaceEdit.changes[key] = edits;
              result = new TextEditChangeImpl(edits);
              this._textEditChanges[key] = result;
            }
            return result;
          }
        };
        WorkspaceChange2.prototype.initDocumentChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
          }
        };
        WorkspaceChange2.prototype.initChanges = function() {
          if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
            this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
          }
        };
        WorkspaceChange2.prototype.createFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = CreateFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = RenameFile.create(oldUri, newUri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        WorkspaceChange2.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
          this.initDocumentChanges();
          if (this._workspaceEdit.documentChanges === void 0) {
            throw new Error("Workspace edit is not configured for document changes.");
          }
          var annotation;
          if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
          } else {
            options = optionsOrAnnotation;
          }
          var operation;
          var id;
          if (annotation === void 0) {
            operation = DeleteFile.create(uri, options);
          } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
          }
          this._workspaceEdit.documentChanges.push(operation);
          if (id !== void 0) {
            return id;
          }
        };
        return WorkspaceChange2;
      }();
      exports3.WorkspaceChange = WorkspaceChange;
      var TextDocumentIdentifier;
      (function(TextDocumentIdentifier2) {
        function create(uri) {
          return { uri };
        }
        TextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier2.is = is;
      })(TextDocumentIdentifier = exports3.TextDocumentIdentifier || (exports3.TextDocumentIdentifier = {}));
      var VersionedTextDocumentIdentifier;
      (function(VersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        VersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier2.is = is;
      })(VersionedTextDocumentIdentifier = exports3.VersionedTextDocumentIdentifier || (exports3.VersionedTextDocumentIdentifier = {}));
      var OptionalVersionedTextDocumentIdentifier;
      (function(OptionalVersionedTextDocumentIdentifier2) {
        function create(uri, version) {
          return { uri, version };
        }
        OptionalVersionedTextDocumentIdentifier2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier2.is = is;
      })(OptionalVersionedTextDocumentIdentifier = exports3.OptionalVersionedTextDocumentIdentifier || (exports3.OptionalVersionedTextDocumentIdentifier = {}));
      var TextDocumentItem;
      (function(TextDocumentItem2) {
        function create(uri, languageId, version, text) {
          return { uri, languageId, version, text };
        }
        TextDocumentItem2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem2.is = is;
      })(TextDocumentItem = exports3.TextDocumentItem || (exports3.TextDocumentItem = {}));
      var MarkupKind;
      (function(MarkupKind2) {
        MarkupKind2.PlainText = "plaintext";
        MarkupKind2.Markdown = "markdown";
        function is(value) {
          var candidate = value;
          return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
        }
        MarkupKind2.is = is;
      })(MarkupKind = exports3.MarkupKind || (exports3.MarkupKind = {}));
      var MarkupContent;
      (function(MarkupContent2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent2.is = is;
      })(MarkupContent = exports3.MarkupContent || (exports3.MarkupContent = {}));
      var CompletionItemKind;
      (function(CompletionItemKind2) {
        CompletionItemKind2.Text = 1;
        CompletionItemKind2.Method = 2;
        CompletionItemKind2.Function = 3;
        CompletionItemKind2.Constructor = 4;
        CompletionItemKind2.Field = 5;
        CompletionItemKind2.Variable = 6;
        CompletionItemKind2.Class = 7;
        CompletionItemKind2.Interface = 8;
        CompletionItemKind2.Module = 9;
        CompletionItemKind2.Property = 10;
        CompletionItemKind2.Unit = 11;
        CompletionItemKind2.Value = 12;
        CompletionItemKind2.Enum = 13;
        CompletionItemKind2.Keyword = 14;
        CompletionItemKind2.Snippet = 15;
        CompletionItemKind2.Color = 16;
        CompletionItemKind2.File = 17;
        CompletionItemKind2.Reference = 18;
        CompletionItemKind2.Folder = 19;
        CompletionItemKind2.EnumMember = 20;
        CompletionItemKind2.Constant = 21;
        CompletionItemKind2.Struct = 22;
        CompletionItemKind2.Event = 23;
        CompletionItemKind2.Operator = 24;
        CompletionItemKind2.TypeParameter = 25;
      })(CompletionItemKind = exports3.CompletionItemKind || (exports3.CompletionItemKind = {}));
      var InsertTextFormat;
      (function(InsertTextFormat2) {
        InsertTextFormat2.PlainText = 1;
        InsertTextFormat2.Snippet = 2;
      })(InsertTextFormat = exports3.InsertTextFormat || (exports3.InsertTextFormat = {}));
      var CompletionItemTag;
      (function(CompletionItemTag2) {
        CompletionItemTag2.Deprecated = 1;
      })(CompletionItemTag = exports3.CompletionItemTag || (exports3.CompletionItemTag = {}));
      var InsertReplaceEdit;
      (function(InsertReplaceEdit2) {
        function create(newText, insert, replace) {
          return { newText, insert, replace };
        }
        InsertReplaceEdit2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit2.is = is;
      })(InsertReplaceEdit = exports3.InsertReplaceEdit || (exports3.InsertReplaceEdit = {}));
      var InsertTextMode;
      (function(InsertTextMode2) {
        InsertTextMode2.asIs = 1;
        InsertTextMode2.adjustIndentation = 2;
      })(InsertTextMode = exports3.InsertTextMode || (exports3.InsertTextMode = {}));
      var CompletionItemLabelDetails;
      (function(CompletionItemLabelDetails2) {
        function is(value) {
          var candidate = value;
          return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
        }
        CompletionItemLabelDetails2.is = is;
      })(CompletionItemLabelDetails = exports3.CompletionItemLabelDetails || (exports3.CompletionItemLabelDetails = {}));
      var CompletionItem;
      (function(CompletionItem2) {
        function create(label) {
          return { label };
        }
        CompletionItem2.create = create;
      })(CompletionItem = exports3.CompletionItem || (exports3.CompletionItem = {}));
      var CompletionList;
      (function(CompletionList2) {
        function create(items, isIncomplete) {
          return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList2.create = create;
      })(CompletionList = exports3.CompletionList || (exports3.CompletionList = {}));
      var MarkedString;
      (function(MarkedString2) {
        function fromPlainText(plainText) {
          return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        MarkedString2.fromPlainText = fromPlainText;
        function is(value) {
          var candidate = value;
          return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
        }
        MarkedString2.is = is;
      })(MarkedString = exports3.MarkedString || (exports3.MarkedString = {}));
      var Hover;
      (function(Hover2) {
        function is(value) {
          var candidate = value;
          return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || Range.is(value.range));
        }
        Hover2.is = is;
      })(Hover = exports3.Hover || (exports3.Hover = {}));
      var ParameterInformation;
      (function(ParameterInformation2) {
        function create(label, documentation) {
          return documentation ? { label, documentation } : { label };
        }
        ParameterInformation2.create = create;
      })(ParameterInformation = exports3.ParameterInformation || (exports3.ParameterInformation = {}));
      var SignatureInformation;
      (function(SignatureInformation2) {
        function create(label, documentation) {
          var parameters = [];
          for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
          }
          var result = { label };
          if (Is.defined(documentation)) {
            result.documentation = documentation;
          }
          if (Is.defined(parameters)) {
            result.parameters = parameters;
          } else {
            result.parameters = [];
          }
          return result;
        }
        SignatureInformation2.create = create;
      })(SignatureInformation = exports3.SignatureInformation || (exports3.SignatureInformation = {}));
      var DocumentHighlightKind;
      (function(DocumentHighlightKind2) {
        DocumentHighlightKind2.Text = 1;
        DocumentHighlightKind2.Read = 2;
        DocumentHighlightKind2.Write = 3;
      })(DocumentHighlightKind = exports3.DocumentHighlightKind || (exports3.DocumentHighlightKind = {}));
      var DocumentHighlight;
      (function(DocumentHighlight2) {
        function create(range, kind) {
          var result = { range };
          if (Is.number(kind)) {
            result.kind = kind;
          }
          return result;
        }
        DocumentHighlight2.create = create;
      })(DocumentHighlight = exports3.DocumentHighlight || (exports3.DocumentHighlight = {}));
      var SymbolKind;
      (function(SymbolKind2) {
        SymbolKind2.File = 1;
        SymbolKind2.Module = 2;
        SymbolKind2.Namespace = 3;
        SymbolKind2.Package = 4;
        SymbolKind2.Class = 5;
        SymbolKind2.Method = 6;
        SymbolKind2.Property = 7;
        SymbolKind2.Field = 8;
        SymbolKind2.Constructor = 9;
        SymbolKind2.Enum = 10;
        SymbolKind2.Interface = 11;
        SymbolKind2.Function = 12;
        SymbolKind2.Variable = 13;
        SymbolKind2.Constant = 14;
        SymbolKind2.String = 15;
        SymbolKind2.Number = 16;
        SymbolKind2.Boolean = 17;
        SymbolKind2.Array = 18;
        SymbolKind2.Object = 19;
        SymbolKind2.Key = 20;
        SymbolKind2.Null = 21;
        SymbolKind2.EnumMember = 22;
        SymbolKind2.Struct = 23;
        SymbolKind2.Event = 24;
        SymbolKind2.Operator = 25;
        SymbolKind2.TypeParameter = 26;
      })(SymbolKind = exports3.SymbolKind || (exports3.SymbolKind = {}));
      var SymbolTag;
      (function(SymbolTag2) {
        SymbolTag2.Deprecated = 1;
      })(SymbolTag = exports3.SymbolTag || (exports3.SymbolTag = {}));
      var SymbolInformation;
      (function(SymbolInformation2) {
        function create(name, kind, range, uri, containerName) {
          var result = {
            name,
            kind,
            location: { uri, range }
          };
          if (containerName) {
            result.containerName = containerName;
          }
          return result;
        }
        SymbolInformation2.create = create;
      })(SymbolInformation = exports3.SymbolInformation || (exports3.SymbolInformation = {}));
      var WorkspaceSymbol;
      (function(WorkspaceSymbol2) {
        function create(name, kind, uri, range) {
          return range !== void 0 ? { name, kind, location: { uri, range } } : { name, kind, location: { uri } };
        }
        WorkspaceSymbol2.create = create;
      })(WorkspaceSymbol = exports3.WorkspaceSymbol || (exports3.WorkspaceSymbol = {}));
      var DocumentSymbol;
      (function(DocumentSymbol2) {
        function create(name, detail, kind, range, selectionRange, children) {
          var result = {
            name,
            detail,
            kind,
            range,
            selectionRange
          };
          if (children !== void 0) {
            result.children = children;
          }
          return result;
        }
        DocumentSymbol2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
        }
        DocumentSymbol2.is = is;
      })(DocumentSymbol = exports3.DocumentSymbol || (exports3.DocumentSymbol = {}));
      var CodeActionKind;
      (function(CodeActionKind2) {
        CodeActionKind2.Empty = "";
        CodeActionKind2.QuickFix = "quickfix";
        CodeActionKind2.Refactor = "refactor";
        CodeActionKind2.RefactorExtract = "refactor.extract";
        CodeActionKind2.RefactorInline = "refactor.inline";
        CodeActionKind2.RefactorRewrite = "refactor.rewrite";
        CodeActionKind2.Source = "source";
        CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
        CodeActionKind2.SourceFixAll = "source.fixAll";
      })(CodeActionKind = exports3.CodeActionKind || (exports3.CodeActionKind = {}));
      var CodeActionTriggerKind;
      (function(CodeActionTriggerKind2) {
        CodeActionTriggerKind2.Invoked = 1;
        CodeActionTriggerKind2.Automatic = 2;
      })(CodeActionTriggerKind = exports3.CodeActionTriggerKind || (exports3.CodeActionTriggerKind = {}));
      var CodeActionContext;
      (function(CodeActionContext2) {
        function create(diagnostics, only, triggerKind) {
          var result = { diagnostics };
          if (only !== void 0 && only !== null) {
            result.only = only;
          }
          if (triggerKind !== void 0 && triggerKind !== null) {
            result.triggerKind = triggerKind;
          }
          return result;
        }
        CodeActionContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext2.is = is;
      })(CodeActionContext = exports3.CodeActionContext || (exports3.CodeActionContext = {}));
      var CodeAction;
      (function(CodeAction2) {
        function create(title, kindOrCommandOrEdit, kind) {
          var result = { title };
          var checkKind = true;
          if (typeof kindOrCommandOrEdit === "string") {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
          } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
          } else {
            result.edit = kindOrCommandOrEdit;
          }
          if (checkKind && kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        CodeAction2.create = create;
        function is(value) {
          var candidate = value;
          return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction2.is = is;
      })(CodeAction = exports3.CodeAction || (exports3.CodeAction = {}));
      var CodeLens;
      (function(CodeLens2) {
        function create(range, data) {
          var result = { range };
          if (Is.defined(data)) {
            result.data = data;
          }
          return result;
        }
        CodeLens2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens2.is = is;
      })(CodeLens = exports3.CodeLens || (exports3.CodeLens = {}));
      var FormattingOptions;
      (function(FormattingOptions2) {
        function create(tabSize, insertSpaces) {
          return { tabSize, insertSpaces };
        }
        FormattingOptions2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions2.is = is;
      })(FormattingOptions = exports3.FormattingOptions || (exports3.FormattingOptions = {}));
      var DocumentLink;
      (function(DocumentLink2) {
        function create(range, target, data) {
          return { range, target, data };
        }
        DocumentLink2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink2.is = is;
      })(DocumentLink = exports3.DocumentLink || (exports3.DocumentLink = {}));
      var SelectionRange;
      (function(SelectionRange2) {
        function create(range, parent) {
          return { range, parent };
        }
        SelectionRange2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
        }
        SelectionRange2.is = is;
      })(SelectionRange = exports3.SelectionRange || (exports3.SelectionRange = {}));
      var SemanticTokenTypes;
      (function(SemanticTokenTypes2) {
        SemanticTokenTypes2["namespace"] = "namespace";
        SemanticTokenTypes2["type"] = "type";
        SemanticTokenTypes2["class"] = "class";
        SemanticTokenTypes2["enum"] = "enum";
        SemanticTokenTypes2["interface"] = "interface";
        SemanticTokenTypes2["struct"] = "struct";
        SemanticTokenTypes2["typeParameter"] = "typeParameter";
        SemanticTokenTypes2["parameter"] = "parameter";
        SemanticTokenTypes2["variable"] = "variable";
        SemanticTokenTypes2["property"] = "property";
        SemanticTokenTypes2["enumMember"] = "enumMember";
        SemanticTokenTypes2["event"] = "event";
        SemanticTokenTypes2["function"] = "function";
        SemanticTokenTypes2["method"] = "method";
        SemanticTokenTypes2["macro"] = "macro";
        SemanticTokenTypes2["keyword"] = "keyword";
        SemanticTokenTypes2["modifier"] = "modifier";
        SemanticTokenTypes2["comment"] = "comment";
        SemanticTokenTypes2["string"] = "string";
        SemanticTokenTypes2["number"] = "number";
        SemanticTokenTypes2["regexp"] = "regexp";
        SemanticTokenTypes2["operator"] = "operator";
        SemanticTokenTypes2["decorator"] = "decorator";
      })(SemanticTokenTypes = exports3.SemanticTokenTypes || (exports3.SemanticTokenTypes = {}));
      var SemanticTokenModifiers;
      (function(SemanticTokenModifiers2) {
        SemanticTokenModifiers2["declaration"] = "declaration";
        SemanticTokenModifiers2["definition"] = "definition";
        SemanticTokenModifiers2["readonly"] = "readonly";
        SemanticTokenModifiers2["static"] = "static";
        SemanticTokenModifiers2["deprecated"] = "deprecated";
        SemanticTokenModifiers2["abstract"] = "abstract";
        SemanticTokenModifiers2["async"] = "async";
        SemanticTokenModifiers2["modification"] = "modification";
        SemanticTokenModifiers2["documentation"] = "documentation";
        SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
      })(SemanticTokenModifiers = exports3.SemanticTokenModifiers || (exports3.SemanticTokenModifiers = {}));
      var SemanticTokens;
      (function(SemanticTokens2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
        }
        SemanticTokens2.is = is;
      })(SemanticTokens = exports3.SemanticTokens || (exports3.SemanticTokens = {}));
      var InlineValueText;
      (function(InlineValueText2) {
        function create(range, text) {
          return { range, text };
        }
        InlineValueText2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText2.is = is;
      })(InlineValueText = exports3.InlineValueText || (exports3.InlineValueText = {}));
      var InlineValueVariableLookup;
      (function(InlineValueVariableLookup2) {
        function create(range, variableName, caseSensitiveLookup) {
          return { range, variableName, caseSensitiveLookup };
        }
        InlineValueVariableLookup2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
        }
        InlineValueVariableLookup2.is = is;
      })(InlineValueVariableLookup = exports3.InlineValueVariableLookup || (exports3.InlineValueVariableLookup = {}));
      var InlineValueEvaluatableExpression;
      (function(InlineValueEvaluatableExpression2) {
        function create(range, expression) {
          return { range, expression };
        }
        InlineValueEvaluatableExpression2.create = create;
        function is(value) {
          var candidate = value;
          return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
        }
        InlineValueEvaluatableExpression2.is = is;
      })(InlineValueEvaluatableExpression = exports3.InlineValueEvaluatableExpression || (exports3.InlineValueEvaluatableExpression = {}));
      var InlineValueContext;
      (function(InlineValueContext2) {
        function create(frameId, stoppedLocation) {
          return { frameId, stoppedLocation };
        }
        InlineValueContext2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext2.is = is;
      })(InlineValueContext = exports3.InlineValueContext || (exports3.InlineValueContext = {}));
      var InlayHintKind;
      (function(InlayHintKind2) {
        InlayHintKind2.Type = 1;
        InlayHintKind2.Parameter = 2;
        function is(value) {
          return value === 1 || value === 2;
        }
        InlayHintKind2.is = is;
      })(InlayHintKind = exports3.InlayHintKind || (exports3.InlayHintKind = {}));
      var InlayHintLabelPart;
      (function(InlayHintLabelPart2) {
        function create(value) {
          return { value };
        }
        InlayHintLabelPart2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
        }
        InlayHintLabelPart2.is = is;
      })(InlayHintLabelPart = exports3.InlayHintLabelPart || (exports3.InlayHintLabelPart = {}));
      var InlayHint;
      (function(InlayHint2) {
        function create(position, label, kind) {
          var result = { position, label };
          if (kind !== void 0) {
            result.kind = kind;
          }
          return result;
        }
        InlayHint2.create = create;
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
        }
        InlayHint2.is = is;
      })(InlayHint = exports3.InlayHint || (exports3.InlayHint = {}));
      var WorkspaceFolder;
      (function(WorkspaceFolder2) {
        function is(value) {
          var candidate = value;
          return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder2.is = is;
      })(WorkspaceFolder = exports3.WorkspaceFolder || (exports3.WorkspaceFolder = {}));
      exports3.EOL = ["\n", "\r\n", "\r"];
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function is(value) {
          var candidate = value;
          return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument2.is = is;
        function applyEdits(document, edits) {
          var text = document.getText();
          var sortedEdits = mergeSort(edits, function(a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          var lastModifiedOffset = text.length;
          for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
              text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
              throw new Error("Overlapping edit");
            }
            lastModifiedOffset = startOffset;
          }
          return text;
        }
        TextDocument2.applyEdits = applyEdits;
        function mergeSort(data, compare) {
          if (data.length <= 1) {
            return data;
          }
          var p = data.length / 2 | 0;
          var left = data.slice(0, p);
          var right = data.slice(p);
          mergeSort(left, compare);
          mergeSort(right, compare);
          var leftIdx = 0;
          var rightIdx = 0;
          var i = 0;
          while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
              data[i++] = left[leftIdx++];
            } else {
              data[i++] = right[rightIdx++];
            }
          }
          while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
          }
          while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
          }
          return data;
        }
      })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
      var FullTextDocument = function() {
        function FullTextDocument2(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        Object.defineProperty(FullTextDocument2.prototype, "uri", {
          get: function() {
            return this._uri;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "languageId", {
          get: function() {
            return this._languageId;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(FullTextDocument2.prototype, "version", {
          get: function() {
            return this._version;
          },
          enumerable: false,
          configurable: true
        });
        FullTextDocument2.prototype.getText = function(range) {
          if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        };
        FullTextDocument2.prototype.update = function(event, version) {
          this._content = event.text;
          this._version = version;
          this._lineOffsets = void 0;
        };
        FullTextDocument2.prototype.getLineOffsets = function() {
          if (this._lineOffsets === void 0) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
              if (isLineStart) {
                lineOffsets.push(i);
                isLineStart = false;
              }
              var ch = text.charAt(i);
              isLineStart = ch === "\r" || ch === "\n";
              if (ch === "\r" && i + 1 < text.length && text.charAt(i + 1) === "\n") {
                i++;
              }
            }
            if (isLineStart && text.length > 0) {
              lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
          }
          return this._lineOffsets;
        };
        FullTextDocument2.prototype.positionAt = function(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          var lineOffsets = this.getLineOffsets();
          var low = 0, high = lineOffsets.length;
          if (high === 0) {
            return Position.create(0, offset);
          }
          while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          var line = low - 1;
          return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument2.prototype.offsetAt = function(position) {
          var lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          var lineOffset = lineOffsets[position.line];
          var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
          get: function() {
            return this.getLineOffsets().length;
          },
          enumerable: false,
          configurable: true
        });
        return FullTextDocument2;
      }();
      var Is;
      (function(Is2) {
        var toString = Object.prototype.toString;
        function defined(value) {
          return typeof value !== "undefined";
        }
        Is2.defined = defined;
        function undefined2(value) {
          return typeof value === "undefined";
        }
        Is2.undefined = undefined2;
        function boolean(value) {
          return value === true || value === false;
        }
        Is2.boolean = boolean;
        function string(value) {
          return toString.call(value) === "[object String]";
        }
        Is2.string = string;
        function number(value) {
          return toString.call(value) === "[object Number]";
        }
        Is2.number = number;
        function numberRange(value, min, max) {
          return toString.call(value) === "[object Number]" && min <= value && value <= max;
        }
        Is2.numberRange = numberRange;
        function integer2(value) {
          return toString.call(value) === "[object Number]" && -2147483648 <= value && value <= 2147483647;
        }
        Is2.integer = integer2;
        function uinteger2(value) {
          return toString.call(value) === "[object Number]" && 0 <= value && value <= 2147483647;
        }
        Is2.uinteger = uinteger2;
        function func(value) {
          return toString.call(value) === "[object Function]";
        }
        Is2.func = func;
        function objectLiteral(value) {
          return value !== null && typeof value === "object";
        }
        Is2.objectLiteral = objectLiteral;
        function typedArray(value, check) {
          return Array.isArray(value) && value.every(check);
        }
        Is2.typedArray = typedArray;
      })(Is || (Is = {}));
    });
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/messages.js
var require_messages2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/messages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProtocolNotificationType = exports2.ProtocolNotificationType0 = exports2.ProtocolRequestType = exports2.ProtocolRequestType0 = exports2.RegistrationType = void 0;
    var vscode_jsonrpc_1 = require_main();
    var RegistrationType = class {
      constructor(method) {
        this.method = method;
      }
    };
    exports2.RegistrationType = RegistrationType;
    var ProtocolRequestType0 = class extends vscode_jsonrpc_1.RequestType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolRequestType0 = ProtocolRequestType0;
    var ProtocolRequestType = class extends vscode_jsonrpc_1.RequestType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolRequestType = ProtocolRequestType;
    var ProtocolNotificationType0 = class extends vscode_jsonrpc_1.NotificationType0 {
      constructor(method) {
        super(method);
      }
    };
    exports2.ProtocolNotificationType0 = ProtocolNotificationType0;
    var ProtocolNotificationType = class extends vscode_jsonrpc_1.NotificationType {
      constructor(method) {
        super(method, vscode_jsonrpc_1.ParameterStructures.byName);
      }
    };
    exports2.ProtocolNotificationType = ProtocolNotificationType;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/utils/is.js
var require_is3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/utils/is.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.objectLiteral = exports2.typedArray = exports2.stringArray = exports2.array = exports2.func = exports2.error = exports2.number = exports2.string = exports2.boolean = void 0;
    function boolean(value) {
      return value === true || value === false;
    }
    exports2.boolean = boolean;
    function string(value) {
      return typeof value === "string" || value instanceof String;
    }
    exports2.string = string;
    function number(value) {
      return typeof value === "number" || value instanceof Number;
    }
    exports2.number = number;
    function error(value) {
      return value instanceof Error;
    }
    exports2.error = error;
    function func(value) {
      return typeof value === "function";
    }
    exports2.func = func;
    function array(value) {
      return Array.isArray(value);
    }
    exports2.array = array;
    function stringArray(value) {
      return array(value) && value.every((elem) => string(elem));
    }
    exports2.stringArray = stringArray;
    function typedArray(value, check) {
      return Array.isArray(value) && value.every(check);
    }
    exports2.typedArray = typedArray;
    function objectLiteral(value) {
      return value !== null && typeof value === "object";
    }
    exports2.objectLiteral = objectLiteral;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js
var require_protocol_implementation = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.implementation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ImplementationRequest = void 0;
    var messages_1 = require_messages2();
    var ImplementationRequest;
    (function(ImplementationRequest2) {
      ImplementationRequest2.method = "textDocument/implementation";
      ImplementationRequest2.type = new messages_1.ProtocolRequestType(ImplementationRequest2.method);
    })(ImplementationRequest = exports2.ImplementationRequest || (exports2.ImplementationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js
var require_protocol_typeDefinition = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeDefinition.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeDefinitionRequest = void 0;
    var messages_1 = require_messages2();
    var TypeDefinitionRequest;
    (function(TypeDefinitionRequest2) {
      TypeDefinitionRequest2.method = "textDocument/typeDefinition";
      TypeDefinitionRequest2.type = new messages_1.ProtocolRequestType(TypeDefinitionRequest2.method);
    })(TypeDefinitionRequest = exports2.TypeDefinitionRequest || (exports2.TypeDefinitionRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js
var require_protocol_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = void 0;
    var messages_1 = require_messages2();
    var WorkspaceFoldersRequest;
    (function(WorkspaceFoldersRequest2) {
      WorkspaceFoldersRequest2.type = new messages_1.ProtocolRequestType0("workspace/workspaceFolders");
    })(WorkspaceFoldersRequest = exports2.WorkspaceFoldersRequest || (exports2.WorkspaceFoldersRequest = {}));
    var DidChangeWorkspaceFoldersNotification;
    (function(DidChangeWorkspaceFoldersNotification2) {
      DidChangeWorkspaceFoldersNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWorkspaceFolders");
    })(DidChangeWorkspaceFoldersNotification = exports2.DidChangeWorkspaceFoldersNotification || (exports2.DidChangeWorkspaceFoldersNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js
var require_protocol_configuration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationRequest = void 0;
    var messages_1 = require_messages2();
    var ConfigurationRequest;
    (function(ConfigurationRequest2) {
      ConfigurationRequest2.type = new messages_1.ProtocolRequestType("workspace/configuration");
    })(ConfigurationRequest = exports2.ConfigurationRequest || (exports2.ConfigurationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js
var require_protocol_colorProvider = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.colorProvider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ColorPresentationRequest = exports2.DocumentColorRequest = void 0;
    var messages_1 = require_messages2();
    var DocumentColorRequest;
    (function(DocumentColorRequest2) {
      DocumentColorRequest2.method = "textDocument/documentColor";
      DocumentColorRequest2.type = new messages_1.ProtocolRequestType(DocumentColorRequest2.method);
    })(DocumentColorRequest = exports2.DocumentColorRequest || (exports2.DocumentColorRequest = {}));
    var ColorPresentationRequest;
    (function(ColorPresentationRequest2) {
      ColorPresentationRequest2.type = new messages_1.ProtocolRequestType("textDocument/colorPresentation");
    })(ColorPresentationRequest = exports2.ColorPresentationRequest || (exports2.ColorPresentationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js
var require_protocol_foldingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.foldingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FoldingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var FoldingRangeRequest;
    (function(FoldingRangeRequest2) {
      FoldingRangeRequest2.method = "textDocument/foldingRange";
      FoldingRangeRequest2.type = new messages_1.ProtocolRequestType(FoldingRangeRequest2.method);
    })(FoldingRangeRequest = exports2.FoldingRangeRequest || (exports2.FoldingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js
var require_protocol_declaration = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.declaration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DeclarationRequest = void 0;
    var messages_1 = require_messages2();
    var DeclarationRequest;
    (function(DeclarationRequest2) {
      DeclarationRequest2.method = "textDocument/declaration";
      DeclarationRequest2.type = new messages_1.ProtocolRequestType(DeclarationRequest2.method);
    })(DeclarationRequest = exports2.DeclarationRequest || (exports2.DeclarationRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js
var require_protocol_selectionRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.selectionRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SelectionRangeRequest = void 0;
    var messages_1 = require_messages2();
    var SelectionRangeRequest;
    (function(SelectionRangeRequest2) {
      SelectionRangeRequest2.method = "textDocument/selectionRange";
      SelectionRangeRequest2.type = new messages_1.ProtocolRequestType(SelectionRangeRequest2.method);
    })(SelectionRangeRequest = exports2.SelectionRangeRequest || (exports2.SelectionRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js
var require_protocol_progress = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = void 0;
    var vscode_jsonrpc_1 = require_main();
    var messages_1 = require_messages2();
    var WorkDoneProgress;
    (function(WorkDoneProgress2) {
      WorkDoneProgress2.type = new vscode_jsonrpc_1.ProgressType();
      function is(value) {
        return value === WorkDoneProgress2.type;
      }
      WorkDoneProgress2.is = is;
    })(WorkDoneProgress = exports2.WorkDoneProgress || (exports2.WorkDoneProgress = {}));
    var WorkDoneProgressCreateRequest;
    (function(WorkDoneProgressCreateRequest2) {
      WorkDoneProgressCreateRequest2.method = "window/workDoneProgress/create";
      WorkDoneProgressCreateRequest2.type = new messages_1.ProtocolRequestType(WorkDoneProgressCreateRequest2.method);
    })(WorkDoneProgressCreateRequest = exports2.WorkDoneProgressCreateRequest || (exports2.WorkDoneProgressCreateRequest = {}));
    var WorkDoneProgressCancelNotification;
    (function(WorkDoneProgressCancelNotification2) {
      WorkDoneProgressCancelNotification2.method = "window/workDoneProgress/cancel";
      WorkDoneProgressCancelNotification2.type = new messages_1.ProtocolNotificationType(WorkDoneProgressCancelNotification2.method);
    })(WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCancelNotification || (exports2.WorkDoneProgressCancelNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js
var require_protocol_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.CallHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var CallHierarchyPrepareRequest;
    (function(CallHierarchyPrepareRequest2) {
      CallHierarchyPrepareRequest2.method = "textDocument/prepareCallHierarchy";
      CallHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyPrepareRequest2.method);
    })(CallHierarchyPrepareRequest = exports2.CallHierarchyPrepareRequest || (exports2.CallHierarchyPrepareRequest = {}));
    var CallHierarchyIncomingCallsRequest;
    (function(CallHierarchyIncomingCallsRequest2) {
      CallHierarchyIncomingCallsRequest2.method = "callHierarchy/incomingCalls";
      CallHierarchyIncomingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyIncomingCallsRequest2.method);
    })(CallHierarchyIncomingCallsRequest = exports2.CallHierarchyIncomingCallsRequest || (exports2.CallHierarchyIncomingCallsRequest = {}));
    var CallHierarchyOutgoingCallsRequest;
    (function(CallHierarchyOutgoingCallsRequest2) {
      CallHierarchyOutgoingCallsRequest2.method = "callHierarchy/outgoingCalls";
      CallHierarchyOutgoingCallsRequest2.type = new messages_1.ProtocolRequestType(CallHierarchyOutgoingCallsRequest2.method);
    })(CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyOutgoingCallsRequest || (exports2.CallHierarchyOutgoingCallsRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js
var require_protocol_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.SemanticTokensRegistrationType = exports2.TokenFormat = void 0;
    var messages_1 = require_messages2();
    var TokenFormat;
    (function(TokenFormat2) {
      TokenFormat2.Relative = "relative";
    })(TokenFormat = exports2.TokenFormat || (exports2.TokenFormat = {}));
    var SemanticTokensRegistrationType;
    (function(SemanticTokensRegistrationType2) {
      SemanticTokensRegistrationType2.method = "textDocument/semanticTokens";
      SemanticTokensRegistrationType2.type = new messages_1.RegistrationType(SemanticTokensRegistrationType2.method);
    })(SemanticTokensRegistrationType = exports2.SemanticTokensRegistrationType || (exports2.SemanticTokensRegistrationType = {}));
    var SemanticTokensRequest;
    (function(SemanticTokensRequest2) {
      SemanticTokensRequest2.method = "textDocument/semanticTokens/full";
      SemanticTokensRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRequest2.method);
    })(SemanticTokensRequest = exports2.SemanticTokensRequest || (exports2.SemanticTokensRequest = {}));
    var SemanticTokensDeltaRequest;
    (function(SemanticTokensDeltaRequest2) {
      SemanticTokensDeltaRequest2.method = "textDocument/semanticTokens/full/delta";
      SemanticTokensDeltaRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensDeltaRequest2.method);
    })(SemanticTokensDeltaRequest = exports2.SemanticTokensDeltaRequest || (exports2.SemanticTokensDeltaRequest = {}));
    var SemanticTokensRangeRequest;
    (function(SemanticTokensRangeRequest2) {
      SemanticTokensRangeRequest2.method = "textDocument/semanticTokens/range";
      SemanticTokensRangeRequest2.type = new messages_1.ProtocolRequestType(SemanticTokensRangeRequest2.method);
    })(SemanticTokensRangeRequest = exports2.SemanticTokensRangeRequest || (exports2.SemanticTokensRangeRequest = {}));
    var SemanticTokensRefreshRequest;
    (function(SemanticTokensRefreshRequest2) {
      SemanticTokensRefreshRequest2.method = `workspace/semanticTokens/refresh`;
      SemanticTokensRefreshRequest2.type = new messages_1.ProtocolRequestType0(SemanticTokensRefreshRequest2.method);
    })(SemanticTokensRefreshRequest = exports2.SemanticTokensRefreshRequest || (exports2.SemanticTokensRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js
var require_protocol_showDocument = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentRequest = void 0;
    var messages_1 = require_messages2();
    var ShowDocumentRequest;
    (function(ShowDocumentRequest2) {
      ShowDocumentRequest2.method = "window/showDocument";
      ShowDocumentRequest2.type = new messages_1.ProtocolRequestType(ShowDocumentRequest2.method);
    })(ShowDocumentRequest = exports2.ShowDocumentRequest || (exports2.ShowDocumentRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js
var require_protocol_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeRequest = void 0;
    var messages_1 = require_messages2();
    var LinkedEditingRangeRequest;
    (function(LinkedEditingRangeRequest2) {
      LinkedEditingRangeRequest2.method = "textDocument/linkedEditingRange";
      LinkedEditingRangeRequest2.type = new messages_1.ProtocolRequestType(LinkedEditingRangeRequest2.method);
    })(LinkedEditingRangeRequest = exports2.LinkedEditingRangeRequest || (exports2.LinkedEditingRangeRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js
var require_protocol_fileOperations = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.DidRenameFilesNotification = exports2.WillRenameFilesRequest = exports2.DidCreateFilesNotification = exports2.WillCreateFilesRequest = exports2.FileOperationPatternKind = void 0;
    var messages_1 = require_messages2();
    var FileOperationPatternKind;
    (function(FileOperationPatternKind2) {
      FileOperationPatternKind2.file = "file";
      FileOperationPatternKind2.folder = "folder";
    })(FileOperationPatternKind = exports2.FileOperationPatternKind || (exports2.FileOperationPatternKind = {}));
    var WillCreateFilesRequest;
    (function(WillCreateFilesRequest2) {
      WillCreateFilesRequest2.method = "workspace/willCreateFiles";
      WillCreateFilesRequest2.type = new messages_1.ProtocolRequestType(WillCreateFilesRequest2.method);
    })(WillCreateFilesRequest = exports2.WillCreateFilesRequest || (exports2.WillCreateFilesRequest = {}));
    var DidCreateFilesNotification;
    (function(DidCreateFilesNotification2) {
      DidCreateFilesNotification2.method = "workspace/didCreateFiles";
      DidCreateFilesNotification2.type = new messages_1.ProtocolNotificationType(DidCreateFilesNotification2.method);
    })(DidCreateFilesNotification = exports2.DidCreateFilesNotification || (exports2.DidCreateFilesNotification = {}));
    var WillRenameFilesRequest;
    (function(WillRenameFilesRequest2) {
      WillRenameFilesRequest2.method = "workspace/willRenameFiles";
      WillRenameFilesRequest2.type = new messages_1.ProtocolRequestType(WillRenameFilesRequest2.method);
    })(WillRenameFilesRequest = exports2.WillRenameFilesRequest || (exports2.WillRenameFilesRequest = {}));
    var DidRenameFilesNotification;
    (function(DidRenameFilesNotification2) {
      DidRenameFilesNotification2.method = "workspace/didRenameFiles";
      DidRenameFilesNotification2.type = new messages_1.ProtocolNotificationType(DidRenameFilesNotification2.method);
    })(DidRenameFilesNotification = exports2.DidRenameFilesNotification || (exports2.DidRenameFilesNotification = {}));
    var DidDeleteFilesNotification;
    (function(DidDeleteFilesNotification2) {
      DidDeleteFilesNotification2.method = "workspace/didDeleteFiles";
      DidDeleteFilesNotification2.type = new messages_1.ProtocolNotificationType(DidDeleteFilesNotification2.method);
    })(DidDeleteFilesNotification = exports2.DidDeleteFilesNotification || (exports2.DidDeleteFilesNotification = {}));
    var WillDeleteFilesRequest;
    (function(WillDeleteFilesRequest2) {
      WillDeleteFilesRequest2.method = "workspace/willDeleteFiles";
      WillDeleteFilesRequest2.type = new messages_1.ProtocolRequestType(WillDeleteFilesRequest2.method);
    })(WillDeleteFilesRequest = exports2.WillDeleteFilesRequest || (exports2.WillDeleteFilesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js
var require_protocol_moniker = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = void 0;
    var messages_1 = require_messages2();
    var UniquenessLevel;
    (function(UniquenessLevel2) {
      UniquenessLevel2.document = "document";
      UniquenessLevel2.project = "project";
      UniquenessLevel2.group = "group";
      UniquenessLevel2.scheme = "scheme";
      UniquenessLevel2.global = "global";
    })(UniquenessLevel = exports2.UniquenessLevel || (exports2.UniquenessLevel = {}));
    var MonikerKind;
    (function(MonikerKind2) {
      MonikerKind2.$import = "import";
      MonikerKind2.$export = "export";
      MonikerKind2.local = "local";
    })(MonikerKind = exports2.MonikerKind || (exports2.MonikerKind = {}));
    var MonikerRequest;
    (function(MonikerRequest2) {
      MonikerRequest2.method = "textDocument/moniker";
      MonikerRequest2.type = new messages_1.ProtocolRequestType(MonikerRequest2.method);
    })(MonikerRequest = exports2.MonikerRequest || (exports2.MonikerRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js
var require_protocol_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchySupertypesRequest = exports2.TypeHierarchyPrepareRequest = void 0;
    var messages_1 = require_messages2();
    var TypeHierarchyPrepareRequest;
    (function(TypeHierarchyPrepareRequest2) {
      TypeHierarchyPrepareRequest2.method = "textDocument/prepareTypeHierarchy";
      TypeHierarchyPrepareRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchyPrepareRequest2.method);
    })(TypeHierarchyPrepareRequest = exports2.TypeHierarchyPrepareRequest || (exports2.TypeHierarchyPrepareRequest = {}));
    var TypeHierarchySupertypesRequest;
    (function(TypeHierarchySupertypesRequest2) {
      TypeHierarchySupertypesRequest2.method = "typeHierarchy/supertypes";
      TypeHierarchySupertypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySupertypesRequest2.method);
    })(TypeHierarchySupertypesRequest = exports2.TypeHierarchySupertypesRequest || (exports2.TypeHierarchySupertypesRequest = {}));
    var TypeHierarchySubtypesRequest;
    (function(TypeHierarchySubtypesRequest2) {
      TypeHierarchySubtypesRequest2.method = "typeHierarchy/subtypes";
      TypeHierarchySubtypesRequest2.type = new messages_1.ProtocolRequestType(TypeHierarchySubtypesRequest2.method);
    })(TypeHierarchySubtypesRequest = exports2.TypeHierarchySubtypesRequest || (exports2.TypeHierarchySubtypesRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js
var require_protocol_inlineValue = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = void 0;
    var messages_1 = require_messages2();
    var InlineValueRequest;
    (function(InlineValueRequest2) {
      InlineValueRequest2.method = "textDocument/inlineValue";
      InlineValueRequest2.type = new messages_1.ProtocolRequestType(InlineValueRequest2.method);
    })(InlineValueRequest = exports2.InlineValueRequest || (exports2.InlineValueRequest = {}));
    var InlineValueRefreshRequest;
    (function(InlineValueRefreshRequest2) {
      InlineValueRefreshRequest2.method = `workspace/inlineValue/refresh`;
      InlineValueRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlineValueRefreshRequest2.method);
    })(InlineValueRefreshRequest = exports2.InlineValueRefreshRequest || (exports2.InlineValueRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js
var require_protocol_inlayHint = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = void 0;
    var messages_1 = require_messages2();
    var InlayHintRequest;
    (function(InlayHintRequest2) {
      InlayHintRequest2.method = "textDocument/inlayHint";
      InlayHintRequest2.type = new messages_1.ProtocolRequestType(InlayHintRequest2.method);
    })(InlayHintRequest = exports2.InlayHintRequest || (exports2.InlayHintRequest = {}));
    var InlayHintResolveRequest;
    (function(InlayHintResolveRequest2) {
      InlayHintResolveRequest2.method = "inlayHint/resolve";
      InlayHintResolveRequest2.type = new messages_1.ProtocolRequestType(InlayHintResolveRequest2.method);
    })(InlayHintResolveRequest = exports2.InlayHintResolveRequest || (exports2.InlayHintResolveRequest = {}));
    var InlayHintRefreshRequest;
    (function(InlayHintRefreshRequest2) {
      InlayHintRefreshRequest2.method = `workspace/inlayHint/refresh`;
      InlayHintRefreshRequest2.type = new messages_1.ProtocolRequestType0(InlayHintRefreshRequest2.method);
    })(InlayHintRefreshRequest = exports2.InlayHintRefreshRequest || (exports2.InlayHintRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js
var require_protocol_diagnostic = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = void 0;
    var vscode_jsonrpc_1 = require_main();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var DiagnosticServerCancellationData;
    (function(DiagnosticServerCancellationData2) {
      function is(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.retriggerRequest);
      }
      DiagnosticServerCancellationData2.is = is;
    })(DiagnosticServerCancellationData = exports2.DiagnosticServerCancellationData || (exports2.DiagnosticServerCancellationData = {}));
    var DocumentDiagnosticReportKind;
    (function(DocumentDiagnosticReportKind2) {
      DocumentDiagnosticReportKind2.Full = "full";
      DocumentDiagnosticReportKind2.Unchanged = "unchanged";
    })(DocumentDiagnosticReportKind = exports2.DocumentDiagnosticReportKind || (exports2.DocumentDiagnosticReportKind = {}));
    var DocumentDiagnosticRequest;
    (function(DocumentDiagnosticRequest2) {
      DocumentDiagnosticRequest2.method = "textDocument/diagnostic";
      DocumentDiagnosticRequest2.type = new messages_1.ProtocolRequestType(DocumentDiagnosticRequest2.method);
      DocumentDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(DocumentDiagnosticRequest = exports2.DocumentDiagnosticRequest || (exports2.DocumentDiagnosticRequest = {}));
    var WorkspaceDiagnosticRequest;
    (function(WorkspaceDiagnosticRequest2) {
      WorkspaceDiagnosticRequest2.method = "workspace/diagnostic";
      WorkspaceDiagnosticRequest2.type = new messages_1.ProtocolRequestType(WorkspaceDiagnosticRequest2.method);
      WorkspaceDiagnosticRequest2.partialResult = new vscode_jsonrpc_1.ProgressType();
    })(WorkspaceDiagnosticRequest = exports2.WorkspaceDiagnosticRequest || (exports2.WorkspaceDiagnosticRequest = {}));
    var DiagnosticRefreshRequest;
    (function(DiagnosticRefreshRequest2) {
      DiagnosticRefreshRequest2.method = `workspace/diagnostic/refresh`;
      DiagnosticRefreshRequest2.type = new messages_1.ProtocolRequestType0(DiagnosticRefreshRequest2.method);
    })(DiagnosticRefreshRequest = exports2.DiagnosticRefreshRequest || (exports2.DiagnosticRefreshRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js
var require_protocol_notebook = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var messages_1 = require_messages2();
    var NotebookCellKind;
    (function(NotebookCellKind2) {
      NotebookCellKind2.Markup = 1;
      NotebookCellKind2.Code = 2;
      function is(value) {
        return value === 1 || value === 2;
      }
      NotebookCellKind2.is = is;
    })(NotebookCellKind = exports2.NotebookCellKind || (exports2.NotebookCellKind = {}));
    var ExecutionSummary;
    (function(ExecutionSummary2) {
      function create(executionOrder, success) {
        const result = { executionOrder };
        if (success === true || success === false) {
          result.success = success;
        }
        return result;
      }
      ExecutionSummary2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.executionOrder) && (candidate.success === void 0 || Is.boolean(candidate.success));
      }
      ExecutionSummary2.is = is;
      function equals(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        return one.executionOrder === other.executionOrder && one.success === other.success;
      }
      ExecutionSummary2.equals = equals;
    })(ExecutionSummary = exports2.ExecutionSummary || (exports2.ExecutionSummary = {}));
    var NotebookCell;
    (function(NotebookCell2) {
      function create(kind, document) {
        return { kind, document };
      }
      NotebookCell2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && NotebookCellKind.is(candidate.kind) && vscode_languageserver_types_1.DocumentUri.is(candidate.document) && (candidate.metadata === void 0 || Is.objectLiteral(candidate.metadata));
      }
      NotebookCell2.is = is;
      function diff(one, two) {
        const result = /* @__PURE__ */ new Set();
        if (one.document !== two.document) {
          result.add("document");
        }
        if (one.kind !== two.kind) {
          result.add("kind");
        }
        if (one.executionSummary !== two.executionSummary) {
          result.add("executionSummary");
        }
        if ((one.metadata !== void 0 || two.metadata !== void 0) && !equalsMetadata(one.metadata, two.metadata)) {
          result.add("metadata");
        }
        if ((one.executionSummary !== void 0 || two.executionSummary !== void 0) && !ExecutionSummary.equals(one.executionSummary, two.executionSummary)) {
          result.add("executionSummary");
        }
        return result;
      }
      NotebookCell2.diff = diff;
      function equalsMetadata(one, other) {
        if (one === other) {
          return true;
        }
        if (one === null || one === void 0 || other === null || other === void 0) {
          return false;
        }
        if (typeof one !== typeof other) {
          return false;
        }
        if (typeof one !== "object") {
          return false;
        }
        const oneArray = Array.isArray(one);
        const otherArray = Array.isArray(other);
        if (oneArray !== otherArray) {
          return false;
        }
        if (oneArray && otherArray) {
          if (one.length !== other.length) {
            return false;
          }
          for (let i = 0; i < one.length; i++) {
            if (!equalsMetadata(one[i], other[i])) {
              return false;
            }
          }
        }
        if (Is.objectLiteral(one) && Is.objectLiteral(other)) {
          const oneKeys = Object.keys(one);
          const otherKeys = Object.keys(other);
          if (oneKeys.length !== otherKeys.length) {
            return false;
          }
          oneKeys.sort();
          otherKeys.sort();
          if (!equalsMetadata(oneKeys, otherKeys)) {
            return false;
          }
          for (let i = 0; i < oneKeys.length; i++) {
            const prop = oneKeys[i];
            if (!equalsMetadata(one[prop], other[prop])) {
              return false;
            }
          }
        }
        return true;
      }
    })(NotebookCell = exports2.NotebookCell || (exports2.NotebookCell = {}));
    var NotebookDocument;
    (function(NotebookDocument2) {
      function create(uri, notebookType, version, cells) {
        return { uri, notebookType, version, cells };
      }
      NotebookDocument2.create = create;
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.uri) && vscode_languageserver_types_1.integer.is(candidate.version) && Is.typedArray(candidate.cells, NotebookCell.is);
      }
      NotebookDocument2.is = is;
    })(NotebookDocument = exports2.NotebookDocument || (exports2.NotebookDocument = {}));
    var NotebookDocumentSyncRegistrationType;
    (function(NotebookDocumentSyncRegistrationType2) {
      NotebookDocumentSyncRegistrationType2.method = "notebookDocument/sync";
      NotebookDocumentSyncRegistrationType2.type = new messages_1.RegistrationType(NotebookDocumentSyncRegistrationType2.method);
    })(NotebookDocumentSyncRegistrationType = exports2.NotebookDocumentSyncRegistrationType || (exports2.NotebookDocumentSyncRegistrationType = {}));
    var DidOpenNotebookDocumentNotification;
    (function(DidOpenNotebookDocumentNotification2) {
      DidOpenNotebookDocumentNotification2.method = "notebookDocument/didOpen";
      DidOpenNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenNotebookDocumentNotification2.method);
    })(DidOpenNotebookDocumentNotification = exports2.DidOpenNotebookDocumentNotification || (exports2.DidOpenNotebookDocumentNotification = {}));
    var NotebookCellArrayChange;
    (function(NotebookCellArrayChange2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && vscode_languageserver_types_1.uinteger.is(candidate.start) && vscode_languageserver_types_1.uinteger.is(candidate.deleteCount) && (candidate.cells === void 0 || Is.typedArray(candidate.cells, NotebookCell.is));
      }
      NotebookCellArrayChange2.is = is;
      function create(start, deleteCount, cells) {
        const result = { start, deleteCount };
        if (cells !== void 0) {
          result.cells = cells;
        }
        return result;
      }
      NotebookCellArrayChange2.create = create;
    })(NotebookCellArrayChange = exports2.NotebookCellArrayChange || (exports2.NotebookCellArrayChange = {}));
    var DidChangeNotebookDocumentNotification;
    (function(DidChangeNotebookDocumentNotification2) {
      DidChangeNotebookDocumentNotification2.method = "notebookDocument/didChange";
      DidChangeNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeNotebookDocumentNotification2.method);
    })(DidChangeNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification || (exports2.DidChangeNotebookDocumentNotification = {}));
    var DidSaveNotebookDocumentNotification;
    (function(DidSaveNotebookDocumentNotification2) {
      DidSaveNotebookDocumentNotification2.method = "notebookDocument/didSave";
      DidSaveNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveNotebookDocumentNotification2.method);
    })(DidSaveNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification || (exports2.DidSaveNotebookDocumentNotification = {}));
    var DidCloseNotebookDocumentNotification;
    (function(DidCloseNotebookDocumentNotification2) {
      DidCloseNotebookDocumentNotification2.method = "notebookDocument/didClose";
      DidCloseNotebookDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseNotebookDocumentNotification2.method);
    })(DidCloseNotebookDocumentNotification = exports2.DidCloseNotebookDocumentNotification || (exports2.DidCloseNotebookDocumentNotification = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/protocol.js
var require_protocol = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/protocol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceSymbolRequest = exports2.CodeActionResolveRequest = exports2.CodeActionRequest = exports2.DocumentSymbolRequest = exports2.DocumentHighlightRequest = exports2.ReferencesRequest = exports2.DefinitionRequest = exports2.SignatureHelpRequest = exports2.SignatureHelpTriggerKind = exports2.HoverRequest = exports2.CompletionResolveRequest = exports2.CompletionRequest = exports2.CompletionTriggerKind = exports2.PublishDiagnosticsNotification = exports2.WatchKind = exports2.RelativePattern = exports2.FileChangeType = exports2.DidChangeWatchedFilesNotification = exports2.WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentNotification = exports2.TextDocumentSaveReason = exports2.DidSaveTextDocumentNotification = exports2.DidCloseTextDocumentNotification = exports2.DidChangeTextDocumentNotification = exports2.TextDocumentContentChangeEvent = exports2.DidOpenTextDocumentNotification = exports2.TextDocumentSyncKind = exports2.TelemetryEventNotification = exports2.LogMessageNotification = exports2.ShowMessageRequest = exports2.ShowMessageNotification = exports2.MessageType = exports2.DidChangeConfigurationNotification = exports2.ExitNotification = exports2.ShutdownRequest = exports2.InitializedNotification = exports2.InitializeErrorCodes = exports2.InitializeRequest = exports2.WorkDoneProgressOptions = exports2.TextDocumentRegistrationOptions = exports2.StaticRegistrationOptions = exports2.PositionEncodingKind = exports2.FailureHandlingKind = exports2.ResourceOperationKind = exports2.UnregistrationRequest = exports2.RegistrationRequest = exports2.DocumentSelector = exports2.NotebookCellTextDocumentFilter = exports2.NotebookDocumentFilter = exports2.TextDocumentFilter = void 0;
    exports2.TypeHierarchySubtypesRequest = exports2.TypeHierarchyPrepareRequest = exports2.MonikerRequest = exports2.MonikerKind = exports2.UniquenessLevel = exports2.WillDeleteFilesRequest = exports2.DidDeleteFilesNotification = exports2.WillRenameFilesRequest = exports2.DidRenameFilesNotification = exports2.WillCreateFilesRequest = exports2.DidCreateFilesNotification = exports2.FileOperationPatternKind = exports2.LinkedEditingRangeRequest = exports2.ShowDocumentRequest = exports2.SemanticTokensRegistrationType = exports2.SemanticTokensRefreshRequest = exports2.SemanticTokensRangeRequest = exports2.SemanticTokensDeltaRequest = exports2.SemanticTokensRequest = exports2.TokenFormat = exports2.CallHierarchyPrepareRequest = exports2.CallHierarchyOutgoingCallsRequest = exports2.CallHierarchyIncomingCallsRequest = exports2.WorkDoneProgressCancelNotification = exports2.WorkDoneProgressCreateRequest = exports2.WorkDoneProgress = exports2.SelectionRangeRequest = exports2.DeclarationRequest = exports2.FoldingRangeRequest = exports2.ColorPresentationRequest = exports2.DocumentColorRequest = exports2.ConfigurationRequest = exports2.DidChangeWorkspaceFoldersNotification = exports2.WorkspaceFoldersRequest = exports2.TypeDefinitionRequest = exports2.ImplementationRequest = exports2.ApplyWorkspaceEditRequest = exports2.ExecuteCommandRequest = exports2.PrepareRenameRequest = exports2.RenameRequest = exports2.PrepareSupportDefaultBehavior = exports2.DocumentOnTypeFormattingRequest = exports2.DocumentRangeFormattingRequest = exports2.DocumentFormattingRequest = exports2.DocumentLinkResolveRequest = exports2.DocumentLinkRequest = exports2.CodeLensRefreshRequest = exports2.CodeLensResolveRequest = exports2.CodeLensRequest = exports2.WorkspaceSymbolResolveRequest = void 0;
    exports2.DidCloseNotebookDocumentNotification = exports2.DidSaveNotebookDocumentNotification = exports2.DidChangeNotebookDocumentNotification = exports2.NotebookCellArrayChange = exports2.DidOpenNotebookDocumentNotification = exports2.NotebookDocumentSyncRegistrationType = exports2.NotebookDocument = exports2.NotebookCell = exports2.ExecutionSummary = exports2.NotebookCellKind = exports2.DiagnosticRefreshRequest = exports2.WorkspaceDiagnosticRequest = exports2.DocumentDiagnosticRequest = exports2.DocumentDiagnosticReportKind = exports2.DiagnosticServerCancellationData = exports2.InlayHintRefreshRequest = exports2.InlayHintResolveRequest = exports2.InlayHintRequest = exports2.InlineValueRefreshRequest = exports2.InlineValueRequest = exports2.TypeHierarchySupertypesRequest = void 0;
    var messages_1 = require_messages2();
    var vscode_languageserver_types_1 = require_main2();
    var Is = require_is3();
    var protocol_implementation_1 = require_protocol_implementation();
    Object.defineProperty(exports2, "ImplementationRequest", { enumerable: true, get: function() {
      return protocol_implementation_1.ImplementationRequest;
    } });
    var protocol_typeDefinition_1 = require_protocol_typeDefinition();
    Object.defineProperty(exports2, "TypeDefinitionRequest", { enumerable: true, get: function() {
      return protocol_typeDefinition_1.TypeDefinitionRequest;
    } });
    var protocol_workspaceFolder_1 = require_protocol_workspaceFolder();
    Object.defineProperty(exports2, "WorkspaceFoldersRequest", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.WorkspaceFoldersRequest;
    } });
    Object.defineProperty(exports2, "DidChangeWorkspaceFoldersNotification", { enumerable: true, get: function() {
      return protocol_workspaceFolder_1.DidChangeWorkspaceFoldersNotification;
    } });
    var protocol_configuration_1 = require_protocol_configuration();
    Object.defineProperty(exports2, "ConfigurationRequest", { enumerable: true, get: function() {
      return protocol_configuration_1.ConfigurationRequest;
    } });
    var protocol_colorProvider_1 = require_protocol_colorProvider();
    Object.defineProperty(exports2, "DocumentColorRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.DocumentColorRequest;
    } });
    Object.defineProperty(exports2, "ColorPresentationRequest", { enumerable: true, get: function() {
      return protocol_colorProvider_1.ColorPresentationRequest;
    } });
    var protocol_foldingRange_1 = require_protocol_foldingRange();
    Object.defineProperty(exports2, "FoldingRangeRequest", { enumerable: true, get: function() {
      return protocol_foldingRange_1.FoldingRangeRequest;
    } });
    var protocol_declaration_1 = require_protocol_declaration();
    Object.defineProperty(exports2, "DeclarationRequest", { enumerable: true, get: function() {
      return protocol_declaration_1.DeclarationRequest;
    } });
    var protocol_selectionRange_1 = require_protocol_selectionRange();
    Object.defineProperty(exports2, "SelectionRangeRequest", { enumerable: true, get: function() {
      return protocol_selectionRange_1.SelectionRangeRequest;
    } });
    var protocol_progress_1 = require_protocol_progress();
    Object.defineProperty(exports2, "WorkDoneProgress", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgress;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCreateRequest", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCreateRequest;
    } });
    Object.defineProperty(exports2, "WorkDoneProgressCancelNotification", { enumerable: true, get: function() {
      return protocol_progress_1.WorkDoneProgressCancelNotification;
    } });
    var protocol_callHierarchy_1 = require_protocol_callHierarchy();
    Object.defineProperty(exports2, "CallHierarchyIncomingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyIncomingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyOutgoingCallsRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyOutgoingCallsRequest;
    } });
    Object.defineProperty(exports2, "CallHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_callHierarchy_1.CallHierarchyPrepareRequest;
    } });
    var protocol_semanticTokens_1 = require_protocol_semanticTokens();
    Object.defineProperty(exports2, "TokenFormat", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.TokenFormat;
    } });
    Object.defineProperty(exports2, "SemanticTokensRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensDeltaRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensDeltaRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRangeRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRangeRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRefreshRequest", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRefreshRequest;
    } });
    Object.defineProperty(exports2, "SemanticTokensRegistrationType", { enumerable: true, get: function() {
      return protocol_semanticTokens_1.SemanticTokensRegistrationType;
    } });
    var protocol_showDocument_1 = require_protocol_showDocument();
    Object.defineProperty(exports2, "ShowDocumentRequest", { enumerable: true, get: function() {
      return protocol_showDocument_1.ShowDocumentRequest;
    } });
    var protocol_linkedEditingRange_1 = require_protocol_linkedEditingRange();
    Object.defineProperty(exports2, "LinkedEditingRangeRequest", { enumerable: true, get: function() {
      return protocol_linkedEditingRange_1.LinkedEditingRangeRequest;
    } });
    var protocol_fileOperations_1 = require_protocol_fileOperations();
    Object.defineProperty(exports2, "FileOperationPatternKind", { enumerable: true, get: function() {
      return protocol_fileOperations_1.FileOperationPatternKind;
    } });
    Object.defineProperty(exports2, "DidCreateFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidCreateFilesNotification;
    } });
    Object.defineProperty(exports2, "WillCreateFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillCreateFilesRequest;
    } });
    Object.defineProperty(exports2, "DidRenameFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidRenameFilesNotification;
    } });
    Object.defineProperty(exports2, "WillRenameFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillRenameFilesRequest;
    } });
    Object.defineProperty(exports2, "DidDeleteFilesNotification", { enumerable: true, get: function() {
      return protocol_fileOperations_1.DidDeleteFilesNotification;
    } });
    Object.defineProperty(exports2, "WillDeleteFilesRequest", { enumerable: true, get: function() {
      return protocol_fileOperations_1.WillDeleteFilesRequest;
    } });
    var protocol_moniker_1 = require_protocol_moniker();
    Object.defineProperty(exports2, "UniquenessLevel", { enumerable: true, get: function() {
      return protocol_moniker_1.UniquenessLevel;
    } });
    Object.defineProperty(exports2, "MonikerKind", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerKind;
    } });
    Object.defineProperty(exports2, "MonikerRequest", { enumerable: true, get: function() {
      return protocol_moniker_1.MonikerRequest;
    } });
    var protocol_typeHierarchy_1 = require_protocol_typeHierarchy();
    Object.defineProperty(exports2, "TypeHierarchyPrepareRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchyPrepareRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySubtypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySubtypesRequest;
    } });
    Object.defineProperty(exports2, "TypeHierarchySupertypesRequest", { enumerable: true, get: function() {
      return protocol_typeHierarchy_1.TypeHierarchySupertypesRequest;
    } });
    var protocol_inlineValue_1 = require_protocol_inlineValue();
    Object.defineProperty(exports2, "InlineValueRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRequest;
    } });
    Object.defineProperty(exports2, "InlineValueRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlineValue_1.InlineValueRefreshRequest;
    } });
    var protocol_inlayHint_1 = require_protocol_inlayHint();
    Object.defineProperty(exports2, "InlayHintRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRequest;
    } });
    Object.defineProperty(exports2, "InlayHintResolveRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintResolveRequest;
    } });
    Object.defineProperty(exports2, "InlayHintRefreshRequest", { enumerable: true, get: function() {
      return protocol_inlayHint_1.InlayHintRefreshRequest;
    } });
    var protocol_diagnostic_1 = require_protocol_diagnostic();
    Object.defineProperty(exports2, "DiagnosticServerCancellationData", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticServerCancellationData;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticReportKind", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticReportKind;
    } });
    Object.defineProperty(exports2, "DocumentDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DocumentDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "WorkspaceDiagnosticRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.WorkspaceDiagnosticRequest;
    } });
    Object.defineProperty(exports2, "DiagnosticRefreshRequest", { enumerable: true, get: function() {
      return protocol_diagnostic_1.DiagnosticRefreshRequest;
    } });
    var protocol_notebook_1 = require_protocol_notebook();
    Object.defineProperty(exports2, "NotebookCellKind", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellKind;
    } });
    Object.defineProperty(exports2, "ExecutionSummary", { enumerable: true, get: function() {
      return protocol_notebook_1.ExecutionSummary;
    } });
    Object.defineProperty(exports2, "NotebookCell", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCell;
    } });
    Object.defineProperty(exports2, "NotebookDocument", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocument;
    } });
    Object.defineProperty(exports2, "NotebookDocumentSyncRegistrationType", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookDocumentSyncRegistrationType;
    } });
    Object.defineProperty(exports2, "DidOpenNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidOpenNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "NotebookCellArrayChange", { enumerable: true, get: function() {
      return protocol_notebook_1.NotebookCellArrayChange;
    } });
    Object.defineProperty(exports2, "DidChangeNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidChangeNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidSaveNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidSaveNotebookDocumentNotification;
    } });
    Object.defineProperty(exports2, "DidCloseNotebookDocumentNotification", { enumerable: true, get: function() {
      return protocol_notebook_1.DidCloseNotebookDocumentNotification;
    } });
    var TextDocumentFilter;
    (function(TextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.string(candidate.language) || Is.string(candidate.scheme) || Is.string(candidate.pattern);
      }
      TextDocumentFilter2.is = is;
    })(TextDocumentFilter = exports2.TextDocumentFilter || (exports2.TextDocumentFilter = {}));
    var NotebookDocumentFilter;
    (function(NotebookDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebookType) || Is.string(candidate.scheme) || Is.string(candidate.pattern));
      }
      NotebookDocumentFilter2.is = is;
    })(NotebookDocumentFilter = exports2.NotebookDocumentFilter || (exports2.NotebookDocumentFilter = {}));
    var NotebookCellTextDocumentFilter;
    (function(NotebookCellTextDocumentFilter2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (Is.string(candidate.notebook) || NotebookDocumentFilter.is(candidate.notebook)) && (candidate.language === void 0 || Is.string(candidate.language));
      }
      NotebookCellTextDocumentFilter2.is = is;
    })(NotebookCellTextDocumentFilter = exports2.NotebookCellTextDocumentFilter || (exports2.NotebookCellTextDocumentFilter = {}));
    var DocumentSelector;
    (function(DocumentSelector2) {
      function is(value) {
        if (!Array.isArray(value)) {
          return false;
        }
        for (let elem of value) {
          if (!Is.string(elem) && !TextDocumentFilter.is(elem) && !NotebookCellTextDocumentFilter.is(elem)) {
            return false;
          }
        }
        return true;
      }
      DocumentSelector2.is = is;
    })(DocumentSelector = exports2.DocumentSelector || (exports2.DocumentSelector = {}));
    var RegistrationRequest;
    (function(RegistrationRequest2) {
      RegistrationRequest2.type = new messages_1.ProtocolRequestType("client/registerCapability");
    })(RegistrationRequest = exports2.RegistrationRequest || (exports2.RegistrationRequest = {}));
    var UnregistrationRequest;
    (function(UnregistrationRequest2) {
      UnregistrationRequest2.type = new messages_1.ProtocolRequestType("client/unregisterCapability");
    })(UnregistrationRequest = exports2.UnregistrationRequest || (exports2.UnregistrationRequest = {}));
    var ResourceOperationKind;
    (function(ResourceOperationKind2) {
      ResourceOperationKind2.Create = "create";
      ResourceOperationKind2.Rename = "rename";
      ResourceOperationKind2.Delete = "delete";
    })(ResourceOperationKind = exports2.ResourceOperationKind || (exports2.ResourceOperationKind = {}));
    var FailureHandlingKind;
    (function(FailureHandlingKind2) {
      FailureHandlingKind2.Abort = "abort";
      FailureHandlingKind2.Transactional = "transactional";
      FailureHandlingKind2.TextOnlyTransactional = "textOnlyTransactional";
      FailureHandlingKind2.Undo = "undo";
    })(FailureHandlingKind = exports2.FailureHandlingKind || (exports2.FailureHandlingKind = {}));
    var PositionEncodingKind;
    (function(PositionEncodingKind2) {
      PositionEncodingKind2.UTF8 = "utf-8";
      PositionEncodingKind2.UTF16 = "utf-16";
      PositionEncodingKind2.UTF32 = "utf-32";
    })(PositionEncodingKind = exports2.PositionEncodingKind || (exports2.PositionEncodingKind = {}));
    var StaticRegistrationOptions;
    (function(StaticRegistrationOptions2) {
      function hasId(value) {
        const candidate = value;
        return candidate && Is.string(candidate.id) && candidate.id.length > 0;
      }
      StaticRegistrationOptions2.hasId = hasId;
    })(StaticRegistrationOptions = exports2.StaticRegistrationOptions || (exports2.StaticRegistrationOptions = {}));
    var TextDocumentRegistrationOptions;
    (function(TextDocumentRegistrationOptions2) {
      function is(value) {
        const candidate = value;
        return candidate && (candidate.documentSelector === null || DocumentSelector.is(candidate.documentSelector));
      }
      TextDocumentRegistrationOptions2.is = is;
    })(TextDocumentRegistrationOptions = exports2.TextDocumentRegistrationOptions || (exports2.TextDocumentRegistrationOptions = {}));
    var WorkDoneProgressOptions;
    (function(WorkDoneProgressOptions2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.workDoneProgress === void 0 || Is.boolean(candidate.workDoneProgress));
      }
      WorkDoneProgressOptions2.is = is;
      function hasWorkDoneProgress(value) {
        const candidate = value;
        return candidate && Is.boolean(candidate.workDoneProgress);
      }
      WorkDoneProgressOptions2.hasWorkDoneProgress = hasWorkDoneProgress;
    })(WorkDoneProgressOptions = exports2.WorkDoneProgressOptions || (exports2.WorkDoneProgressOptions = {}));
    var InitializeRequest;
    (function(InitializeRequest2) {
      InitializeRequest2.type = new messages_1.ProtocolRequestType("initialize");
    })(InitializeRequest = exports2.InitializeRequest || (exports2.InitializeRequest = {}));
    var InitializeErrorCodes;
    (function(InitializeErrorCodes2) {
      InitializeErrorCodes2.unknownProtocolVersion = 1;
    })(InitializeErrorCodes = exports2.InitializeErrorCodes || (exports2.InitializeErrorCodes = {}));
    var InitializedNotification;
    (function(InitializedNotification2) {
      InitializedNotification2.type = new messages_1.ProtocolNotificationType("initialized");
    })(InitializedNotification = exports2.InitializedNotification || (exports2.InitializedNotification = {}));
    var ShutdownRequest;
    (function(ShutdownRequest2) {
      ShutdownRequest2.type = new messages_1.ProtocolRequestType0("shutdown");
    })(ShutdownRequest = exports2.ShutdownRequest || (exports2.ShutdownRequest = {}));
    var ExitNotification;
    (function(ExitNotification2) {
      ExitNotification2.type = new messages_1.ProtocolNotificationType0("exit");
    })(ExitNotification = exports2.ExitNotification || (exports2.ExitNotification = {}));
    var DidChangeConfigurationNotification;
    (function(DidChangeConfigurationNotification2) {
      DidChangeConfigurationNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeConfiguration");
    })(DidChangeConfigurationNotification = exports2.DidChangeConfigurationNotification || (exports2.DidChangeConfigurationNotification = {}));
    var MessageType;
    (function(MessageType2) {
      MessageType2.Error = 1;
      MessageType2.Warning = 2;
      MessageType2.Info = 3;
      MessageType2.Log = 4;
    })(MessageType = exports2.MessageType || (exports2.MessageType = {}));
    var ShowMessageNotification;
    (function(ShowMessageNotification2) {
      ShowMessageNotification2.type = new messages_1.ProtocolNotificationType("window/showMessage");
    })(ShowMessageNotification = exports2.ShowMessageNotification || (exports2.ShowMessageNotification = {}));
    var ShowMessageRequest;
    (function(ShowMessageRequest2) {
      ShowMessageRequest2.type = new messages_1.ProtocolRequestType("window/showMessageRequest");
    })(ShowMessageRequest = exports2.ShowMessageRequest || (exports2.ShowMessageRequest = {}));
    var LogMessageNotification;
    (function(LogMessageNotification2) {
      LogMessageNotification2.type = new messages_1.ProtocolNotificationType("window/logMessage");
    })(LogMessageNotification = exports2.LogMessageNotification || (exports2.LogMessageNotification = {}));
    var TelemetryEventNotification;
    (function(TelemetryEventNotification2) {
      TelemetryEventNotification2.type = new messages_1.ProtocolNotificationType("telemetry/event");
    })(TelemetryEventNotification = exports2.TelemetryEventNotification || (exports2.TelemetryEventNotification = {}));
    var TextDocumentSyncKind;
    (function(TextDocumentSyncKind2) {
      TextDocumentSyncKind2.None = 0;
      TextDocumentSyncKind2.Full = 1;
      TextDocumentSyncKind2.Incremental = 2;
    })(TextDocumentSyncKind = exports2.TextDocumentSyncKind || (exports2.TextDocumentSyncKind = {}));
    var DidOpenTextDocumentNotification;
    (function(DidOpenTextDocumentNotification2) {
      DidOpenTextDocumentNotification2.method = "textDocument/didOpen";
      DidOpenTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidOpenTextDocumentNotification2.method);
    })(DidOpenTextDocumentNotification = exports2.DidOpenTextDocumentNotification || (exports2.DidOpenTextDocumentNotification = {}));
    var TextDocumentContentChangeEvent;
    (function(TextDocumentContentChangeEvent2) {
      function isIncremental(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
      }
      TextDocumentContentChangeEvent2.isIncremental = isIncremental;
      function isFull(event) {
        let candidate = event;
        return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
      }
      TextDocumentContentChangeEvent2.isFull = isFull;
    })(TextDocumentContentChangeEvent = exports2.TextDocumentContentChangeEvent || (exports2.TextDocumentContentChangeEvent = {}));
    var DidChangeTextDocumentNotification;
    (function(DidChangeTextDocumentNotification2) {
      DidChangeTextDocumentNotification2.method = "textDocument/didChange";
      DidChangeTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidChangeTextDocumentNotification2.method);
    })(DidChangeTextDocumentNotification = exports2.DidChangeTextDocumentNotification || (exports2.DidChangeTextDocumentNotification = {}));
    var DidCloseTextDocumentNotification;
    (function(DidCloseTextDocumentNotification2) {
      DidCloseTextDocumentNotification2.method = "textDocument/didClose";
      DidCloseTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidCloseTextDocumentNotification2.method);
    })(DidCloseTextDocumentNotification = exports2.DidCloseTextDocumentNotification || (exports2.DidCloseTextDocumentNotification = {}));
    var DidSaveTextDocumentNotification;
    (function(DidSaveTextDocumentNotification2) {
      DidSaveTextDocumentNotification2.method = "textDocument/didSave";
      DidSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(DidSaveTextDocumentNotification2.method);
    })(DidSaveTextDocumentNotification = exports2.DidSaveTextDocumentNotification || (exports2.DidSaveTextDocumentNotification = {}));
    var TextDocumentSaveReason;
    (function(TextDocumentSaveReason2) {
      TextDocumentSaveReason2.Manual = 1;
      TextDocumentSaveReason2.AfterDelay = 2;
      TextDocumentSaveReason2.FocusOut = 3;
    })(TextDocumentSaveReason = exports2.TextDocumentSaveReason || (exports2.TextDocumentSaveReason = {}));
    var WillSaveTextDocumentNotification;
    (function(WillSaveTextDocumentNotification2) {
      WillSaveTextDocumentNotification2.method = "textDocument/willSave";
      WillSaveTextDocumentNotification2.type = new messages_1.ProtocolNotificationType(WillSaveTextDocumentNotification2.method);
    })(WillSaveTextDocumentNotification = exports2.WillSaveTextDocumentNotification || (exports2.WillSaveTextDocumentNotification = {}));
    var WillSaveTextDocumentWaitUntilRequest;
    (function(WillSaveTextDocumentWaitUntilRequest2) {
      WillSaveTextDocumentWaitUntilRequest2.method = "textDocument/willSaveWaitUntil";
      WillSaveTextDocumentWaitUntilRequest2.type = new messages_1.ProtocolRequestType(WillSaveTextDocumentWaitUntilRequest2.method);
    })(WillSaveTextDocumentWaitUntilRequest = exports2.WillSaveTextDocumentWaitUntilRequest || (exports2.WillSaveTextDocumentWaitUntilRequest = {}));
    var DidChangeWatchedFilesNotification;
    (function(DidChangeWatchedFilesNotification2) {
      DidChangeWatchedFilesNotification2.type = new messages_1.ProtocolNotificationType("workspace/didChangeWatchedFiles");
    })(DidChangeWatchedFilesNotification = exports2.DidChangeWatchedFilesNotification || (exports2.DidChangeWatchedFilesNotification = {}));
    var FileChangeType;
    (function(FileChangeType2) {
      FileChangeType2.Created = 1;
      FileChangeType2.Changed = 2;
      FileChangeType2.Deleted = 3;
    })(FileChangeType = exports2.FileChangeType || (exports2.FileChangeType = {}));
    var RelativePattern;
    (function(RelativePattern2) {
      function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (vscode_languageserver_types_1.URI.is(candidate.baseUri) || vscode_languageserver_types_1.WorkspaceFolder.is(candidate.baseUri)) && Is.string(candidate.pattern);
      }
      RelativePattern2.is = is;
    })(RelativePattern = exports2.RelativePattern || (exports2.RelativePattern = {}));
    var WatchKind;
    (function(WatchKind2) {
      WatchKind2.Create = 1;
      WatchKind2.Change = 2;
      WatchKind2.Delete = 4;
    })(WatchKind = exports2.WatchKind || (exports2.WatchKind = {}));
    var PublishDiagnosticsNotification;
    (function(PublishDiagnosticsNotification2) {
      PublishDiagnosticsNotification2.type = new messages_1.ProtocolNotificationType("textDocument/publishDiagnostics");
    })(PublishDiagnosticsNotification = exports2.PublishDiagnosticsNotification || (exports2.PublishDiagnosticsNotification = {}));
    var CompletionTriggerKind;
    (function(CompletionTriggerKind2) {
      CompletionTriggerKind2.Invoked = 1;
      CompletionTriggerKind2.TriggerCharacter = 2;
      CompletionTriggerKind2.TriggerForIncompleteCompletions = 3;
    })(CompletionTriggerKind = exports2.CompletionTriggerKind || (exports2.CompletionTriggerKind = {}));
    var CompletionRequest;
    (function(CompletionRequest2) {
      CompletionRequest2.method = "textDocument/completion";
      CompletionRequest2.type = new messages_1.ProtocolRequestType(CompletionRequest2.method);
    })(CompletionRequest = exports2.CompletionRequest || (exports2.CompletionRequest = {}));
    var CompletionResolveRequest;
    (function(CompletionResolveRequest2) {
      CompletionResolveRequest2.method = "completionItem/resolve";
      CompletionResolveRequest2.type = new messages_1.ProtocolRequestType(CompletionResolveRequest2.method);
    })(CompletionResolveRequest = exports2.CompletionResolveRequest || (exports2.CompletionResolveRequest = {}));
    var HoverRequest;
    (function(HoverRequest2) {
      HoverRequest2.method = "textDocument/hover";
      HoverRequest2.type = new messages_1.ProtocolRequestType(HoverRequest2.method);
    })(HoverRequest = exports2.HoverRequest || (exports2.HoverRequest = {}));
    var SignatureHelpTriggerKind;
    (function(SignatureHelpTriggerKind2) {
      SignatureHelpTriggerKind2.Invoked = 1;
      SignatureHelpTriggerKind2.TriggerCharacter = 2;
      SignatureHelpTriggerKind2.ContentChange = 3;
    })(SignatureHelpTriggerKind = exports2.SignatureHelpTriggerKind || (exports2.SignatureHelpTriggerKind = {}));
    var SignatureHelpRequest;
    (function(SignatureHelpRequest2) {
      SignatureHelpRequest2.method = "textDocument/signatureHelp";
      SignatureHelpRequest2.type = new messages_1.ProtocolRequestType(SignatureHelpRequest2.method);
    })(SignatureHelpRequest = exports2.SignatureHelpRequest || (exports2.SignatureHelpRequest = {}));
    var DefinitionRequest;
    (function(DefinitionRequest2) {
      DefinitionRequest2.method = "textDocument/definition";
      DefinitionRequest2.type = new messages_1.ProtocolRequestType(DefinitionRequest2.method);
    })(DefinitionRequest = exports2.DefinitionRequest || (exports2.DefinitionRequest = {}));
    var ReferencesRequest;
    (function(ReferencesRequest2) {
      ReferencesRequest2.method = "textDocument/references";
      ReferencesRequest2.type = new messages_1.ProtocolRequestType(ReferencesRequest2.method);
    })(ReferencesRequest = exports2.ReferencesRequest || (exports2.ReferencesRequest = {}));
    var DocumentHighlightRequest;
    (function(DocumentHighlightRequest2) {
      DocumentHighlightRequest2.method = "textDocument/documentHighlight";
      DocumentHighlightRequest2.type = new messages_1.ProtocolRequestType(DocumentHighlightRequest2.method);
    })(DocumentHighlightRequest = exports2.DocumentHighlightRequest || (exports2.DocumentHighlightRequest = {}));
    var DocumentSymbolRequest;
    (function(DocumentSymbolRequest2) {
      DocumentSymbolRequest2.method = "textDocument/documentSymbol";
      DocumentSymbolRequest2.type = new messages_1.ProtocolRequestType(DocumentSymbolRequest2.method);
    })(DocumentSymbolRequest = exports2.DocumentSymbolRequest || (exports2.DocumentSymbolRequest = {}));
    var CodeActionRequest;
    (function(CodeActionRequest2) {
      CodeActionRequest2.method = "textDocument/codeAction";
      CodeActionRequest2.type = new messages_1.ProtocolRequestType(CodeActionRequest2.method);
    })(CodeActionRequest = exports2.CodeActionRequest || (exports2.CodeActionRequest = {}));
    var CodeActionResolveRequest;
    (function(CodeActionResolveRequest2) {
      CodeActionResolveRequest2.method = "codeAction/resolve";
      CodeActionResolveRequest2.type = new messages_1.ProtocolRequestType(CodeActionResolveRequest2.method);
    })(CodeActionResolveRequest = exports2.CodeActionResolveRequest || (exports2.CodeActionResolveRequest = {}));
    var WorkspaceSymbolRequest;
    (function(WorkspaceSymbolRequest2) {
      WorkspaceSymbolRequest2.method = "workspace/symbol";
      WorkspaceSymbolRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolRequest2.method);
    })(WorkspaceSymbolRequest = exports2.WorkspaceSymbolRequest || (exports2.WorkspaceSymbolRequest = {}));
    var WorkspaceSymbolResolveRequest;
    (function(WorkspaceSymbolResolveRequest2) {
      WorkspaceSymbolResolveRequest2.method = "workspaceSymbol/resolve";
      WorkspaceSymbolResolveRequest2.type = new messages_1.ProtocolRequestType(WorkspaceSymbolResolveRequest2.method);
    })(WorkspaceSymbolResolveRequest = exports2.WorkspaceSymbolResolveRequest || (exports2.WorkspaceSymbolResolveRequest = {}));
    var CodeLensRequest;
    (function(CodeLensRequest2) {
      CodeLensRequest2.method = "textDocument/codeLens";
      CodeLensRequest2.type = new messages_1.ProtocolRequestType(CodeLensRequest2.method);
    })(CodeLensRequest = exports2.CodeLensRequest || (exports2.CodeLensRequest = {}));
    var CodeLensResolveRequest;
    (function(CodeLensResolveRequest2) {
      CodeLensResolveRequest2.method = "codeLens/resolve";
      CodeLensResolveRequest2.type = new messages_1.ProtocolRequestType(CodeLensResolveRequest2.method);
    })(CodeLensResolveRequest = exports2.CodeLensResolveRequest || (exports2.CodeLensResolveRequest = {}));
    var CodeLensRefreshRequest;
    (function(CodeLensRefreshRequest2) {
      CodeLensRefreshRequest2.method = `workspace/codeLens/refresh`;
      CodeLensRefreshRequest2.type = new messages_1.ProtocolRequestType0(CodeLensRefreshRequest2.method);
    })(CodeLensRefreshRequest = exports2.CodeLensRefreshRequest || (exports2.CodeLensRefreshRequest = {}));
    var DocumentLinkRequest;
    (function(DocumentLinkRequest2) {
      DocumentLinkRequest2.method = "textDocument/documentLink";
      DocumentLinkRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkRequest2.method);
    })(DocumentLinkRequest = exports2.DocumentLinkRequest || (exports2.DocumentLinkRequest = {}));
    var DocumentLinkResolveRequest;
    (function(DocumentLinkResolveRequest2) {
      DocumentLinkResolveRequest2.method = "documentLink/resolve";
      DocumentLinkResolveRequest2.type = new messages_1.ProtocolRequestType(DocumentLinkResolveRequest2.method);
    })(DocumentLinkResolveRequest = exports2.DocumentLinkResolveRequest || (exports2.DocumentLinkResolveRequest = {}));
    var DocumentFormattingRequest;
    (function(DocumentFormattingRequest2) {
      DocumentFormattingRequest2.method = "textDocument/formatting";
      DocumentFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentFormattingRequest2.method);
    })(DocumentFormattingRequest = exports2.DocumentFormattingRequest || (exports2.DocumentFormattingRequest = {}));
    var DocumentRangeFormattingRequest;
    (function(DocumentRangeFormattingRequest2) {
      DocumentRangeFormattingRequest2.method = "textDocument/rangeFormatting";
      DocumentRangeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentRangeFormattingRequest2.method);
    })(DocumentRangeFormattingRequest = exports2.DocumentRangeFormattingRequest || (exports2.DocumentRangeFormattingRequest = {}));
    var DocumentOnTypeFormattingRequest;
    (function(DocumentOnTypeFormattingRequest2) {
      DocumentOnTypeFormattingRequest2.method = "textDocument/onTypeFormatting";
      DocumentOnTypeFormattingRequest2.type = new messages_1.ProtocolRequestType(DocumentOnTypeFormattingRequest2.method);
    })(DocumentOnTypeFormattingRequest = exports2.DocumentOnTypeFormattingRequest || (exports2.DocumentOnTypeFormattingRequest = {}));
    var PrepareSupportDefaultBehavior;
    (function(PrepareSupportDefaultBehavior2) {
      PrepareSupportDefaultBehavior2.Identifier = 1;
    })(PrepareSupportDefaultBehavior = exports2.PrepareSupportDefaultBehavior || (exports2.PrepareSupportDefaultBehavior = {}));
    var RenameRequest;
    (function(RenameRequest2) {
      RenameRequest2.method = "textDocument/rename";
      RenameRequest2.type = new messages_1.ProtocolRequestType(RenameRequest2.method);
    })(RenameRequest = exports2.RenameRequest || (exports2.RenameRequest = {}));
    var PrepareRenameRequest;
    (function(PrepareRenameRequest2) {
      PrepareRenameRequest2.method = "textDocument/prepareRename";
      PrepareRenameRequest2.type = new messages_1.ProtocolRequestType(PrepareRenameRequest2.method);
    })(PrepareRenameRequest = exports2.PrepareRenameRequest || (exports2.PrepareRenameRequest = {}));
    var ExecuteCommandRequest;
    (function(ExecuteCommandRequest2) {
      ExecuteCommandRequest2.type = new messages_1.ProtocolRequestType("workspace/executeCommand");
    })(ExecuteCommandRequest = exports2.ExecuteCommandRequest || (exports2.ExecuteCommandRequest = {}));
    var ApplyWorkspaceEditRequest;
    (function(ApplyWorkspaceEditRequest2) {
      ApplyWorkspaceEditRequest2.type = new messages_1.ProtocolRequestType("workspace/applyEdit");
    })(ApplyWorkspaceEditRequest = exports2.ApplyWorkspaceEditRequest || (exports2.ApplyWorkspaceEditRequest = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/connection.js
var require_connection2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/connection.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var vscode_jsonrpc_1 = require_main();
    function createProtocolConnection(input, output, logger, options) {
      if (vscode_jsonrpc_1.ConnectionStrategy.is(options)) {
        options = { connectionStrategy: options };
      }
      return (0, vscode_jsonrpc_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver-protocol/lib/common/api.js
var require_api2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LSPErrorCodes = exports2.createProtocolConnection = void 0;
    __exportStar(require_main(), exports2);
    __exportStar(require_main2(), exports2);
    __exportStar(require_messages2(), exports2);
    __exportStar(require_protocol(), exports2);
    var connection_1 = require_connection2();
    Object.defineProperty(exports2, "createProtocolConnection", { enumerable: true, get: function() {
      return connection_1.createProtocolConnection;
    } });
    var LSPErrorCodes;
    (function(LSPErrorCodes2) {
      LSPErrorCodes2.lspReservedErrorRangeStart = -32899;
      LSPErrorCodes2.RequestFailed = -32803;
      LSPErrorCodes2.ServerCancelled = -32802;
      LSPErrorCodes2.ContentModified = -32801;
      LSPErrorCodes2.RequestCancelled = -32800;
      LSPErrorCodes2.lspReservedErrorRangeEnd = -32800;
    })(LSPErrorCodes = exports2.LSPErrorCodes || (exports2.LSPErrorCodes = {}));
  }
});

// node_modules/vscode-languageserver-protocol/lib/node/main.js
var require_main3 = __commonJS({
  "node_modules/vscode-languageserver-protocol/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createProtocolConnection = void 0;
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    __exportStar(require_api2(), exports2);
    function createProtocolConnection(input, output, logger, options) {
      return (0, node_1.createMessageConnection)(input, output, logger, options);
    }
    exports2.createProtocolConnection = createProtocolConnection;
  }
});

// node_modules/vscode-languageserver/lib/common/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/vscode-languageserver/lib/common/utils/uuid.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generateUuid = exports2.parse = exports2.isUUID = exports2.v4 = exports2.empty = void 0;
    var ValueUUID = class {
      constructor(_value) {
        this._value = _value;
      }
      asHex() {
        return this._value;
      }
      equals(other) {
        return this.asHex() === other.asHex();
      }
    };
    var V4UUID = class extends ValueUUID {
      constructor() {
        super([
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          "4",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._oneOf(V4UUID._timeHighBits),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          "-",
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex(),
          V4UUID._randomHex()
        ].join(""));
      }
      static _oneOf(array) {
        return array[Math.floor(array.length * Math.random())];
      }
      static _randomHex() {
        return V4UUID._oneOf(V4UUID._chars);
      }
    };
    V4UUID._chars = ["0", "1", "2", "3", "4", "5", "6", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    V4UUID._timeHighBits = ["8", "9", "a", "b"];
    exports2.empty = new ValueUUID("00000000-0000-0000-0000-000000000000");
    function v4() {
      return new V4UUID();
    }
    exports2.v4 = v4;
    var _UUIDPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    function isUUID(value) {
      return _UUIDPattern.test(value);
    }
    exports2.isUUID = isUUID;
    function parse(value) {
      if (!isUUID(value)) {
        throw new Error("invalid uuid");
      }
      return new ValueUUID(value);
    }
    exports2.parse = parse;
    function generateUuid() {
      return v4().asHex();
    }
    exports2.generateUuid = generateUuid;
  }
});

// node_modules/vscode-languageserver/lib/common/progress.js
var require_progress = __commonJS({
  "node_modules/vscode-languageserver/lib/common/progress.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attachPartialResult = exports2.ProgressFeature = exports2.attachWorkDone = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var uuid_1 = require_uuid();
    var WorkDoneProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
        WorkDoneProgressReporterImpl.Instances.set(this._token, this);
      }
      begin(title, percentage, message, cancellable) {
        let param = {
          kind: "begin",
          title,
          percentage,
          message,
          cancellable
        };
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      report(arg0, arg1) {
        let param = {
          kind: "report"
        };
        if (typeof arg0 === "number") {
          param.percentage = arg0;
          if (arg1 !== void 0) {
            param.message = arg1;
          }
        } else {
          param.message = arg0;
        }
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, param);
      }
      done() {
        WorkDoneProgressReporterImpl.Instances.delete(this._token);
        this._connection.sendProgress(vscode_languageserver_protocol_1.WorkDoneProgress.type, this._token, { kind: "end" });
      }
    };
    WorkDoneProgressReporterImpl.Instances = /* @__PURE__ */ new Map();
    var WorkDoneProgressServerReporterImpl = class extends WorkDoneProgressReporterImpl {
      constructor(connection, token) {
        super(connection, token);
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
        super.done();
      }
      cancel() {
        this._source.cancel();
      }
    };
    var NullProgressReporter = class {
      constructor() {
      }
      begin() {
      }
      report() {
      }
      done() {
      }
    };
    var NullProgressServerReporter = class extends NullProgressReporter {
      constructor() {
        super();
        this._source = new vscode_languageserver_protocol_1.CancellationTokenSource();
      }
      get token() {
        return this._source.token;
      }
      done() {
        this._source.dispose();
      }
      cancel() {
        this._source.cancel();
      }
    };
    function attachWorkDone(connection, params) {
      if (params === void 0 || params.workDoneToken === void 0) {
        return new NullProgressReporter();
      }
      const token = params.workDoneToken;
      delete params.workDoneToken;
      return new WorkDoneProgressReporterImpl(connection, token);
    }
    exports2.attachWorkDone = attachWorkDone;
    var ProgressFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._progressSupported = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          if (capabilities?.window?.workDoneProgress === true) {
            this._progressSupported = true;
            this.connection.onNotification(vscode_languageserver_protocol_1.WorkDoneProgressCancelNotification.type, (params) => {
              let progress = WorkDoneProgressReporterImpl.Instances.get(params.token);
              if (progress instanceof WorkDoneProgressServerReporterImpl || progress instanceof NullProgressServerReporter) {
                progress.cancel();
              }
            });
          }
        }
        attachWorkDoneProgress(token) {
          if (token === void 0) {
            return new NullProgressReporter();
          } else {
            return new WorkDoneProgressReporterImpl(this.connection, token);
          }
        }
        createWorkDoneProgress() {
          if (this._progressSupported) {
            const token = (0, uuid_1.generateUuid)();
            return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkDoneProgressCreateRequest.type, { token }).then(() => {
              const result = new WorkDoneProgressServerReporterImpl(this.connection, token);
              return result;
            });
          } else {
            return Promise.resolve(new NullProgressServerReporter());
          }
        }
      };
    };
    exports2.ProgressFeature = ProgressFeature;
    var ResultProgress;
    (function(ResultProgress2) {
      ResultProgress2.type = new vscode_languageserver_protocol_1.ProgressType();
    })(ResultProgress || (ResultProgress = {}));
    var ResultProgressReporterImpl = class {
      constructor(_connection, _token) {
        this._connection = _connection;
        this._token = _token;
      }
      report(data) {
        this._connection.sendProgress(ResultProgress.type, this._token, data);
      }
    };
    function attachPartialResult(connection, params) {
      if (params === void 0 || params.partialResultToken === void 0) {
        return void 0;
      }
      const token = params.partialResultToken;
      delete params.partialResultToken;
      return new ResultProgressReporterImpl(connection, token);
    }
    exports2.attachPartialResult = attachPartialResult;
  }
});

// node_modules/vscode-languageserver/lib/common/configuration.js
var require_configuration = __commonJS({
  "node_modules/vscode-languageserver/lib/common/configuration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ConfigurationFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var ConfigurationFeature = (Base) => {
      return class extends Base {
        getConfiguration(arg) {
          if (!arg) {
            return this._getConfiguration({});
          } else if (Is.string(arg)) {
            return this._getConfiguration({ section: arg });
          } else {
            return this._getConfiguration(arg);
          }
        }
        _getConfiguration(arg) {
          let params = {
            items: Array.isArray(arg) ? arg : [arg]
          };
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ConfigurationRequest.type, params).then((result) => {
            if (Array.isArray(result)) {
              return Array.isArray(arg) ? result : result[0];
            } else {
              return Array.isArray(arg) ? [] : null;
            }
          });
        }
      };
    };
    exports2.ConfigurationFeature = ConfigurationFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/workspaceFolder.js
var require_workspaceFolder = __commonJS({
  "node_modules/vscode-languageserver/lib/common/workspaceFolder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkspaceFoldersFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var WorkspaceFoldersFeature = (Base) => {
      return class extends Base {
        constructor() {
          super();
          this._notificationIsAutoRegistered = false;
        }
        initialize(capabilities) {
          super.initialize(capabilities);
          let workspaceCapabilities = capabilities.workspace;
          if (workspaceCapabilities && workspaceCapabilities.workspaceFolders) {
            this._onDidChangeWorkspaceFolders = new vscode_languageserver_protocol_1.Emitter();
            this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type, (params) => {
              this._onDidChangeWorkspaceFolders.fire(params.event);
            });
          }
        }
        fillServerCapabilities(capabilities) {
          super.fillServerCapabilities(capabilities);
          const changeNotifications = capabilities.workspace?.workspaceFolders?.changeNotifications;
          this._notificationIsAutoRegistered = changeNotifications === true || typeof changeNotifications === "string";
        }
        getWorkspaceFolders() {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.WorkspaceFoldersRequest.type);
        }
        get onDidChangeWorkspaceFolders() {
          if (!this._onDidChangeWorkspaceFolders) {
            throw new Error("Client doesn't support sending workspace folder change events.");
          }
          if (!this._notificationIsAutoRegistered && !this._unregistration) {
            this._unregistration = this.connection.client.register(vscode_languageserver_protocol_1.DidChangeWorkspaceFoldersNotification.type);
          }
          return this._onDidChangeWorkspaceFolders.event;
        }
      };
    };
    exports2.WorkspaceFoldersFeature = WorkspaceFoldersFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/callHierarchy.js
var require_callHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/callHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CallHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var CallHierarchyFeature = (Base) => {
      return class extends Base {
        get callHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.CallHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onIncomingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyIncomingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onOutgoingCalls: (handler) => {
              const type = vscode_languageserver_protocol_1.CallHierarchyOutgoingCallsRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.CallHierarchyFeature = CallHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/semanticTokens.js
var require_semanticTokens = __commonJS({
  "node_modules/vscode-languageserver/lib/common/semanticTokens.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SemanticTokensBuilder = exports2.SemanticTokensDiff = exports2.SemanticTokensFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var SemanticTokensFeature = (Base) => {
      return class extends Base {
        get semanticTokens() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.SemanticTokensRefreshRequest.type);
            },
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onDelta: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensDeltaRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onRange: (handler) => {
              const type = vscode_languageserver_protocol_1.SemanticTokensRangeRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.SemanticTokensFeature = SemanticTokensFeature;
    var SemanticTokensDiff = class {
      constructor(originalSequence, modifiedSequence) {
        this.originalSequence = originalSequence;
        this.modifiedSequence = modifiedSequence;
      }
      computeDiff() {
        const originalLength = this.originalSequence.length;
        const modifiedLength = this.modifiedSequence.length;
        let startIndex = 0;
        while (startIndex < modifiedLength && startIndex < originalLength && this.originalSequence[startIndex] === this.modifiedSequence[startIndex]) {
          startIndex++;
        }
        if (startIndex < modifiedLength && startIndex < originalLength) {
          let originalEndIndex = originalLength - 1;
          let modifiedEndIndex = modifiedLength - 1;
          while (originalEndIndex >= startIndex && modifiedEndIndex >= startIndex && this.originalSequence[originalEndIndex] === this.modifiedSequence[modifiedEndIndex]) {
            originalEndIndex--;
            modifiedEndIndex--;
          }
          if (originalEndIndex < startIndex || modifiedEndIndex < startIndex) {
            originalEndIndex++;
            modifiedEndIndex++;
          }
          const deleteCount = originalEndIndex - startIndex + 1;
          const newData = this.modifiedSequence.slice(startIndex, modifiedEndIndex + 1);
          if (newData.length === 1 && newData[0] === this.originalSequence[originalEndIndex]) {
            return [
              { start: startIndex, deleteCount: deleteCount - 1 }
            ];
          } else {
            return [
              { start: startIndex, deleteCount, data: newData }
            ];
          }
        } else if (startIndex < modifiedLength) {
          return [
            { start: startIndex, deleteCount: 0, data: this.modifiedSequence.slice(startIndex) }
          ];
        } else if (startIndex < originalLength) {
          return [
            { start: startIndex, deleteCount: originalLength - startIndex }
          ];
        } else {
          return [];
        }
      }
    };
    exports2.SemanticTokensDiff = SemanticTokensDiff;
    var SemanticTokensBuilder = class {
      constructor() {
        this._prevData = void 0;
        this.initialize();
      }
      initialize() {
        this._id = Date.now();
        this._prevLine = 0;
        this._prevChar = 0;
        this._data = [];
        this._dataLen = 0;
      }
      push(line, char, length, tokenType, tokenModifiers) {
        let pushLine = line;
        let pushChar = char;
        if (this._dataLen > 0) {
          pushLine -= this._prevLine;
          if (pushLine === 0) {
            pushChar -= this._prevChar;
          }
        }
        this._data[this._dataLen++] = pushLine;
        this._data[this._dataLen++] = pushChar;
        this._data[this._dataLen++] = length;
        this._data[this._dataLen++] = tokenType;
        this._data[this._dataLen++] = tokenModifiers;
        this._prevLine = line;
        this._prevChar = char;
      }
      get id() {
        return this._id.toString();
      }
      previousResult(id) {
        if (this.id === id) {
          this._prevData = this._data;
        }
        this.initialize();
      }
      build() {
        this._prevData = void 0;
        return {
          resultId: this.id,
          data: this._data
        };
      }
      canBuildEdits() {
        return this._prevData !== void 0;
      }
      buildEdits() {
        if (this._prevData !== void 0) {
          return {
            resultId: this.id,
            edits: new SemanticTokensDiff(this._prevData, this._data).computeDiff()
          };
        } else {
          return this.build();
        }
      }
    };
    exports2.SemanticTokensBuilder = SemanticTokensBuilder;
  }
});

// node_modules/vscode-languageserver/lib/common/showDocument.js
var require_showDocument = __commonJS({
  "node_modules/vscode-languageserver/lib/common/showDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ShowDocumentFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var ShowDocumentFeature = (Base) => {
      return class extends Base {
        showDocument(params) {
          return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowDocumentRequest.type, params);
        }
      };
    };
    exports2.ShowDocumentFeature = ShowDocumentFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/fileOperations.js
var require_fileOperations = __commonJS({
  "node_modules/vscode-languageserver/lib/common/fileOperations.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileOperationsFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var FileOperationsFeature = (Base) => {
      return class extends Base {
        onDidCreateFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidCreateFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidRenameFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidRenameFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onDidDeleteFiles(handler) {
          return this.connection.onNotification(vscode_languageserver_protocol_1.DidDeleteFilesNotification.type, (params) => {
            handler(params);
          });
        }
        onWillCreateFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillCreateFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillRenameFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillRenameFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
        onWillDeleteFiles(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.WillDeleteFilesRequest.type, (params, cancel) => {
            return handler(params, cancel);
          });
        }
      };
    };
    exports2.FileOperationsFeature = FileOperationsFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/linkedEditingRange.js
var require_linkedEditingRange = __commonJS({
  "node_modules/vscode-languageserver/lib/common/linkedEditingRange.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LinkedEditingRangeFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var LinkedEditingRangeFeature = (Base) => {
      return class extends Base {
        onLinkedEditingRange(handler) {
          return this.connection.onRequest(vscode_languageserver_protocol_1.LinkedEditingRangeRequest.type, (params, cancel) => {
            return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
          });
        }
      };
    };
    exports2.LinkedEditingRangeFeature = LinkedEditingRangeFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/typeHierarchy.js
var require_typeHierarchy = __commonJS({
  "node_modules/vscode-languageserver/lib/common/typeHierarchy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeHierarchyFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TypeHierarchyFeature = (Base) => {
      return class extends Base {
        get typeHierarchy() {
          return {
            onPrepare: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.TypeHierarchyPrepareRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), void 0);
              });
            },
            onSupertypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySupertypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            },
            onSubtypes: (handler) => {
              const type = vscode_languageserver_protocol_1.TypeHierarchySubtypesRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.TypeHierarchyFeature = TypeHierarchyFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlineValue.js
var require_inlineValue = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlineValue.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlineValueFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlineValueFeature = (Base) => {
      return class extends Base {
        get inlineValue() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlineValueRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlineValueRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            }
          };
        }
      };
    };
    exports2.InlineValueFeature = InlineValueFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/inlayHint.js
var require_inlayHint = __commonJS({
  "node_modules/vscode-languageserver/lib/common/inlayHint.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.InlayHintFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var InlayHintFeature = (Base) => {
      return class extends Base {
        get inlayHint() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.InlayHintRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params));
              });
            },
            resolve: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.InlayHintResolveRequest.type, (params, cancel) => {
                return handler(params, cancel);
              });
            }
          };
        }
      };
    };
    exports2.InlayHintFeature = InlayHintFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/diagnostic.js
var require_diagnostic = __commonJS({
  "node_modules/vscode-languageserver/lib/common/diagnostic.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DiagnosticFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var DiagnosticFeature = (Base) => {
      return class extends Base {
        get diagnostics() {
          return {
            refresh: () => {
              return this.connection.sendRequest(vscode_languageserver_protocol_1.DiagnosticRefreshRequest.type);
            },
            on: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.DocumentDiagnosticRequest.partialResult, params));
              });
            },
            onWorkspace: (handler) => {
              return this.connection.onRequest(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(vscode_languageserver_protocol_1.WorkspaceDiagnosticRequest.partialResult, params));
              });
            }
          };
        }
      };
    };
    exports2.DiagnosticFeature = DiagnosticFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/textDocuments.js
var require_textDocuments = __commonJS({
  "node_modules/vscode-languageserver/lib/common/textDocuments.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TextDocuments = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var TextDocuments = class {
      constructor(configuration) {
        this._configuration = configuration;
        this._syncedDocuments = /* @__PURE__ */ new Map();
        this._onDidChangeContent = new vscode_languageserver_protocol_1.Emitter();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onWillSave = new vscode_languageserver_protocol_1.Emitter();
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidChangeContent() {
        return this._onDidChangeContent.event;
      }
      get onWillSave() {
        return this._onWillSave.event;
      }
      onWillSaveWaitUntil(handler) {
        this._willSaveWaitUntil = handler;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      get(uri) {
        return this._syncedDocuments.get(uri);
      }
      all() {
        return Array.from(this._syncedDocuments.values());
      }
      keys() {
        return Array.from(this._syncedDocuments.keys());
      }
      listen(connection) {
        connection.__textDocumentSync = vscode_languageserver_protocol_1.TextDocumentSyncKind.Incremental;
        const disposables = [];
        disposables.push(connection.onDidOpenTextDocument((event) => {
          const td = event.textDocument;
          const document = this._configuration.create(td.uri, td.languageId, td.version, td.text);
          this._syncedDocuments.set(td.uri, document);
          const toFire = Object.freeze({ document });
          this._onDidOpen.fire(toFire);
          this._onDidChangeContent.fire(toFire);
        }));
        disposables.push(connection.onDidChangeTextDocument((event) => {
          const td = event.textDocument;
          const changes = event.contentChanges;
          if (changes.length === 0) {
            return;
          }
          const { version } = td;
          if (version === null || version === void 0) {
            throw new Error(`Received document change event for ${td.uri} without valid version identifier`);
          }
          let syncedDocument = this._syncedDocuments.get(td.uri);
          if (syncedDocument !== void 0) {
            syncedDocument = this._configuration.update(syncedDocument, changes, version);
            this._syncedDocuments.set(td.uri, syncedDocument);
            this._onDidChangeContent.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onDidCloseTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._syncedDocuments.delete(event.textDocument.uri);
            this._onDidClose.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onWillSave.fire(Object.freeze({ document: syncedDocument, reason: event.reason }));
          }
        }));
        disposables.push(connection.onWillSaveTextDocumentWaitUntil((event, token) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0 && this._willSaveWaitUntil) {
            return this._willSaveWaitUntil(Object.freeze({ document: syncedDocument, reason: event.reason }), token);
          } else {
            return [];
          }
        }));
        disposables.push(connection.onDidSaveTextDocument((event) => {
          let syncedDocument = this._syncedDocuments.get(event.textDocument.uri);
          if (syncedDocument !== void 0) {
            this._onDidSave.fire(Object.freeze({ document: syncedDocument }));
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
    };
    exports2.TextDocuments = TextDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/notebook.js
var require_notebook = __commonJS({
  "node_modules/vscode-languageserver/lib/common/notebook.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotebookDocuments = exports2.NotebookSyncFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var textDocuments_1 = require_textDocuments();
    var NotebookSyncFeature = (Base) => {
      return class extends Base {
        get synchronization() {
          return {
            onDidOpenNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidOpenNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidChangeNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidChangeNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidSaveNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidSaveNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            },
            onDidCloseNotebookDocument: (handler) => {
              return this.connection.onNotification(vscode_languageserver_protocol_1.DidCloseNotebookDocumentNotification.type, (params) => {
                handler(params);
              });
            }
          };
        }
      };
    };
    exports2.NotebookSyncFeature = NotebookSyncFeature;
    var CellTextDocumentConnection = class {
      onDidOpenTextDocument(handler) {
        this.openHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.openHandler = void 0;
        });
      }
      openTextDocument(params) {
        this.openHandler && this.openHandler(params);
      }
      onDidChangeTextDocument(handler) {
        this.changeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.changeHandler = handler;
        });
      }
      changeTextDocument(params) {
        this.changeHandler && this.changeHandler(params);
      }
      onDidCloseTextDocument(handler) {
        this.closeHandler = handler;
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          this.closeHandler = void 0;
        });
      }
      closeTextDocument(params) {
        this.closeHandler && this.closeHandler(params);
      }
      onWillSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
      onWillSaveTextDocumentWaitUntil() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
      onDidSaveTextDocument() {
        return CellTextDocumentConnection.NULL_DISPOSE;
      }
    };
    CellTextDocumentConnection.NULL_DISPOSE = Object.freeze({ dispose: () => {
    } });
    var NotebookDocuments = class {
      constructor(configurationOrTextDocuments) {
        if (configurationOrTextDocuments instanceof textDocuments_1.TextDocuments) {
          this._cellTextDocuments = configurationOrTextDocuments;
        } else {
          this._cellTextDocuments = new textDocuments_1.TextDocuments(configurationOrTextDocuments);
        }
        this.notebookDocuments = /* @__PURE__ */ new Map();
        this.notebookCellMap = /* @__PURE__ */ new Map();
        this._onDidOpen = new vscode_languageserver_protocol_1.Emitter();
        this._onDidChange = new vscode_languageserver_protocol_1.Emitter();
        this._onDidSave = new vscode_languageserver_protocol_1.Emitter();
        this._onDidClose = new vscode_languageserver_protocol_1.Emitter();
      }
      get cellTextDocuments() {
        return this._cellTextDocuments;
      }
      getCellTextDocument(cell) {
        return this._cellTextDocuments.get(cell.document);
      }
      getNotebookDocument(uri) {
        return this.notebookDocuments.get(uri);
      }
      getNotebookCell(uri) {
        const value = this.notebookCellMap.get(uri);
        return value && value[0];
      }
      findNotebookDocumentForCell(cell) {
        const key = typeof cell === "string" ? cell : cell.document;
        const value = this.notebookCellMap.get(key);
        return value && value[1];
      }
      get onDidOpen() {
        return this._onDidOpen.event;
      }
      get onDidSave() {
        return this._onDidSave.event;
      }
      get onDidChange() {
        return this._onDidChange.event;
      }
      get onDidClose() {
        return this._onDidClose.event;
      }
      listen(connection) {
        const cellTextDocumentConnection = new CellTextDocumentConnection();
        const disposables = [];
        disposables.push(this.cellTextDocuments.listen(cellTextDocumentConnection));
        disposables.push(connection.notebooks.synchronization.onDidOpenNotebookDocument((params) => {
          this.notebookDocuments.set(params.notebookDocument.uri, params.notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.openTextDocument({ textDocument: cellTextDocument });
          }
          this.updateCellMap(params.notebookDocument);
          this._onDidOpen.fire(params.notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidChangeNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          notebookDocument.version = params.notebookDocument.version;
          const oldMetadata = notebookDocument.metadata;
          let metadataChanged = false;
          const change = params.change;
          if (change.metadata !== void 0) {
            metadataChanged = true;
            notebookDocument.metadata = change.metadata;
          }
          const opened = [];
          const closed = [];
          const data = [];
          const text = [];
          if (change.cells !== void 0) {
            const changedCells = change.cells;
            if (changedCells.structure !== void 0) {
              const array = changedCells.structure.array;
              notebookDocument.cells.splice(array.start, array.deleteCount, ...array.cells !== void 0 ? array.cells : []);
              if (changedCells.structure.didOpen !== void 0) {
                for (const open of changedCells.structure.didOpen) {
                  cellTextDocumentConnection.openTextDocument({ textDocument: open });
                  opened.push(open.uri);
                }
              }
              if (changedCells.structure.didClose) {
                for (const close of changedCells.structure.didClose) {
                  cellTextDocumentConnection.closeTextDocument({ textDocument: close });
                  closed.push(close.uri);
                }
              }
            }
            if (changedCells.data !== void 0) {
              const cellUpdates = new Map(changedCells.data.map((cell) => [cell.document, cell]));
              for (let i = 0; i <= notebookDocument.cells.length; i++) {
                const change2 = cellUpdates.get(notebookDocument.cells[i].document);
                if (change2 !== void 0) {
                  const old = notebookDocument.cells.splice(i, 1, change2);
                  data.push({ old: old[0], new: change2 });
                  cellUpdates.delete(change2.document);
                  if (cellUpdates.size === 0) {
                    break;
                  }
                }
              }
            }
            if (changedCells.textContent !== void 0) {
              for (const cellTextDocument of changedCells.textContent) {
                cellTextDocumentConnection.changeTextDocument({ textDocument: cellTextDocument.document, contentChanges: cellTextDocument.changes });
                text.push(cellTextDocument.document.uri);
              }
            }
          }
          this.updateCellMap(notebookDocument);
          const changeEvent = { notebookDocument };
          if (metadataChanged) {
            changeEvent.metadata = { old: oldMetadata, new: notebookDocument.metadata };
          }
          const added = [];
          for (const open of opened) {
            added.push(this.getNotebookCell(open));
          }
          const removed = [];
          for (const close of closed) {
            removed.push(this.getNotebookCell(close));
          }
          const textContent = [];
          for (const change2 of text) {
            textContent.push(this.getNotebookCell(change2));
          }
          if (added.length > 0 || removed.length > 0 || data.length > 0 || textContent.length > 0) {
            changeEvent.cells = { added, removed, changed: { data, textContent } };
          }
          if (changeEvent.metadata !== void 0 || changeEvent.cells !== void 0) {
            this._onDidChange.fire(changeEvent);
          }
        }));
        disposables.push(connection.notebooks.synchronization.onDidSaveNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidSave.fire(notebookDocument);
        }));
        disposables.push(connection.notebooks.synchronization.onDidCloseNotebookDocument((params) => {
          const notebookDocument = this.notebookDocuments.get(params.notebookDocument.uri);
          if (notebookDocument === void 0) {
            return;
          }
          this._onDidClose.fire(notebookDocument);
          for (const cellTextDocument of params.cellTextDocuments) {
            cellTextDocumentConnection.closeTextDocument({ textDocument: cellTextDocument });
          }
          this.notebookDocuments.delete(params.notebookDocument.uri);
          for (const cell of notebookDocument.cells) {
            this.notebookCellMap.delete(cell.document);
          }
        }));
        return vscode_languageserver_protocol_1.Disposable.create(() => {
          disposables.forEach((disposable) => disposable.dispose());
        });
      }
      updateCellMap(notebookDocument) {
        for (const cell of notebookDocument.cells) {
          this.notebookCellMap.set(cell.document, [cell, notebookDocument]);
        }
      }
    };
    exports2.NotebookDocuments = NotebookDocuments;
  }
});

// node_modules/vscode-languageserver/lib/common/moniker.js
var require_moniker = __commonJS({
  "node_modules/vscode-languageserver/lib/common/moniker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MonikerFeature = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var MonikerFeature = (Base) => {
      return class extends Base {
        get moniker() {
          return {
            on: (handler) => {
              const type = vscode_languageserver_protocol_1.MonikerRequest.type;
              return this.connection.onRequest(type, (params, cancel) => {
                return handler(params, cancel, this.attachWorkDoneProgress(params), this.attachPartialResultProgress(type, params));
              });
            }
          };
        }
      };
    };
    exports2.MonikerFeature = MonikerFeature;
  }
});

// node_modules/vscode-languageserver/lib/common/server.js
var require_server = __commonJS({
  "node_modules/vscode-languageserver/lib/common/server.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.combineFeatures = exports2.combineNotebooksFeatures = exports2.combineLanguagesFeatures = exports2.combineWorkspaceFeatures = exports2.combineWindowFeatures = exports2.combineClientFeatures = exports2.combineTracerFeatures = exports2.combineTelemetryFeatures = exports2.combineConsoleFeatures = exports2._NotebooksImpl = exports2._LanguagesImpl = exports2.BulkUnregistration = exports2.BulkRegistration = exports2.ErrorMessageTracker = void 0;
    var vscode_languageserver_protocol_1 = require_main3();
    var Is = require_is();
    var UUID = require_uuid();
    var progress_1 = require_progress();
    var configuration_1 = require_configuration();
    var workspaceFolder_1 = require_workspaceFolder();
    var callHierarchy_1 = require_callHierarchy();
    var semanticTokens_1 = require_semanticTokens();
    var showDocument_1 = require_showDocument();
    var fileOperations_1 = require_fileOperations();
    var linkedEditingRange_1 = require_linkedEditingRange();
    var typeHierarchy_1 = require_typeHierarchy();
    var inlineValue_1 = require_inlineValue();
    var inlayHint_1 = require_inlayHint();
    var diagnostic_1 = require_diagnostic();
    var notebook_1 = require_notebook();
    var moniker_1 = require_moniker();
    function null2Undefined(value) {
      if (value === null) {
        return void 0;
      }
      return value;
    }
    var ErrorMessageTracker = class {
      constructor() {
        this._messages = /* @__PURE__ */ Object.create(null);
      }
      add(message) {
        let count = this._messages[message];
        if (!count) {
          count = 0;
        }
        count++;
        this._messages[message] = count;
      }
      sendErrors(connection) {
        Object.keys(this._messages).forEach((message) => {
          connection.window.showErrorMessage(message);
        });
      }
    };
    exports2.ErrorMessageTracker = ErrorMessageTracker;
    var RemoteConsoleImpl = class {
      constructor() {
      }
      rawAttach(connection) {
        this._rawConnection = connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      fillServerCapabilities(_capabilities) {
      }
      initialize(_capabilities) {
      }
      error(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Error, message);
      }
      warn(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Warning, message);
      }
      info(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Info, message);
      }
      log(message) {
        this.send(vscode_languageserver_protocol_1.MessageType.Log, message);
      }
      send(type, message) {
        if (this._rawConnection) {
          this._rawConnection.sendNotification(vscode_languageserver_protocol_1.LogMessageNotification.type, { type, message }).catch(() => {
            (0, vscode_languageserver_protocol_1.RAL)().console.error(`Sending log message failed`);
          });
        }
      }
    };
    var _RemoteWindowImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      showErrorMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Error, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showWarningMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Warning, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
      showInformationMessage(message, ...actions) {
        let params = { type: vscode_languageserver_protocol_1.MessageType.Info, message, actions };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ShowMessageRequest.type, params).then(null2Undefined);
      }
    };
    var RemoteWindowImpl = (0, showDocument_1.ShowDocumentFeature)((0, progress_1.ProgressFeature)(_RemoteWindowImpl));
    var BulkRegistration;
    (function(BulkRegistration2) {
      function create() {
        return new BulkRegistrationImpl();
      }
      BulkRegistration2.create = create;
    })(BulkRegistration = exports2.BulkRegistration || (exports2.BulkRegistration = {}));
    var BulkRegistrationImpl = class {
      constructor() {
        this._registrations = [];
        this._registered = /* @__PURE__ */ new Set();
      }
      add(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        if (this._registered.has(method)) {
          throw new Error(`${method} is already added to this registration`);
        }
        const id = UUID.generateUuid();
        this._registrations.push({
          id,
          method,
          registerOptions: registerOptions || {}
        });
        this._registered.add(method);
      }
      asRegistrationParams() {
        return {
          registrations: this._registrations
        };
      }
    };
    var BulkUnregistration;
    (function(BulkUnregistration2) {
      function create() {
        return new BulkUnregistrationImpl(void 0, []);
      }
      BulkUnregistration2.create = create;
    })(BulkUnregistration = exports2.BulkUnregistration || (exports2.BulkUnregistration = {}));
    var BulkUnregistrationImpl = class {
      constructor(_connection, unregistrations) {
        this._connection = _connection;
        this._unregistrations = /* @__PURE__ */ new Map();
        unregistrations.forEach((unregistration) => {
          this._unregistrations.set(unregistration.method, unregistration);
        });
      }
      get isAttached() {
        return !!this._connection;
      }
      attach(connection) {
        this._connection = connection;
      }
      add(unregistration) {
        this._unregistrations.set(unregistration.method, unregistration);
      }
      dispose() {
        let unregistrations = [];
        for (let unregistration of this._unregistrations.values()) {
          unregistrations.push(unregistration);
        }
        let params = {
          unregisterations: unregistrations
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this._connection.console.info(`Bulk unregistration failed.`);
        });
      }
      disposeSingle(arg) {
        const method = Is.string(arg) ? arg : arg.method;
        const unregistration = this._unregistrations.get(method);
        if (!unregistration) {
          return false;
        }
        let params = {
          unregisterations: [unregistration]
        };
        this._connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).then(() => {
          this._unregistrations.delete(method);
        }, (_error) => {
          this._connection.console.info(`Un-registering request handler for ${unregistration.id} failed.`);
        });
        return true;
      }
    };
    var RemoteClientImpl = class {
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      register(typeOrRegistrations, registerOptionsOrType, registerOptions) {
        if (typeOrRegistrations instanceof BulkRegistrationImpl) {
          return this.registerMany(typeOrRegistrations);
        } else if (typeOrRegistrations instanceof BulkUnregistrationImpl) {
          return this.registerSingle1(typeOrRegistrations, registerOptionsOrType, registerOptions);
        } else {
          return this.registerSingle2(typeOrRegistrations, registerOptionsOrType);
        }
      }
      registerSingle1(unregistration, type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        if (!unregistration.isAttached) {
          unregistration.attach(this.connection);
        }
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          unregistration.add({ id, method });
          return unregistration;
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      registerSingle2(type, registerOptions) {
        const method = Is.string(type) ? type : type.method;
        const id = UUID.generateUuid();
        let params = {
          registrations: [{ id, method, registerOptions: registerOptions || {} }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then((_result) => {
          return vscode_languageserver_protocol_1.Disposable.create(() => {
            this.unregisterSingle(id, method).catch(() => {
              this.connection.console.info(`Un-registering capability with id ${id} failed.`);
            });
          });
        }, (_error) => {
          this.connection.console.info(`Registering request handler for ${method} failed.`);
          return Promise.reject(_error);
        });
      }
      unregisterSingle(id, method) {
        let params = {
          unregisterations: [{ id, method }]
        };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.UnregistrationRequest.type, params).catch(() => {
          this.connection.console.info(`Un-registering request handler for ${id} failed.`);
        });
      }
      registerMany(registrations) {
        let params = registrations.asRegistrationParams();
        return this.connection.sendRequest(vscode_languageserver_protocol_1.RegistrationRequest.type, params).then(() => {
          return new BulkUnregistrationImpl(this._connection, params.registrations.map((registration) => {
            return { id: registration.id, method: registration.method };
          }));
        }, (_error) => {
          this.connection.console.info(`Bulk registration failed.`);
          return Promise.reject(_error);
        });
      }
    };
    var _RemoteWorkspaceImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      applyEdit(paramOrEdit) {
        function isApplyWorkspaceEditParams(value) {
          return value && !!value.edit;
        }
        let params = isApplyWorkspaceEditParams(paramOrEdit) ? paramOrEdit : { edit: paramOrEdit };
        return this.connection.sendRequest(vscode_languageserver_protocol_1.ApplyWorkspaceEditRequest.type, params);
      }
    };
    var RemoteWorkspaceImpl = (0, fileOperations_1.FileOperationsFeature)((0, workspaceFolder_1.WorkspaceFoldersFeature)((0, configuration_1.ConfigurationFeature)(_RemoteWorkspaceImpl)));
    var TracerImpl = class {
      constructor() {
        this._trace = vscode_languageserver_protocol_1.Trace.Off;
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      set trace(value) {
        this._trace = value;
      }
      log(message, verbose) {
        if (this._trace === vscode_languageserver_protocol_1.Trace.Off) {
          return;
        }
        this.connection.sendNotification(vscode_languageserver_protocol_1.LogTraceNotification.type, {
          message,
          verbose: this._trace === vscode_languageserver_protocol_1.Trace.Verbose ? verbose : void 0
        }).catch(() => {
        });
      }
    };
    var TelemetryImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      logEvent(data) {
        this.connection.sendNotification(vscode_languageserver_protocol_1.TelemetryEventNotification.type, data).catch(() => {
          this.connection.console.log(`Sending TelemetryEventNotification failed`);
        });
      }
    };
    var _LanguagesImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._LanguagesImpl = _LanguagesImpl;
    var LanguagesImpl = (0, moniker_1.MonikerFeature)((0, diagnostic_1.DiagnosticFeature)((0, inlayHint_1.InlayHintFeature)((0, inlineValue_1.InlineValueFeature)((0, typeHierarchy_1.TypeHierarchyFeature)((0, linkedEditingRange_1.LinkedEditingRangeFeature)((0, semanticTokens_1.SemanticTokensFeature)((0, callHierarchy_1.CallHierarchyFeature)(_LanguagesImpl))))))));
    var _NotebooksImpl = class {
      constructor() {
      }
      attach(connection) {
        this._connection = connection;
      }
      get connection() {
        if (!this._connection) {
          throw new Error("Remote is not attached to a connection yet.");
        }
        return this._connection;
      }
      initialize(_capabilities) {
      }
      fillServerCapabilities(_capabilities) {
      }
      attachWorkDoneProgress(params) {
        return (0, progress_1.attachWorkDone)(this.connection, params);
      }
      attachPartialResultProgress(_type, params) {
        return (0, progress_1.attachPartialResult)(this.connection, params);
      }
    };
    exports2._NotebooksImpl = _NotebooksImpl;
    var NotebooksImpl = (0, notebook_1.NotebookSyncFeature)(_NotebooksImpl);
    function combineConsoleFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineConsoleFeatures = combineConsoleFeatures;
    function combineTelemetryFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTelemetryFeatures = combineTelemetryFeatures;
    function combineTracerFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineTracerFeatures = combineTracerFeatures;
    function combineClientFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineClientFeatures = combineClientFeatures;
    function combineWindowFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWindowFeatures = combineWindowFeatures;
    function combineWorkspaceFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineWorkspaceFeatures = combineWorkspaceFeatures;
    function combineLanguagesFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineLanguagesFeatures = combineLanguagesFeatures;
    function combineNotebooksFeatures(one, two) {
      return function(Base) {
        return two(one(Base));
      };
    }
    exports2.combineNotebooksFeatures = combineNotebooksFeatures;
    function combineFeatures(one, two) {
      function combine(one2, two2, func) {
        if (one2 && two2) {
          return func(one2, two2);
        } else if (one2) {
          return one2;
        } else {
          return two2;
        }
      }
      let result = {
        __brand: "features",
        console: combine(one.console, two.console, combineConsoleFeatures),
        tracer: combine(one.tracer, two.tracer, combineTracerFeatures),
        telemetry: combine(one.telemetry, two.telemetry, combineTelemetryFeatures),
        client: combine(one.client, two.client, combineClientFeatures),
        window: combine(one.window, two.window, combineWindowFeatures),
        workspace: combine(one.workspace, two.workspace, combineWorkspaceFeatures),
        languages: combine(one.languages, two.languages, combineLanguagesFeatures),
        notebooks: combine(one.notebooks, two.notebooks, combineNotebooksFeatures)
      };
      return result;
    }
    exports2.combineFeatures = combineFeatures;
    function createConnection(connectionFactory, watchDog, factories) {
      const logger = factories && factories.console ? new (factories.console(RemoteConsoleImpl))() : new RemoteConsoleImpl();
      const connection = connectionFactory(logger);
      logger.rawAttach(connection);
      const tracer = factories && factories.tracer ? new (factories.tracer(TracerImpl))() : new TracerImpl();
      const telemetry = factories && factories.telemetry ? new (factories.telemetry(TelemetryImpl))() : new TelemetryImpl();
      const client = factories && factories.client ? new (factories.client(RemoteClientImpl))() : new RemoteClientImpl();
      const remoteWindow = factories && factories.window ? new (factories.window(RemoteWindowImpl))() : new RemoteWindowImpl();
      const workspace = factories && factories.workspace ? new (factories.workspace(RemoteWorkspaceImpl))() : new RemoteWorkspaceImpl();
      const languages = factories && factories.languages ? new (factories.languages(LanguagesImpl))() : new LanguagesImpl();
      const notebooks = factories && factories.notebooks ? new (factories.notebooks(NotebooksImpl))() : new NotebooksImpl();
      const allRemotes = [logger, tracer, telemetry, client, remoteWindow, workspace, languages, notebooks];
      function asPromise(value) {
        if (value instanceof Promise) {
          return value;
        } else if (Is.thenable(value)) {
          return new Promise((resolve, reject) => {
            value.then((resolved) => resolve(resolved), (error) => reject(error));
          });
        } else {
          return Promise.resolve(value);
        }
      }
      let shutdownHandler = void 0;
      let initializeHandler = void 0;
      let exitHandler = void 0;
      let protocolConnection = {
        listen: () => connection.listen(),
        sendRequest: (type, ...params) => connection.sendRequest(Is.string(type) ? type : type.method, ...params),
        onRequest: (type, handler) => connection.onRequest(type, handler),
        sendNotification: (type, param) => {
          const method = Is.string(type) ? type : type.method;
          if (arguments.length === 1) {
            return connection.sendNotification(method);
          } else {
            return connection.sendNotification(method, param);
          }
        },
        onNotification: (type, handler) => connection.onNotification(type, handler),
        onProgress: connection.onProgress,
        sendProgress: connection.sendProgress,
        onInitialize: (handler) => {
          initializeHandler = handler;
          return {
            dispose: () => {
              initializeHandler = void 0;
            }
          };
        },
        onInitialized: (handler) => connection.onNotification(vscode_languageserver_protocol_1.InitializedNotification.type, handler),
        onShutdown: (handler) => {
          shutdownHandler = handler;
          return {
            dispose: () => {
              shutdownHandler = void 0;
            }
          };
        },
        onExit: (handler) => {
          exitHandler = handler;
          return {
            dispose: () => {
              exitHandler = void 0;
            }
          };
        },
        get console() {
          return logger;
        },
        get telemetry() {
          return telemetry;
        },
        get tracer() {
          return tracer;
        },
        get client() {
          return client;
        },
        get window() {
          return remoteWindow;
        },
        get workspace() {
          return workspace;
        },
        get languages() {
          return languages;
        },
        get notebooks() {
          return notebooks;
        },
        onDidChangeConfiguration: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeConfigurationNotification.type, handler),
        onDidChangeWatchedFiles: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeWatchedFilesNotification.type, handler),
        __textDocumentSync: void 0,
        onDidOpenTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidOpenTextDocumentNotification.type, handler),
        onDidChangeTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidChangeTextDocumentNotification.type, handler),
        onDidCloseTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidCloseTextDocumentNotification.type, handler),
        onWillSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.WillSaveTextDocumentNotification.type, handler),
        onWillSaveTextDocumentWaitUntil: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WillSaveTextDocumentWaitUntilRequest.type, handler),
        onDidSaveTextDocument: (handler) => connection.onNotification(vscode_languageserver_protocol_1.DidSaveTextDocumentNotification.type, handler),
        sendDiagnostics: (params) => connection.sendNotification(vscode_languageserver_protocol_1.PublishDiagnosticsNotification.type, params),
        onHover: (handler) => connection.onRequest(vscode_languageserver_protocol_1.HoverRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onCompletion: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCompletionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CompletionResolveRequest.type, handler),
        onSignatureHelp: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SignatureHelpRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDeclaration: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DeclarationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onTypeDefinition: (handler) => connection.onRequest(vscode_languageserver_protocol_1.TypeDefinitionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onImplementation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ImplementationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onReferences: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ReferencesRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentHighlight: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentHighlightRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbol: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onWorkspaceSymbolResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.WorkspaceSymbolResolveRequest.type, handler),
        onCodeAction: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeActionResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeActionResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onCodeLens: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onCodeLensResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.CodeLensResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentRangeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentRangeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onDocumentOnTypeFormatting: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentOnTypeFormattingRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onRenameRequest: (handler) => connection.onRequest(vscode_languageserver_protocol_1.RenameRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        onPrepareRename: (handler) => connection.onRequest(vscode_languageserver_protocol_1.PrepareRenameRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentLinks: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onDocumentLinkResolve: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentLinkResolveRequest.type, (params, cancel) => {
          return handler(params, cancel);
        }),
        onDocumentColor: (handler) => connection.onRequest(vscode_languageserver_protocol_1.DocumentColorRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onColorPresentation: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ColorPresentationRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onFoldingRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.FoldingRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onSelectionRanges: (handler) => connection.onRequest(vscode_languageserver_protocol_1.SelectionRangeRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), (0, progress_1.attachPartialResult)(connection, params));
        }),
        onExecuteCommand: (handler) => connection.onRequest(vscode_languageserver_protocol_1.ExecuteCommandRequest.type, (params, cancel) => {
          return handler(params, cancel, (0, progress_1.attachWorkDone)(connection, params), void 0);
        }),
        dispose: () => connection.dispose()
      };
      for (let remote of allRemotes) {
        remote.attach(protocolConnection);
      }
      connection.onRequest(vscode_languageserver_protocol_1.InitializeRequest.type, (params) => {
        watchDog.initialize(params);
        if (Is.string(params.trace)) {
          tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.trace);
        }
        for (let remote of allRemotes) {
          remote.initialize(params.capabilities);
        }
        if (initializeHandler) {
          let result = initializeHandler(params, new vscode_languageserver_protocol_1.CancellationTokenSource().token, (0, progress_1.attachWorkDone)(connection, params), void 0);
          return asPromise(result).then((value) => {
            if (value instanceof vscode_languageserver_protocol_1.ResponseError) {
              return value;
            }
            let result2 = value;
            if (!result2) {
              result2 = { capabilities: {} };
            }
            let capabilities = result2.capabilities;
            if (!capabilities) {
              capabilities = {};
              result2.capabilities = capabilities;
            }
            if (capabilities.textDocumentSync === void 0 || capabilities.textDocumentSync === null) {
              capabilities.textDocumentSync = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            } else if (!Is.number(capabilities.textDocumentSync) && !Is.number(capabilities.textDocumentSync.change)) {
              capabilities.textDocumentSync.change = Is.number(protocolConnection.__textDocumentSync) ? protocolConnection.__textDocumentSync : vscode_languageserver_protocol_1.TextDocumentSyncKind.None;
            }
            for (let remote of allRemotes) {
              remote.fillServerCapabilities(capabilities);
            }
            return result2;
          });
        } else {
          let result = { capabilities: { textDocumentSync: vscode_languageserver_protocol_1.TextDocumentSyncKind.None } };
          for (let remote of allRemotes) {
            remote.fillServerCapabilities(result.capabilities);
          }
          return result;
        }
      });
      connection.onRequest(vscode_languageserver_protocol_1.ShutdownRequest.type, () => {
        watchDog.shutdownReceived = true;
        if (shutdownHandler) {
          return shutdownHandler(new vscode_languageserver_protocol_1.CancellationTokenSource().token);
        } else {
          return void 0;
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.ExitNotification.type, () => {
        try {
          if (exitHandler) {
            exitHandler();
          }
        } finally {
          if (watchDog.shutdownReceived) {
            watchDog.exit(0);
          } else {
            watchDog.exit(1);
          }
        }
      });
      connection.onNotification(vscode_languageserver_protocol_1.SetTraceNotification.type, (params) => {
        tracer.trace = vscode_languageserver_protocol_1.Trace.fromString(params.value);
      });
      return protocolConnection;
    }
    exports2.createConnection = createConnection;
  }
});

// node_modules/vscode-languageserver/lib/node/files.js
var require_files = __commonJS({
  "node_modules/vscode-languageserver/lib/node/files.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.resolveModulePath = exports2.FileSystem = exports2.resolveGlobalYarnPath = exports2.resolveGlobalNodePath = exports2.resolve = exports2.uriToFilePath = void 0;
    var url = require("url");
    var path = require("path");
    var fs = require("fs");
    var child_process_1 = require("child_process");
    function uriToFilePath(uri) {
      let parsed = url.parse(uri);
      if (parsed.protocol !== "file:" || !parsed.path) {
        return void 0;
      }
      let segments = parsed.path.split("/");
      for (var i = 0, len = segments.length; i < len; i++) {
        segments[i] = decodeURIComponent(segments[i]);
      }
      if (process.platform === "win32" && segments.length > 1) {
        let first = segments[0];
        let second = segments[1];
        if (first.length === 0 && second.length > 1 && second[1] === ":") {
          segments.shift();
        }
      }
      return path.normalize(segments.join("/"));
    }
    exports2.uriToFilePath = uriToFilePath;
    function isWindows() {
      return process.platform === "win32";
    }
    function resolve(moduleName, nodePath, cwd, tracer) {
      const nodePathKey = "NODE_PATH";
      const app = [
        "var p = process;",
        "p.on('message',function(m){",
        "if(m.c==='e'){",
        "p.exit(0);",
        "}",
        "else if(m.c==='rs'){",
        "try{",
        "var r=require.resolve(m.a);",
        "p.send({c:'r',s:true,r:r});",
        "}",
        "catch(err){",
        "p.send({c:'r',s:false});",
        "}",
        "}",
        "});"
      ].join("");
      return new Promise((resolve2, reject) => {
        let env = process.env;
        let newEnv = /* @__PURE__ */ Object.create(null);
        Object.keys(env).forEach((key) => newEnv[key] = env[key]);
        if (nodePath && fs.existsSync(nodePath)) {
          if (newEnv[nodePathKey]) {
            newEnv[nodePathKey] = nodePath + path.delimiter + newEnv[nodePathKey];
          } else {
            newEnv[nodePathKey] = nodePath;
          }
          if (tracer) {
            tracer(`NODE_PATH value is: ${newEnv[nodePathKey]}`);
          }
        }
        newEnv["ELECTRON_RUN_AS_NODE"] = "1";
        try {
          let cp = (0, child_process_1.fork)("", [], {
            cwd,
            env: newEnv,
            execArgv: ["-e", app]
          });
          if (cp.pid === void 0) {
            reject(new Error(`Starting process to resolve node module  ${moduleName} failed`));
            return;
          }
          cp.on("error", (error) => {
            reject(error);
          });
          cp.on("message", (message2) => {
            if (message2.c === "r") {
              cp.send({ c: "e" });
              if (message2.s) {
                resolve2(message2.r);
              } else {
                reject(new Error(`Failed to resolve module: ${moduleName}`));
              }
            }
          });
          let message = {
            c: "rs",
            a: moduleName
          };
          cp.send(message);
        } catch (error) {
          reject(error);
        }
      });
    }
    exports2.resolve = resolve;
    function resolveGlobalNodePath(tracer) {
      let npmCommand = "npm";
      const env = /* @__PURE__ */ Object.create(null);
      Object.keys(process.env).forEach((key) => env[key] = process.env[key]);
      env["NO_UPDATE_NOTIFIER"] = "true";
      const options = {
        encoding: "utf8",
        env
      };
      if (isWindows()) {
        npmCommand = "npm.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let stdout = (0, child_process_1.spawnSync)(npmCommand, ["config", "get", "prefix"], options).stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'npm config get prefix' didn't return a value.`);
          }
          return void 0;
        }
        let prefix = stdout.trim();
        if (tracer) {
          tracer(`'npm config get prefix' value is: ${prefix}`);
        }
        if (prefix.length > 0) {
          if (isWindows()) {
            return path.join(prefix, "node_modules");
          } else {
            return path.join(prefix, "lib", "node_modules");
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalNodePath = resolveGlobalNodePath;
    function resolveGlobalYarnPath(tracer) {
      let yarnCommand = "yarn";
      let options = {
        encoding: "utf8"
      };
      if (isWindows()) {
        yarnCommand = "yarn.cmd";
        options.shell = true;
      }
      let handler = () => {
      };
      try {
        process.on("SIGPIPE", handler);
        let results = (0, child_process_1.spawnSync)(yarnCommand, ["global", "dir", "--json"], options);
        let stdout = results.stdout;
        if (!stdout) {
          if (tracer) {
            tracer(`'yarn global dir' didn't return a value.`);
            if (results.stderr) {
              tracer(results.stderr);
            }
          }
          return void 0;
        }
        let lines = stdout.trim().split(/\r?\n/);
        for (let line of lines) {
          try {
            let yarn = JSON.parse(line);
            if (yarn.type === "log") {
              return path.join(yarn.data, "node_modules");
            }
          } catch (e) {
          }
        }
        return void 0;
      } catch (err) {
        return void 0;
      } finally {
        process.removeListener("SIGPIPE", handler);
      }
    }
    exports2.resolveGlobalYarnPath = resolveGlobalYarnPath;
    var FileSystem;
    (function(FileSystem2) {
      let _isCaseSensitive = void 0;
      function isCaseSensitive() {
        if (_isCaseSensitive !== void 0) {
          return _isCaseSensitive;
        }
        if (process.platform === "win32") {
          _isCaseSensitive = false;
        } else {
          _isCaseSensitive = !fs.existsSync(__filename.toUpperCase()) || !fs.existsSync(__filename.toLowerCase());
        }
        return _isCaseSensitive;
      }
      FileSystem2.isCaseSensitive = isCaseSensitive;
      function isParent(parent, child) {
        if (isCaseSensitive()) {
          return path.normalize(child).indexOf(path.normalize(parent)) === 0;
        } else {
          return path.normalize(child).toLowerCase().indexOf(path.normalize(parent).toLowerCase()) === 0;
        }
      }
      FileSystem2.isParent = isParent;
    })(FileSystem = exports2.FileSystem || (exports2.FileSystem = {}));
    function resolveModulePath(workspaceRoot, moduleName, nodePath, tracer) {
      if (nodePath) {
        if (!path.isAbsolute(nodePath)) {
          nodePath = path.join(workspaceRoot, nodePath);
        }
        return resolve(moduleName, nodePath, nodePath, tracer).then((value) => {
          if (FileSystem.isParent(nodePath, value)) {
            return value;
          } else {
            return Promise.reject(new Error(`Failed to load ${moduleName} from node path location.`));
          }
        }).then(void 0, (_error) => {
          return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
        });
      } else {
        return resolve(moduleName, resolveGlobalNodePath(tracer), workspaceRoot, tracer);
      }
    }
    exports2.resolveModulePath = resolveModulePath;
  }
});

// node_modules/vscode-languageserver-protocol/node.js
var require_node2 = __commonJS({
  "node_modules/vscode-languageserver-protocol/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main3();
  }
});

// node_modules/vscode-languageserver/lib/common/api.js
var require_api3 = __commonJS({
  "node_modules/vscode-languageserver/lib/common/api.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProposedFeatures = exports2.NotebookDocuments = exports2.TextDocuments = exports2.SemanticTokensBuilder = void 0;
    var semanticTokens_1 = require_semanticTokens();
    Object.defineProperty(exports2, "SemanticTokensBuilder", { enumerable: true, get: function() {
      return semanticTokens_1.SemanticTokensBuilder;
    } });
    __exportStar(require_main3(), exports2);
    var textDocuments_1 = require_textDocuments();
    Object.defineProperty(exports2, "TextDocuments", { enumerable: true, get: function() {
      return textDocuments_1.TextDocuments;
    } });
    var notebook_1 = require_notebook();
    Object.defineProperty(exports2, "NotebookDocuments", { enumerable: true, get: function() {
      return notebook_1.NotebookDocuments;
    } });
    __exportStar(require_server(), exports2);
    var ProposedFeatures;
    (function(ProposedFeatures2) {
      ProposedFeatures2.all = {
        __brand: "features"
      };
    })(ProposedFeatures = exports2.ProposedFeatures || (exports2.ProposedFeatures = {}));
  }
});

// node_modules/vscode-languageserver/lib/node/main.js
var require_main4 = __commonJS({
  "node_modules/vscode-languageserver/lib/node/main.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createConnection = exports2.Files = void 0;
    var Is = require_is();
    var server_1 = require_server();
    var fm = require_files();
    var node_1 = require_node2();
    __exportStar(require_node2(), exports2);
    __exportStar(require_api3(), exports2);
    var Files;
    (function(Files2) {
      Files2.uriToFilePath = fm.uriToFilePath;
      Files2.resolveGlobalNodePath = fm.resolveGlobalNodePath;
      Files2.resolveGlobalYarnPath = fm.resolveGlobalYarnPath;
      Files2.resolve = fm.resolve;
      Files2.resolveModulePath = fm.resolveModulePath;
    })(Files = exports2.Files || (exports2.Files = {}));
    var _protocolConnection;
    function endProtocolConnection() {
      if (_protocolConnection === void 0) {
        return;
      }
      try {
        _protocolConnection.end();
      } catch (_err) {
      }
    }
    var _shutdownReceived = false;
    var exitTimer = void 0;
    function setupExitTimer() {
      const argName = "--clientProcessId";
      function runTimer(value) {
        try {
          let processId = parseInt(value);
          if (!isNaN(processId)) {
            exitTimer = setInterval(() => {
              try {
                process.kill(processId, 0);
              } catch (ex) {
                endProtocolConnection();
                process.exit(_shutdownReceived ? 0 : 1);
              }
            }, 3e3);
          }
        } catch (e) {
        }
      }
      for (let i = 2; i < process.argv.length; i++) {
        let arg = process.argv[i];
        if (arg === argName && i + 1 < process.argv.length) {
          runTimer(process.argv[i + 1]);
          return;
        } else {
          let args = arg.split("=");
          if (args[0] === argName) {
            runTimer(args[1]);
          }
        }
      }
    }
    setupExitTimer();
    var watchDog = {
      initialize: (params) => {
        const processId = params.processId;
        if (Is.number(processId) && exitTimer === void 0) {
          setInterval(() => {
            try {
              process.kill(processId, 0);
            } catch (ex) {
              process.exit(_shutdownReceived ? 0 : 1);
            }
          }, 3e3);
        }
      },
      get shutdownReceived() {
        return _shutdownReceived;
      },
      set shutdownReceived(value) {
        _shutdownReceived = value;
      },
      exit: (code) => {
        endProtocolConnection();
        process.exit(code);
      }
    };
    function createConnection(arg1, arg2, arg3, arg4) {
      let factories;
      let input;
      let output;
      let options;
      if (arg1 !== void 0 && arg1.__brand === "features") {
        factories = arg1;
        arg1 = arg2;
        arg2 = arg3;
        arg3 = arg4;
      }
      if (node_1.ConnectionStrategy.is(arg1) || node_1.ConnectionOptions.is(arg1)) {
        options = arg1;
      } else {
        input = arg1;
        output = arg2;
        options = arg3;
      }
      return _createConnection(input, output, options, factories);
    }
    exports2.createConnection = createConnection;
    function _createConnection(input, output, options, factories) {
      if (!input && !output && process.argv.length > 2) {
        let port = void 0;
        let pipeName = void 0;
        let argv = process.argv.slice(2);
        for (let i = 0; i < argv.length; i++) {
          let arg = argv[i];
          if (arg === "--node-ipc") {
            input = new node_1.IPCMessageReader(process);
            output = new node_1.IPCMessageWriter(process);
            break;
          } else if (arg === "--stdio") {
            input = process.stdin;
            output = process.stdout;
            break;
          } else if (arg === "--socket") {
            port = parseInt(argv[i + 1]);
            break;
          } else if (arg === "--pipe") {
            pipeName = argv[i + 1];
            break;
          } else {
            var args = arg.split("=");
            if (args[0] === "--socket") {
              port = parseInt(args[1]);
              break;
            } else if (args[0] === "--pipe") {
              pipeName = args[1];
              break;
            }
          }
        }
        if (port) {
          let transport = (0, node_1.createServerSocketTransport)(port);
          input = transport[0];
          output = transport[1];
        } else if (pipeName) {
          let transport = (0, node_1.createServerPipeTransport)(pipeName);
          input = transport[0];
          output = transport[1];
        }
      }
      var commandLineMessage = "Use arguments of createConnection or set command line parameters: '--node-ipc', '--stdio' or '--socket={number}'";
      if (!input) {
        throw new Error("Connection input stream is not set. " + commandLineMessage);
      }
      if (!output) {
        throw new Error("Connection output stream is not set. " + commandLineMessage);
      }
      if (Is.func(input.read) && Is.func(input.on)) {
        let inputStream = input;
        inputStream.on("end", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
        inputStream.on("close", () => {
          endProtocolConnection();
          process.exit(_shutdownReceived ? 0 : 1);
        });
      }
      const connectionFactory = (logger) => {
        const result = (0, node_1.createProtocolConnection)(input, output, logger, options);
        return result;
      };
      return (0, server_1.createConnection)(connectionFactory, watchDog, factories);
    }
  }
});

// node_modules/vscode-languageserver/node.js
var require_node3 = __commonJS({
  "node_modules/vscode-languageserver/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require_main4();
  }
});

// node_modules/vscode-languageserver-textdocument/lib/umd/main.js
var require_main5 = __commonJS({
  "node_modules/vscode-languageserver-textdocument/lib/umd/main.js"(exports2, module2) {
    (function(factory) {
      if (typeof module2 === "object" && typeof module2.exports === "object") {
        var v = factory(require, exports2);
        if (v !== void 0)
          module2.exports = v;
      } else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
      }
    })(function(require2, exports3) {
      "use strict";
      Object.defineProperty(exports3, "__esModule", { value: true });
      exports3.TextDocument = void 0;
      class FullTextDocument {
        constructor(uri, languageId, version, content) {
          this._uri = uri;
          this._languageId = languageId;
          this._version = version;
          this._content = content;
          this._lineOffsets = void 0;
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(range) {
          if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
          }
          return this._content;
        }
        update(changes, version) {
          for (let change of changes) {
            if (FullTextDocument.isIncremental(change)) {
              const range = getWellformedRange(change.range);
              const startOffset = this.offsetAt(range.start);
              const endOffset = this.offsetAt(range.end);
              this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
              const startLine = Math.max(range.start.line, 0);
              const endLine = Math.max(range.end.line, 0);
              let lineOffsets = this._lineOffsets;
              const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
              if (endLine - startLine === addedLineOffsets.length) {
                for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                  lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                }
              } else {
                if (addedLineOffsets.length < 1e4) {
                  lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                } else {
                  this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                }
              }
              const diff = change.text.length - (endOffset - startOffset);
              if (diff !== 0) {
                for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                  lineOffsets[i] = lineOffsets[i] + diff;
                }
              }
            } else if (FullTextDocument.isFull(change)) {
              this._content = change.text;
              this._lineOffsets = void 0;
            } else {
              throw new Error("Unknown change event received");
            }
          }
          this._version = version;
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            this._lineOffsets = computeLineOffsets(this._content, true);
          }
          return this._lineOffsets;
        }
        positionAt(offset) {
          offset = Math.max(Math.min(offset, this._content.length), 0);
          let lineOffsets = this.getLineOffsets();
          let low = 0, high = lineOffsets.length;
          if (high === 0) {
            return { line: 0, character: offset };
          }
          while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
              high = mid;
            } else {
              low = mid + 1;
            }
          }
          let line = low - 1;
          return { line, character: offset - lineOffsets[line] };
        }
        offsetAt(position) {
          let lineOffsets = this.getLineOffsets();
          if (position.line >= lineOffsets.length) {
            return this._content.length;
          } else if (position.line < 0) {
            return 0;
          }
          let lineOffset = lineOffsets[position.line];
          let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
          return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
        static isIncremental(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range !== void 0 && (candidate.rangeLength === void 0 || typeof candidate.rangeLength === "number");
        }
        static isFull(event) {
          let candidate = event;
          return candidate !== void 0 && candidate !== null && typeof candidate.text === "string" && candidate.range === void 0 && candidate.rangeLength === void 0;
        }
      }
      var TextDocument;
      (function(TextDocument2) {
        function create(uri, languageId, version, content) {
          return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument2.create = create;
        function update(document, changes, version) {
          if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
          } else {
            throw new Error("TextDocument.update: document must be created by TextDocument.create");
          }
        }
        TextDocument2.update = update;
        function applyEdits(document, edits) {
          let text = document.getText();
          let sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
              return a.range.start.character - b.range.start.character;
            }
            return diff;
          });
          let lastModifiedOffset = 0;
          const spans = [];
          for (const e of sortedEdits) {
            let startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
              throw new Error("Overlapping edit");
            } else if (startOffset > lastModifiedOffset) {
              spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
              spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
          }
          spans.push(text.substr(lastModifiedOffset));
          return spans.join("");
        }
        TextDocument2.applyEdits = applyEdits;
      })(TextDocument = exports3.TextDocument || (exports3.TextDocument = {}));
      function mergeSort(data, compare) {
        if (data.length <= 1) {
          return data;
        }
        const p = data.length / 2 | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
          let ret = compare(left[leftIdx], right[rightIdx]);
          if (ret <= 0) {
            data[i++] = left[leftIdx++];
          } else {
            data[i++] = right[rightIdx++];
          }
        }
        while (leftIdx < left.length) {
          data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
          data[i++] = right[rightIdx++];
        }
        return data;
      }
      function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
        const result = isAtLineStart ? [textOffset] : [];
        for (let i = 0; i < text.length; i++) {
          let ch = text.charCodeAt(i);
          if (ch === 13 || ch === 10) {
            if (ch === 13 && i + 1 < text.length && text.charCodeAt(i + 1) === 10) {
              i++;
            }
            result.push(textOffset + i + 1);
          }
        }
        return result;
      }
      function getWellformedRange(range) {
        const start = range.start;
        const end = range.end;
        if (start.line > end.line || start.line === end.line && start.character > end.character) {
          return { start: end, end: start };
        }
        return range;
      }
      function getWellformedEdit(textEdit) {
        const range = getWellformedRange(textEdit.range);
        if (range !== textEdit.range) {
          return { newText: textEdit.newText, range };
        }
        return textEdit;
      }
    });
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/walkGherkinDocument.js
var require_walkGherkinDocument = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/walkGherkinDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.walkGherkinDocument = void 0;
    function walkGherkinDocument(gherkinDocument, initialValue, handlers) {
      let acc = initialValue;
      const h = Object.assign(Object.assign({}, makeDefaultHandlers()), handlers);
      const feature = gherkinDocument.feature;
      if (!feature)
        return acc;
      acc = walkTags(feature.tags || [], acc);
      acc = h.feature(feature, acc);
      for (const child of feature.children) {
        if (child.background) {
          acc = walkStepContainer(child.background, acc);
        } else if (child.scenario) {
          acc = walkStepContainer(child.scenario, acc);
        } else if (child.rule) {
          acc = walkTags(child.rule.tags || [], acc);
          acc = h.rule(child.rule, acc);
          for (const ruleChild of child.rule.children) {
            if (ruleChild.background) {
              acc = walkStepContainer(ruleChild.background, acc);
            } else if (ruleChild.scenario) {
              acc = walkStepContainer(ruleChild.scenario, acc);
            }
          }
        }
      }
      return acc;
      function walkTags(tags, acc2) {
        return tags.reduce((acc3, tag) => h.tag(tag, acc3), acc2);
      }
      function walkSteps(steps, acc2) {
        return steps.reduce((acc3, step) => walkStep(step, acc3), acc2);
      }
      function walkStep(step, acc2) {
        acc2 = h.step(step, acc2);
        if (step.docString) {
          acc2 = h.docString(step.docString, acc2);
        }
        if (step.dataTable) {
          acc2 = h.dataTable(step.dataTable, acc2);
          acc2 = walkTableRows(step.dataTable.rows, acc2);
        }
        return acc2;
      }
      function walkTableRows(tableRows, acc2) {
        return tableRows.reduce((acc3, tableRow) => walkTableRow(tableRow, acc3), acc2);
      }
      function walkTableRow(tableRow, acc2) {
        acc2 = h.tableRow(tableRow, acc2);
        return tableRow.cells.reduce((acc3, tableCell) => h.tableCell(tableCell, acc3), acc2);
      }
      function walkStepContainer(stepContainer, acc2) {
        const scenario = "tags" in stepContainer ? stepContainer : null;
        acc2 = walkTags((scenario === null || scenario === void 0 ? void 0 : scenario.tags) || [], acc2);
        acc2 = scenario ? h.scenario(scenario, acc2) : h.background(stepContainer, acc2);
        acc2 = walkSteps(stepContainer.steps, acc2);
        if (scenario) {
          for (const examples of scenario.examples || []) {
            acc2 = walkTags(examples.tags || [], acc2);
            acc2 = h.examples(examples, acc2);
            if (examples.tableHeader) {
              acc2 = walkTableRow(examples.tableHeader, acc2);
              acc2 = walkTableRows(examples.tableBody || [], acc2);
            }
          }
        }
        return acc2;
      }
    }
    exports2.walkGherkinDocument = walkGherkinDocument;
    function makeDefaultHandlers() {
      const defaultHandlers = {
        feature(feature, acc) {
          return acc;
        },
        background(background, acc) {
          return acc;
        },
        rule(rule, acc) {
          return acc;
        },
        scenario(scenario, acc) {
          return acc;
        },
        step(step, acc) {
          return acc;
        },
        examples(examples, acc) {
          return acc;
        },
        tag(tag, acc) {
          return acc;
        },
        comment(comment, acc) {
          return acc;
        },
        dataTable(dataTable, acc) {
          return acc;
        },
        tableRow(tableRow, acc) {
          return acc;
        },
        tableCell(tableCell, acc) {
          return acc;
        },
        docString(docString, acc) {
          return acc;
        }
      };
      return defaultHandlers;
    }
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/GherkinDocumentHandlers.js
var require_GherkinDocumentHandlers = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/GherkinDocumentHandlers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/pretty.js
var require_pretty = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/pretty.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeCell = void 0;
    var walkGherkinDocument_1 = require_walkGherkinDocument();
    function pretty(gherkinDocument, syntax = "gherkin") {
      let scenarioLevel = 1;
      return (0, walkGherkinDocument_1.walkGherkinDocument)(gherkinDocument, "", {
        feature(feature, content) {
          return content.concat(prettyLanguageHeader(feature.language)).concat(prettyKeywordContainer(feature, syntax, 0));
        },
        rule(rule, content) {
          scenarioLevel = 2;
          return content.concat(prettyKeywordContainer(rule, syntax, 1));
        },
        background(background, content) {
          return content.concat(prettyKeywordContainer(background, syntax, scenarioLevel));
        },
        scenario(scenario, content) {
          return content.concat(prettyKeywordContainer(scenario, syntax, scenarioLevel));
        },
        examples(examples, content) {
          const tableRows = examples.tableHeader ? [examples.tableHeader, ...examples.tableBody] : [];
          return content.concat(prettyKeywordContainer(examples, syntax, scenarioLevel + 1)).concat(prettyTableRows(tableRows, syntax, scenarioLevel + 2));
        },
        step(step, content) {
          return content.concat(stepPrefix(scenarioLevel + 1, syntax)).concat(step.keyword).concat(step.text).concat("\n");
        },
        dataTable(dataTable, content) {
          const level = syntax === "markdown" ? 1 : scenarioLevel + 2;
          return content.concat(prettyTableRows(dataTable.rows || [], syntax, level));
        },
        docString(docString, content) {
          const delimiter = makeDocStringDelimiter(syntax, docString);
          const level = syntax === "markdown" ? 1 : scenarioLevel + 2;
          const indent = spaces(level);
          let docStringContent = docString.content.replace(/^/gm, indent);
          if (syntax === "gherkin") {
            if (docString.delimiter === '"""') {
              docStringContent = docStringContent.replace(/"""/gm, '\\"\\"\\"');
            } else {
              docStringContent = docStringContent.replace(/```/gm, "\\`\\`\\`");
            }
          }
          return content.concat(indent).concat(delimiter).concat(docString.mediaType || "").concat("\n").concat(docStringContent).concat("\n").concat(indent).concat(delimiter).concat("\n");
        }
      });
    }
    exports2.default = pretty;
    function prettyLanguageHeader(language) {
      return language === "en" ? "" : `# language: ${language}
`;
    }
    function prettyKeywordContainer(stepContainer, syntax, level) {
      const tags = "tags" in stepContainer ? stepContainer.tags : [];
      const stepCount = "steps" in stepContainer ? stepContainer.steps.length : 0;
      const description = prettyDescription(stepContainer.description, syntax);
      return "".concat(level === 0 ? "" : "\n").concat(prettyTags(tags, syntax, level)).concat(keywordPrefix(level, syntax)).concat(stepContainer.keyword).concat(": ").concat(stepContainer.name).concat("\n").concat(description).concat(description && stepCount > 0 ? "\n" : "");
    }
    function prettyDescription(description, syntax) {
      if (!description)
        return "";
      if (syntax === "gherkin")
        return description + "\n";
      else
        return description.replace(/^\s*/gm, "") + "\n";
    }
    function prettyTags(tags, syntax, level) {
      if (tags === void 0 || tags.length == 0) {
        return "";
      }
      const prefix = syntax === "gherkin" ? spaces(level) : "";
      const tagQuote = syntax === "gherkin" ? "" : "`";
      return prefix + tags.map((tag) => `${tagQuote}${tag.name}${tagQuote}`).join(" ") + "\n";
    }
    function keywordPrefix(level, syntax) {
      if (syntax === "markdown") {
        return new Array(level + 2).join("#") + " ";
      } else {
        return spaces(level);
      }
    }
    function stepPrefix(level, syntax) {
      if (syntax === "markdown") {
        return "* ";
      } else {
        return new Array(level + 1).join("  ");
      }
    }
    function spaces(level) {
      return new Array(level + 1).join("  ");
    }
    function makeDocStringDelimiter(syntax, docString) {
      if (syntax === "gherkin") {
        return docString.delimiter.substring(0, 3);
      }
      const threeOrMoreBackticks = /(```+)/g;
      let maxContentBackTickCount = 2;
      let match;
      do {
        match = threeOrMoreBackticks.exec(docString.content);
        if (match) {
          maxContentBackTickCount = Math.max(maxContentBackTickCount, match[1].length);
        }
      } while (match);
      return new Array(maxContentBackTickCount + 2).join("`");
    }
    function prettyTableRows(tableRows, syntax, level) {
      if (tableRows.length === 0)
        return "";
      const maxWidths = new Array(tableRows[0].cells.length).fill(0);
      tableRows.forEach((tableRow) => {
        tableRow.cells.forEach((tableCell, j) => {
          maxWidths[j] = Math.max(maxWidths[j], escapeCell(tableCell.value).length);
        });
      });
      let n = 0;
      let s = "";
      for (const row of tableRows) {
        s += prettyTableRow(row, level, maxWidths, syntax);
        if (n === 0 && syntax === "markdown") {
          const separatorRow = {
            location: row.location,
            id: row.id + "-separator",
            cells: row.cells.map((cell, j) => ({
              location: cell.location,
              value: new Array(maxWidths[j] + 1).join("-")
            }))
          };
          s += prettyTableRow(separatorRow, level, maxWidths, syntax);
        }
        n++;
      }
      return s;
    }
    function prettyTableRow(row, level, maxWidths, syntax) {
      const actualLevel = syntax === "markdown" ? 1 : level;
      return `${spaces(actualLevel)}| ${row.cells.map((cell, j) => {
        const escapedCellValue = escapeCell(cell.value);
        const spaceCount = maxWidths[j] - escapedCellValue.length;
        const spaces2 = new Array(spaceCount + 1).join(" ");
        return isNumeric(escapedCellValue) ? spaces2 + escapedCellValue : escapedCellValue + spaces2;
      }).join(" | ")} |
`;
    }
    function escapeCell(s) {
      let e = "";
      const characters = s.split("");
      for (const c of characters) {
        switch (c) {
          case "\\":
            e += "\\\\";
            break;
          case "\n":
            e += "\\n";
            break;
          case "|":
            e += "\\|";
            break;
          default:
            e += c;
        }
      }
      return e;
    }
    exports2.escapeCell = escapeCell;
    function isNumeric(s) {
      return !isNaN(parseFloat(s));
    }
  }
});

// node_modules/@teppeis/multimaps/dist/src/multimap.js
var require_multimap = __commonJS({
  "node_modules/@teppeis/multimaps/dist/src/multimap.js"(exports2) {
    "use strict";
    var __generator = exports2 && exports2.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Multimap = void 0;
    var Multimap = function() {
      function Multimap2(operator, iterable) {
        var e_1, _a;
        this.size_ = 0;
        this.map = /* @__PURE__ */ new Map();
        this.operator = operator;
        if (iterable) {
          try {
            for (var iterable_1 = __values(iterable), iterable_1_1 = iterable_1.next(); !iterable_1_1.done; iterable_1_1 = iterable_1.next()) {
              var _b = __read(iterable_1_1.value, 2), key = _b[0], value = _b[1];
              this.put(key, value);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (iterable_1_1 && !iterable_1_1.done && (_a = iterable_1.return))
                _a.call(iterable_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        }
        return this;
      }
      Object.defineProperty(Multimap2.prototype, "size", {
        get: function() {
          return this.size_;
        },
        enumerable: false,
        configurable: true
      });
      Multimap2.prototype.get = function(key) {
        var values = this.map.get(key);
        if (values) {
          return this.operator.clone(values);
        } else {
          return this.operator.create();
        }
      };
      Multimap2.prototype.put = function(key, value) {
        var values = this.map.get(key);
        if (!values) {
          values = this.operator.create();
        }
        if (!this.operator.add(value, values)) {
          return false;
        }
        this.map.set(key, values);
        this.size_++;
        return true;
      };
      Multimap2.prototype.putAll = function(arg1, arg2) {
        var e_2, _a, e_3, _b;
        var pushed = 0;
        if (arg2) {
          var key = arg1;
          var values = arg2;
          try {
            for (var values_1 = __values(values), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
              var value = values_1_1.value;
              this.put(key, value);
              pushed++;
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (values_1_1 && !values_1_1.done && (_a = values_1.return))
                _a.call(values_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        } else if (arg1 instanceof Multimap2) {
          try {
            for (var _c = __values(arg1.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {
              var _e = __read(_d.value, 2), key = _e[0], value = _e[1];
              this.put(key, value);
              pushed++;
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (_d && !_d.done && (_b = _c.return))
                _b.call(_c);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
        } else {
          throw new TypeError("unexpected arguments");
        }
        return pushed > 0;
      };
      Multimap2.prototype.has = function(key) {
        return this.map.has(key);
      };
      Multimap2.prototype.hasEntry = function(key, value) {
        return this.operator.has(value, this.get(key));
      };
      Multimap2.prototype.delete = function(key) {
        this.size_ -= this.operator.size(this.get(key));
        return this.map.delete(key);
      };
      Multimap2.prototype.deleteEntry = function(key, value) {
        var current = this.get(key);
        if (!this.operator.delete(value, current)) {
          return false;
        }
        this.map.set(key, current);
        this.size_--;
        return true;
      };
      Multimap2.prototype.clear = function() {
        this.map.clear();
        this.size_ = 0;
      };
      Multimap2.prototype.keys = function() {
        return this.map.keys();
      };
      Multimap2.prototype.entries = function() {
        var self2 = this;
        function gen() {
          var _a, _b, _c, key, values, values_2, values_2_1, value, e_4_1, e_5_1;
          var e_5, _d, e_4, _e;
          return __generator(this, function(_f) {
            switch (_f.label) {
              case 0:
                _f.trys.push([0, 11, 12, 13]);
                _a = __values(self2.map.entries()), _b = _a.next();
                _f.label = 1;
              case 1:
                if (!!_b.done)
                  return [3, 10];
                _c = __read(_b.value, 2), key = _c[0], values = _c[1];
                _f.label = 2;
              case 2:
                _f.trys.push([2, 7, 8, 9]);
                values_2 = (e_4 = void 0, __values(values)), values_2_1 = values_2.next();
                _f.label = 3;
              case 3:
                if (!!values_2_1.done)
                  return [3, 6];
                value = values_2_1.value;
                return [4, [key, value]];
              case 4:
                _f.sent();
                _f.label = 5;
              case 5:
                values_2_1 = values_2.next();
                return [3, 3];
              case 6:
                return [3, 9];
              case 7:
                e_4_1 = _f.sent();
                e_4 = { error: e_4_1 };
                return [3, 9];
              case 8:
                try {
                  if (values_2_1 && !values_2_1.done && (_e = values_2.return))
                    _e.call(values_2);
                } finally {
                  if (e_4)
                    throw e_4.error;
                }
                return [7];
              case 9:
                _b = _a.next();
                return [3, 1];
              case 10:
                return [3, 13];
              case 11:
                e_5_1 = _f.sent();
                e_5 = { error: e_5_1 };
                return [3, 13];
              case 12:
                try {
                  if (_b && !_b.done && (_d = _a.return))
                    _d.call(_a);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
                return [7];
              case 13:
                return [2];
            }
          });
        }
        return gen();
      };
      Multimap2.prototype.values = function() {
        var self2 = this;
        function gen() {
          var _a, _b, _c, value, e_6_1;
          var e_6, _d;
          return __generator(this, function(_e) {
            switch (_e.label) {
              case 0:
                _e.trys.push([0, 5, 6, 7]);
                _a = __values(self2.entries()), _b = _a.next();
                _e.label = 1;
              case 1:
                if (!!_b.done)
                  return [3, 4];
                _c = __read(_b.value, 2), value = _c[1];
                return [4, value];
              case 2:
                _e.sent();
                _e.label = 3;
              case 3:
                _b = _a.next();
                return [3, 1];
              case 4:
                return [3, 7];
              case 5:
                e_6_1 = _e.sent();
                e_6 = { error: e_6_1 };
                return [3, 7];
              case 6:
                try {
                  if (_b && !_b.done && (_d = _a.return))
                    _d.call(_a);
                } finally {
                  if (e_6)
                    throw e_6.error;
                }
                return [7];
              case 7:
                return [2];
            }
          });
        }
        return gen();
      };
      Multimap2.prototype.forEach = function(callback, thisArg) {
        var e_7, _a;
        try {
          for (var _b = __values(this.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
            callback.call(thisArg === void 0 ? this : thisArg, value, key, this);
          }
        } catch (e_7_1) {
          e_7 = { error: e_7_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_7)
              throw e_7.error;
          }
        }
      };
      Multimap2.prototype[Symbol.iterator] = function() {
        return this.entries();
      };
      Multimap2.prototype.asMap = function() {
        var e_8, _a;
        var ret = /* @__PURE__ */ new Map();
        try {
          for (var _b = __values(this.keys()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var key = _c.value;
            ret.set(key, this.operator.clone(this.get(key)));
          }
        } catch (e_8_1) {
          e_8 = { error: e_8_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_8)
              throw e_8.error;
          }
        }
        return ret;
      };
      return Multimap2;
    }();
    exports2.Multimap = Multimap;
  }
});

// node_modules/@teppeis/multimaps/dist/src/arraymultimap.js
var require_arraymultimap = __commonJS({
  "node_modules/@teppeis/multimaps/dist/src/arraymultimap.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ArrayMultimap = void 0;
    var multimap_1 = require_multimap();
    var ArrayMultimap = function(_super) {
      __extends(ArrayMultimap2, _super);
      function ArrayMultimap2(iterable) {
        return _super.call(this, new ArrayOperator(), iterable) || this;
      }
      Object.defineProperty(ArrayMultimap2.prototype, Symbol.toStringTag, {
        get: function() {
          return "ArrayMultimap";
        },
        enumerable: false,
        configurable: true
      });
      return ArrayMultimap2;
    }(multimap_1.Multimap);
    exports2.ArrayMultimap = ArrayMultimap;
    var ArrayOperator = function() {
      function ArrayOperator2() {
      }
      ArrayOperator2.prototype.create = function() {
        return [];
      };
      ArrayOperator2.prototype.clone = function(collection) {
        return collection.slice();
      };
      ArrayOperator2.prototype.add = function(value, collection) {
        collection.push(value);
        return true;
      };
      ArrayOperator2.prototype.size = function(collection) {
        return collection.length;
      };
      ArrayOperator2.prototype.delete = function(value, collection) {
        var index = collection.indexOf(value);
        if (index > -1) {
          collection.splice(index, 1);
          return true;
        }
        return false;
      };
      ArrayOperator2.prototype.has = function(value, collection) {
        return collection.includes(value);
      };
      return ArrayOperator2;
    }();
  }
});

// node_modules/@teppeis/multimaps/dist/src/setmultimap.js
var require_setmultimap = __commonJS({
  "node_modules/@teppeis/multimaps/dist/src/setmultimap.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetMultimap = void 0;
    var multimap_1 = require_multimap();
    var SetMultimap = function(_super) {
      __extends(SetMultimap2, _super);
      function SetMultimap2(iterable) {
        return _super.call(this, new SetOperator(), iterable) || this;
      }
      Object.defineProperty(SetMultimap2.prototype, Symbol.toStringTag, {
        get: function() {
          return "SetMultimap";
        },
        enumerable: false,
        configurable: true
      });
      return SetMultimap2;
    }(multimap_1.Multimap);
    exports2.SetMultimap = SetMultimap;
    var SetOperator = function() {
      function SetOperator2() {
      }
      SetOperator2.prototype.create = function() {
        return /* @__PURE__ */ new Set();
      };
      SetOperator2.prototype.clone = function(collection) {
        return new Set(collection);
      };
      SetOperator2.prototype.add = function(value, collection) {
        var prev = collection.size;
        collection.add(value);
        return prev !== collection.size;
      };
      SetOperator2.prototype.size = function(collection) {
        return collection.size;
      };
      SetOperator2.prototype.delete = function(value, collection) {
        return collection.delete(value);
      };
      SetOperator2.prototype.has = function(value, collection) {
        return collection.has(value);
      };
      return SetOperator2;
    }();
  }
});

// node_modules/@teppeis/multimaps/dist/src/index.js
var require_src = __commonJS({
  "node_modules/@teppeis/multimaps/dist/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SetMultimap = exports2.ArrayMultimap = void 0;
    var arraymultimap_1 = require_arraymultimap();
    Object.defineProperty(exports2, "ArrayMultimap", { enumerable: true, get: function() {
      return arraymultimap_1.ArrayMultimap;
    } });
    var setmultimap_1 = require_setmultimap();
    Object.defineProperty(exports2, "SetMultimap", { enumerable: true, get: function() {
      return setmultimap_1.SetMultimap;
    } });
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/Query.js
var require_Query = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/Query.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var multimaps_1 = require_src();
    var Query = class {
      constructor() {
        this.sources = [];
        this.sourceByUri = /* @__PURE__ */ new Map();
        this.gherkinDocuments = [];
        this.pickles = [];
        this.locationByAstNodeId = /* @__PURE__ */ new Map();
        this.gherkinStepByAstNodeId = /* @__PURE__ */ new Map();
        this.pickleIdsMapByUri = /* @__PURE__ */ new Map();
        this.pickleIdsByAstNodeId = /* @__PURE__ */ new Map();
        this.pickleStepIdsByAstNodeId = /* @__PURE__ */ new Map();
        this.featureByUriLine = /* @__PURE__ */ new Map();
        this.backgroundByUriLine = /* @__PURE__ */ new Map();
        this.ruleByUriLine = /* @__PURE__ */ new Map();
        this.scenarioByUriLine = /* @__PURE__ */ new Map();
        this.examplesByUriLine = /* @__PURE__ */ new Map();
        this.stepByUriLine = /* @__PURE__ */ new Map();
      }
      getLocation(astNodeId) {
        return this.locationByAstNodeId.get(astNodeId);
      }
      getSources() {
        return this.sources;
      }
      getGherkinDocuments() {
        return this.gherkinDocuments;
      }
      getPickles() {
        return this.pickles;
      }
      getSource(uri) {
        return this.sourceByUri.get(uri);
      }
      getFeature(uri, line) {
        return getAstNode(this.featureByUriLine, uri, line);
      }
      getBackground(uri, line) {
        return getAstNode(this.backgroundByUriLine, uri, line);
      }
      getRule(uri, line) {
        return getAstNode(this.ruleByUriLine, uri, line);
      }
      getScenario(uri, line) {
        return getAstNode(this.scenarioByUriLine, uri, line);
      }
      getExamples(uri, line) {
        return getAstNode(this.examplesByUriLine, uri, line);
      }
      getStep(uri, line) {
        return getAstNode(this.stepByUriLine, uri, line);
      }
      getPickleIds(uri, astNodeId) {
        const pickleIdsByAstNodeId = this.pickleIdsMapByUri.get(uri);
        if (!pickleIdsByAstNodeId) {
          throw new Error(`No pickleIds for uri=${uri}`);
        }
        return astNodeId === void 0 ? Array.from(new Set(pickleIdsByAstNodeId.values())) : pickleIdsByAstNodeId.get(astNodeId);
      }
      getPickleStepIds(astNodeId) {
        return this.pickleStepIdsByAstNodeId.get(astNodeId) || [];
      }
      update(message) {
        if (message.source) {
          this.sources.push(message.source);
          this.sourceByUri.set(message.source.uri, message.source);
        }
        if (message.gherkinDocument) {
          this.gherkinDocuments.push(message.gherkinDocument);
          if (message.gherkinDocument.feature) {
            this.updateGherkinFeature(message.gherkinDocument.uri, message.gherkinDocument.feature);
          }
        }
        if (message.pickle) {
          const pickle = message.pickle;
          this.updatePickle(pickle);
        }
        return this;
      }
      updateGherkinFeature(uri, feature) {
        setAstNode(this.featureByUriLine, uri, feature);
        this.pickleIdsMapByUri.set(uri, new multimaps_1.ArrayMultimap());
        for (const featureChild of feature.children) {
          if (featureChild.background) {
            this.updateGherkinBackground(uri, featureChild.background);
          }
          if (featureChild.scenario) {
            this.updateGherkinScenario(uri, featureChild.scenario);
          }
          if (featureChild.rule) {
            this.updateGherkinRule(uri, featureChild.rule);
          }
        }
      }
      updateGherkinBackground(uri, background) {
        setAstNode(this.backgroundByUriLine, uri, background);
        for (const step of background.steps) {
          this.updateGherkinStep(uri, step);
        }
      }
      updateGherkinRule(uri, rule) {
        setAstNode(this.ruleByUriLine, uri, rule);
        for (const ruleChild of rule.children) {
          if (ruleChild.background) {
            this.updateGherkinBackground(uri, ruleChild.background);
          }
          if (ruleChild.scenario) {
            this.updateGherkinScenario(uri, ruleChild.scenario);
          }
        }
      }
      updateGherkinScenario(uri, scenario) {
        setAstNode(this.scenarioByUriLine, uri, scenario);
        this.locationByAstNodeId.set(scenario.id, scenario.location);
        for (const step of scenario.steps) {
          this.updateGherkinStep(uri, step);
        }
        for (const examples of scenario.examples) {
          this.updateGherkinExamples(uri, examples);
        }
      }
      updateGherkinExamples(uri, examples) {
        setAstNode(this.examplesByUriLine, uri, examples);
        for (const tableRow of examples.tableBody || []) {
          this.locationByAstNodeId.set(tableRow.id, tableRow.location);
        }
      }
      updateGherkinStep(uri, step) {
        setAstNode(this.stepByUriLine, uri, step);
        this.locationByAstNodeId.set(step.id, step.location);
        this.gherkinStepByAstNodeId.set(step.id, step);
      }
      updatePickle(pickle) {
        const pickleIdsByLineNumber = this.pickleIdsMapByUri.get(pickle.uri);
        for (const astNodeId of pickle.astNodeIds) {
          pickleIdsByLineNumber.put(astNodeId, pickle.id);
        }
        this.updatePickleSteps(pickle);
        this.pickles.push(pickle);
        for (const astNodeId of pickle.astNodeIds) {
          if (!this.pickleIdsByAstNodeId.has(astNodeId)) {
            this.pickleIdsByAstNodeId.set(astNodeId, []);
          }
          this.pickleIdsByAstNodeId.get(astNodeId).push(pickle.id);
        }
      }
      updatePickleSteps(pickle) {
        const pickleSteps = pickle.steps;
        for (const pickleStep of pickleSteps) {
          for (const astNodeId of pickleStep.astNodeIds) {
            if (!this.pickleStepIdsByAstNodeId.has(astNodeId)) {
              this.pickleStepIdsByAstNodeId.set(astNodeId, []);
            }
            this.pickleStepIdsByAstNodeId.get(astNodeId).push(pickleStep.id);
          }
        }
      }
    };
    exports2.default = Query;
    function setAstNode(map, uri, astNode) {
      const line = astNode.location.line;
      const uriLine = [uri, line].join(":");
      map.set(uriLine, astNode);
    }
    function getAstNode(map, uri, line) {
      const uriLine = [uri, line].join(":");
      return map.get(uriLine);
    }
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/GherkinDocumentWalker.js
var require_GherkinDocumentWalker = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/GherkinDocumentWalker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rejectAllFilters = void 0;
    var defaultFilters = {
      acceptScenario: () => true,
      acceptStep: () => true,
      acceptBackground: () => true,
      acceptRule: () => true,
      acceptFeature: () => true
    };
    exports2.rejectAllFilters = {
      acceptScenario: () => false,
      acceptStep: () => false,
      acceptBackground: () => false,
      acceptRule: () => false,
      acceptFeature: () => false
    };
    var defaultHandlers = {
      handleStep: () => null,
      handleScenario: () => null,
      handleBackground: () => null,
      handleRule: () => null,
      handleFeature: () => null
    };
    var GherkinDocumentWalker = class {
      constructor(filters, handlers) {
        this.filters = Object.assign(Object.assign({}, defaultFilters), filters);
        this.handlers = Object.assign(Object.assign({}, defaultHandlers), handlers);
      }
      walkGherkinDocument(gherkinDocument) {
        if (!gherkinDocument.feature) {
          return null;
        }
        const feature = this.walkFeature(gherkinDocument.feature);
        if (!feature) {
          return null;
        }
        return {
          feature,
          comments: gherkinDocument.comments,
          uri: gherkinDocument.uri
        };
      }
      walkFeature(feature) {
        const keptChildren = this.walkFeatureChildren(feature.children);
        this.handlers.handleFeature(feature);
        const backgroundKept = keptChildren.find((child) => child.background);
        if (this.filters.acceptFeature(feature) || backgroundKept) {
          return this.copyFeature(feature, feature.children.map((child) => {
            if (child.background) {
              return {
                background: this.copyBackground(child.background)
              };
            }
            if (child.scenario) {
              return {
                scenario: this.copyScenario(child.scenario)
              };
            }
            if (child.rule) {
              return {
                rule: this.copyRule(child.rule, child.rule.children)
              };
            }
          }));
        }
        if (keptChildren.find((child) => child !== null)) {
          return this.copyFeature(feature, keptChildren);
        }
      }
      copyFeature(feature, children) {
        return {
          children: this.filterFeatureChildren(feature, children),
          location: feature.location,
          language: feature.language,
          keyword: feature.keyword,
          name: feature.name,
          description: feature.description,
          tags: this.copyTags(feature.tags)
        };
      }
      copyTags(tags) {
        return tags.map((tag) => ({
          name: tag.name,
          id: tag.id,
          location: tag.location
        }));
      }
      filterFeatureChildren(feature, children) {
        const copyChildren = [];
        const scenariosKeptById = new Map(children.filter((child) => child.scenario).map((child) => [child.scenario.id, child]));
        const ruleKeptById = new Map(children.filter((child) => child.rule).map((child) => [child.rule.id, child]));
        for (const child of feature.children) {
          if (child.background) {
            copyChildren.push({
              background: this.copyBackground(child.background)
            });
          }
          if (child.scenario) {
            const scenarioCopy = scenariosKeptById.get(child.scenario.id);
            if (scenarioCopy) {
              copyChildren.push(scenarioCopy);
            }
          }
          if (child.rule) {
            const ruleCopy = ruleKeptById.get(child.rule.id);
            if (ruleCopy) {
              copyChildren.push(ruleCopy);
            }
          }
        }
        return copyChildren;
      }
      walkFeatureChildren(children) {
        const childrenCopy = [];
        for (const child of children) {
          let backgroundCopy = null;
          let scenarioCopy = null;
          let ruleCopy = null;
          if (child.background) {
            backgroundCopy = this.walkBackground(child.background);
          }
          if (child.scenario) {
            scenarioCopy = this.walkScenario(child.scenario);
          }
          if (child.rule) {
            ruleCopy = this.walkRule(child.rule);
          }
          if (backgroundCopy || scenarioCopy || ruleCopy) {
            childrenCopy.push({
              background: backgroundCopy,
              scenario: scenarioCopy,
              rule: ruleCopy
            });
          }
        }
        return childrenCopy;
      }
      walkRule(rule) {
        const children = this.walkRuleChildren(rule.children);
        this.handlers.handleRule(rule);
        const backgroundKept = children.find((child) => child !== null && child.background !== null);
        const scenariosKept = children.filter((child) => child !== null && child.scenario !== null);
        if (this.filters.acceptRule(rule) || backgroundKept) {
          return this.copyRule(rule, rule.children);
        }
        if (scenariosKept.length > 0) {
          return this.copyRule(rule, scenariosKept);
        }
      }
      copyRule(rule, children) {
        return {
          id: rule.id,
          name: rule.name,
          description: rule.description,
          location: rule.location,
          keyword: rule.keyword,
          children: this.filterRuleChildren(rule.children, children),
          tags: this.copyTags(rule.tags)
        };
      }
      filterRuleChildren(children, childrenKept) {
        const childrenCopy = [];
        const scenariosKeptIds = childrenKept.filter((child) => child.scenario).map((child) => child.scenario.id);
        for (const child of children) {
          if (child.background) {
            childrenCopy.push({
              background: this.copyBackground(child.background)
            });
          }
          if (child.scenario && scenariosKeptIds.includes(child.scenario.id)) {
            childrenCopy.push({
              scenario: this.copyScenario(child.scenario)
            });
          }
        }
        return childrenCopy;
      }
      walkRuleChildren(children) {
        const childrenCopy = [];
        for (const child of children) {
          if (child.background) {
            childrenCopy.push({
              background: this.walkBackground(child.background)
            });
          }
          if (child.scenario) {
            childrenCopy.push({
              scenario: this.walkScenario(child.scenario)
            });
          }
        }
        return childrenCopy;
      }
      walkBackground(background) {
        const steps = this.walkAllSteps(background.steps);
        this.handlers.handleBackground(background);
        if (this.filters.acceptBackground(background) || steps.find((step) => step !== null)) {
          return this.copyBackground(background);
        }
      }
      copyBackground(background) {
        return {
          id: background.id,
          name: background.name,
          location: background.location,
          keyword: background.keyword,
          steps: background.steps.map((step) => this.copyStep(step)),
          description: background.description
        };
      }
      walkScenario(scenario) {
        const steps = this.walkAllSteps(scenario.steps);
        this.handlers.handleScenario(scenario);
        if (this.filters.acceptScenario(scenario) || steps.find((step) => step !== null)) {
          return this.copyScenario(scenario);
        }
      }
      copyScenario(scenario) {
        return {
          id: scenario.id,
          name: scenario.name,
          description: scenario.description,
          location: scenario.location,
          keyword: scenario.keyword,
          examples: scenario.examples,
          steps: scenario.steps.map((step) => this.copyStep(step)),
          tags: this.copyTags(scenario.tags)
        };
      }
      walkAllSteps(steps) {
        return steps.map((step) => this.walkStep(step));
      }
      walkStep(step) {
        this.handlers.handleStep(step);
        if (!this.filters.acceptStep(step)) {
          return null;
        }
        return this.copyStep(step);
      }
      copyStep(step) {
        return {
          id: step.id,
          keyword: step.keyword,
          keywordType: step.keywordType,
          location: step.location,
          text: step.text,
          dataTable: step.dataTable,
          docString: step.docString
        };
      }
    };
    exports2.default = GherkinDocumentWalker;
  }
});

// node_modules/@cucumber/gherkin-utils/dist/src/index.js
var require_src2 = __commonJS({
  "node_modules/@cucumber/gherkin-utils/dist/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rejectAllFilters = exports2.GherkinDocumentWalker = exports2.Query = exports2.pretty = void 0;
    __exportStar(require_walkGherkinDocument(), exports2);
    __exportStar(require_GherkinDocumentHandlers(), exports2);
    var pretty_1 = __importDefault(require_pretty());
    exports2.pretty = pretty_1.default;
    var Query_1 = __importDefault(require_Query());
    exports2.Query = Query_1.default;
    var GherkinDocumentWalker_1 = __importStar(require_GherkinDocumentWalker());
    exports2.GherkinDocumentWalker = GherkinDocumentWalker_1.default;
    Object.defineProperty(exports2, "rejectAllFilters", { enumerable: true, get: function() {
      return GherkinDocumentWalker_1.rejectAllFilters;
    } });
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/gherkin/extractStepTexts.js
var require_extractStepTexts = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/gherkin/extractStepTexts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.extractStepTexts = void 0;
    var gherkin_utils_1 = require_src2();
    function extractStepTexts(gherkinDocument, stepTexts) {
      return (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, stepTexts, {
        step: function(step, arr) {
          return arr.concat(step.text);
        }
      });
    }
    exports2.extractStepTexts = extractStepTexts;
  }
});

// node_modules/@cucumber/gherkin/dist/src/Errors.js
var require_Errors = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/Errors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NoSuchLanguageException = exports2.AstBuilderException = exports2.CompositeParserException = exports2.ParserException = exports2.GherkinException = void 0;
    var GherkinException = class extends Error {
      constructor(message) {
        super(message);
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
      }
      static _create(message, location) {
        const column = location != null ? location.column || 0 : -1;
        const line = location != null ? location.line || 0 : -1;
        const m = `(${line}:${column}): ${message}`;
        const err = new this(m);
        err.location = location;
        return err;
      }
    };
    exports2.GherkinException = GherkinException;
    var ParserException = class extends GherkinException {
      static create(message, line, column) {
        const err = new this(`(${line}:${column}): ${message}`);
        err.location = { line, column };
        return err;
      }
    };
    exports2.ParserException = ParserException;
    var CompositeParserException = class extends GherkinException {
      static create(errors) {
        const message = "Parser errors:\n" + errors.map((e) => e.message).join("\n");
        const err = new this(message);
        err.errors = errors;
        return err;
      }
    };
    exports2.CompositeParserException = CompositeParserException;
    var AstBuilderException = class extends GherkinException {
      static create(message, location) {
        return this._create(message, location);
      }
    };
    exports2.AstBuilderException = AstBuilderException;
    var NoSuchLanguageException = class extends GherkinException {
      static create(language, location) {
        const message = "Language not supported: " + language;
        return this._create(message, location);
      }
    };
    exports2.NoSuchLanguageException = NoSuchLanguageException;
  }
});

// node_modules/@cucumber/gherkin/dist/src/TokenExceptions.js
var require_TokenExceptions = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/TokenExceptions.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.UnexpectedEOFException = exports2.UnexpectedTokenException = void 0;
    var Errors_1 = require_Errors();
    var UnexpectedTokenException = class extends Errors_1.GherkinException {
      static create(token, expectedTokenTypes) {
        const message = `expected: ${expectedTokenTypes.join(", ")}, got '${token.getTokenValue().trim()}'`;
        const location = tokenLocation(token);
        return this._create(message, location);
      }
    };
    exports2.UnexpectedTokenException = UnexpectedTokenException;
    var UnexpectedEOFException = class extends Errors_1.GherkinException {
      static create(token, expectedTokenTypes) {
        const message = `unexpected end of file, expected: ${expectedTokenTypes.join(", ")}`;
        const location = tokenLocation(token);
        return this._create(message, location);
      }
    };
    exports2.UnexpectedEOFException = UnexpectedEOFException;
    function tokenLocation(token) {
      return token.location && token.location.line && token.line && token.line.indent !== void 0 ? {
        line: token.location.line,
        column: token.line.indent + 1
      } : token.location;
    }
  }
});

// node_modules/@cucumber/gherkin/dist/src/TokenScanner.js
var require_TokenScanner = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/TokenScanner.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var TokenScanner = class {
      constructor(source, makeToken) {
        this.makeToken = makeToken;
        this.lineNumber = 0;
        this.lines = source.split(/\r?\n/);
        if (this.lines.length > 0 && this.lines[this.lines.length - 1].trim() === "") {
          this.lines.pop();
        }
      }
      read() {
        const line = this.lines[this.lineNumber++];
        const location = {
          line: this.lineNumber
        };
        return this.makeToken(line, location);
      }
    };
    exports2.default = TokenScanner;
  }
});

// node_modules/@cucumber/gherkin/dist/src/countSymbols.js
var require_countSymbols = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/countSymbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    function countSymbols(s) {
      return s.replace(regexAstralSymbols, "_").length;
    }
    exports2.default = countSymbols;
  }
});

// node_modules/@cucumber/gherkin/dist/src/GherkinLine.js
var require_GherkinLine = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/GherkinLine.js"(exports2, module2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var countSymbols_1 = __importDefault(require_countSymbols());
    var GherkinLine = class {
      constructor(lineText, lineNumber) {
        this.lineText = lineText;
        this.lineNumber = lineNumber;
        this.trimmedLineText = lineText.replace(/^\s+/g, "");
        this.isEmpty = this.trimmedLineText.length === 0;
        this.indent = (0, countSymbols_1.default)(lineText) - (0, countSymbols_1.default)(this.trimmedLineText);
      }
      startsWith(prefix) {
        return this.trimmedLineText.indexOf(prefix) === 0;
      }
      startsWithTitleKeyword(keyword) {
        return this.startsWith(keyword + ":");
      }
      match(regexp) {
        return this.trimmedLineText.match(regexp);
      }
      getLineText(indentToRemove) {
        if (indentToRemove < 0 || indentToRemove > this.indent) {
          return this.trimmedLineText;
        } else {
          return this.lineText.substring(indentToRemove);
        }
      }
      getRestTrimmed(length) {
        return this.trimmedLineText.substring(length).trim();
      }
      getTableCells() {
        const cells = [];
        let col = 0;
        let startCol = col + 1;
        let cell = "";
        let firstCell = true;
        while (col < this.trimmedLineText.length) {
          let chr = this.trimmedLineText[col];
          col++;
          if (chr === "|") {
            if (firstCell) {
              firstCell = false;
            } else {
              const trimmedLeft = cell.replace(/^[ \t\v\f\r\u0085\u00A0]*/g, "");
              const trimmed = trimmedLeft.replace(/[ \t\v\f\r\u0085\u00A0]*$/g, "");
              const cellIndent = cell.length - trimmedLeft.length;
              const span = {
                column: this.indent + startCol + cellIndent,
                text: trimmed
              };
              cells.push(span);
            }
            cell = "";
            startCol = col + 1;
          } else if (chr === "\\") {
            chr = this.trimmedLineText[col];
            col += 1;
            if (chr === "n") {
              cell += "\n";
            } else {
              if (chr !== "|" && chr !== "\\") {
                cell += "\\";
              }
              cell += chr;
            }
          } else {
            cell += chr;
          }
        }
        return cells;
      }
    };
    exports2.default = GherkinLine;
    module2.exports = GherkinLine;
  }
});

// node_modules/@cucumber/gherkin/dist/src/Parser.js
var require_Parser = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/Parser.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RuleType = exports2.TokenType = exports2.Token = void 0;
    var Errors_1 = require_Errors();
    var TokenExceptions_1 = require_TokenExceptions();
    var TokenScanner_1 = __importDefault(require_TokenScanner());
    var GherkinLine_1 = __importDefault(require_GherkinLine());
    var Token = class {
      constructor(line, location) {
        this.line = line;
        this.location = location;
        this.isEof = !line;
      }
      getTokenValue() {
        return this.isEof ? "EOF" : this.line.getLineText(-1);
      }
      detach() {
      }
    };
    exports2.Token = Token;
    var TokenType;
    (function(TokenType2) {
      TokenType2[TokenType2["None"] = 0] = "None";
      TokenType2[TokenType2["EOF"] = 1] = "EOF";
      TokenType2[TokenType2["Empty"] = 2] = "Empty";
      TokenType2[TokenType2["Comment"] = 3] = "Comment";
      TokenType2[TokenType2["TagLine"] = 4] = "TagLine";
      TokenType2[TokenType2["FeatureLine"] = 5] = "FeatureLine";
      TokenType2[TokenType2["RuleLine"] = 6] = "RuleLine";
      TokenType2[TokenType2["BackgroundLine"] = 7] = "BackgroundLine";
      TokenType2[TokenType2["ScenarioLine"] = 8] = "ScenarioLine";
      TokenType2[TokenType2["ExamplesLine"] = 9] = "ExamplesLine";
      TokenType2[TokenType2["StepLine"] = 10] = "StepLine";
      TokenType2[TokenType2["DocStringSeparator"] = 11] = "DocStringSeparator";
      TokenType2[TokenType2["TableRow"] = 12] = "TableRow";
      TokenType2[TokenType2["Language"] = 13] = "Language";
      TokenType2[TokenType2["Other"] = 14] = "Other";
    })(TokenType = exports2.TokenType || (exports2.TokenType = {}));
    var RuleType;
    (function(RuleType2) {
      RuleType2[RuleType2["None"] = 0] = "None";
      RuleType2[RuleType2["_EOF"] = 1] = "_EOF";
      RuleType2[RuleType2["_Empty"] = 2] = "_Empty";
      RuleType2[RuleType2["_Comment"] = 3] = "_Comment";
      RuleType2[RuleType2["_TagLine"] = 4] = "_TagLine";
      RuleType2[RuleType2["_FeatureLine"] = 5] = "_FeatureLine";
      RuleType2[RuleType2["_RuleLine"] = 6] = "_RuleLine";
      RuleType2[RuleType2["_BackgroundLine"] = 7] = "_BackgroundLine";
      RuleType2[RuleType2["_ScenarioLine"] = 8] = "_ScenarioLine";
      RuleType2[RuleType2["_ExamplesLine"] = 9] = "_ExamplesLine";
      RuleType2[RuleType2["_StepLine"] = 10] = "_StepLine";
      RuleType2[RuleType2["_DocStringSeparator"] = 11] = "_DocStringSeparator";
      RuleType2[RuleType2["_TableRow"] = 12] = "_TableRow";
      RuleType2[RuleType2["_Language"] = 13] = "_Language";
      RuleType2[RuleType2["_Other"] = 14] = "_Other";
      RuleType2[RuleType2["GherkinDocument"] = 15] = "GherkinDocument";
      RuleType2[RuleType2["Feature"] = 16] = "Feature";
      RuleType2[RuleType2["FeatureHeader"] = 17] = "FeatureHeader";
      RuleType2[RuleType2["Rule"] = 18] = "Rule";
      RuleType2[RuleType2["RuleHeader"] = 19] = "RuleHeader";
      RuleType2[RuleType2["Background"] = 20] = "Background";
      RuleType2[RuleType2["ScenarioDefinition"] = 21] = "ScenarioDefinition";
      RuleType2[RuleType2["Scenario"] = 22] = "Scenario";
      RuleType2[RuleType2["ExamplesDefinition"] = 23] = "ExamplesDefinition";
      RuleType2[RuleType2["Examples"] = 24] = "Examples";
      RuleType2[RuleType2["ExamplesTable"] = 25] = "ExamplesTable";
      RuleType2[RuleType2["Step"] = 26] = "Step";
      RuleType2[RuleType2["StepArg"] = 27] = "StepArg";
      RuleType2[RuleType2["DataTable"] = 28] = "DataTable";
      RuleType2[RuleType2["DocString"] = 29] = "DocString";
      RuleType2[RuleType2["Tags"] = 30] = "Tags";
      RuleType2[RuleType2["DescriptionHelper"] = 31] = "DescriptionHelper";
      RuleType2[RuleType2["Description"] = 32] = "Description";
    })(RuleType = exports2.RuleType || (exports2.RuleType = {}));
    var Parser = class {
      constructor(builder, tokenMatcher) {
        this.builder = builder;
        this.tokenMatcher = tokenMatcher;
        this.stopAtFirstError = false;
      }
      parse(gherkinSource) {
        const tokenScanner = new TokenScanner_1.default(gherkinSource, (line, location) => {
          const gherkinLine = line === null || line === void 0 ? null : new GherkinLine_1.default(line, location.line);
          return new Token(gherkinLine, location);
        });
        this.builder.reset();
        this.tokenMatcher.reset();
        this.context = {
          tokenScanner,
          tokenQueue: [],
          errors: []
        };
        this.startRule(this.context, RuleType.GherkinDocument);
        let state = 0;
        let token = null;
        while (true) {
          token = this.readToken(this.context);
          state = this.matchToken(state, token, this.context);
          if (token.isEof)
            break;
        }
        this.endRule(this.context);
        if (this.context.errors.length > 0) {
          throw Errors_1.CompositeParserException.create(this.context.errors);
        }
        return this.getResult();
      }
      addError(context, error) {
        if (!context.errors.map((e) => {
          return e.message;
        }).includes(error.message)) {
          context.errors.push(error);
          if (context.errors.length > 10)
            throw Errors_1.CompositeParserException.create(context.errors);
        }
      }
      startRule(context, ruleType) {
        this.handleAstError(context, () => this.builder.startRule(ruleType));
      }
      endRule(context) {
        this.handleAstError(context, () => this.builder.endRule());
      }
      build(context, token) {
        this.handleAstError(context, () => this.builder.build(token));
      }
      getResult() {
        return this.builder.getResult();
      }
      handleAstError(context, action) {
        this.handleExternalError(context, true, action);
      }
      handleExternalError(context, defaultValue, action) {
        if (this.stopAtFirstError)
          return action();
        try {
          return action();
        } catch (e) {
          if (e instanceof Errors_1.CompositeParserException) {
            e.errors.forEach((error) => this.addError(context, error));
          } else if (e instanceof Errors_1.ParserException || e instanceof Errors_1.AstBuilderException || e instanceof TokenExceptions_1.UnexpectedTokenException || e instanceof Errors_1.NoSuchLanguageException) {
            this.addError(context, e);
          } else {
            throw e;
          }
        }
        return defaultValue;
      }
      readToken(context) {
        return context.tokenQueue.length > 0 ? context.tokenQueue.shift() : context.tokenScanner.read();
      }
      matchToken(state, token, context) {
        switch (state) {
          case 0:
            return this.matchTokenAt_0(token, context);
          case 1:
            return this.matchTokenAt_1(token, context);
          case 2:
            return this.matchTokenAt_2(token, context);
          case 3:
            return this.matchTokenAt_3(token, context);
          case 4:
            return this.matchTokenAt_4(token, context);
          case 5:
            return this.matchTokenAt_5(token, context);
          case 6:
            return this.matchTokenAt_6(token, context);
          case 7:
            return this.matchTokenAt_7(token, context);
          case 8:
            return this.matchTokenAt_8(token, context);
          case 9:
            return this.matchTokenAt_9(token, context);
          case 10:
            return this.matchTokenAt_10(token, context);
          case 11:
            return this.matchTokenAt_11(token, context);
          case 12:
            return this.matchTokenAt_12(token, context);
          case 13:
            return this.matchTokenAt_13(token, context);
          case 14:
            return this.matchTokenAt_14(token, context);
          case 15:
            return this.matchTokenAt_15(token, context);
          case 16:
            return this.matchTokenAt_16(token, context);
          case 17:
            return this.matchTokenAt_17(token, context);
          case 18:
            return this.matchTokenAt_18(token, context);
          case 19:
            return this.matchTokenAt_19(token, context);
          case 20:
            return this.matchTokenAt_20(token, context);
          case 21:
            return this.matchTokenAt_21(token, context);
          case 22:
            return this.matchTokenAt_22(token, context);
          case 23:
            return this.matchTokenAt_23(token, context);
          case 24:
            return this.matchTokenAt_24(token, context);
          case 25:
            return this.matchTokenAt_25(token, context);
          case 26:
            return this.matchTokenAt_26(token, context);
          case 27:
            return this.matchTokenAt_27(token, context);
          case 28:
            return this.matchTokenAt_28(token, context);
          case 29:
            return this.matchTokenAt_29(token, context);
          case 30:
            return this.matchTokenAt_30(token, context);
          case 31:
            return this.matchTokenAt_31(token, context);
          case 32:
            return this.matchTokenAt_32(token, context);
          case 33:
            return this.matchTokenAt_33(token, context);
          case 34:
            return this.matchTokenAt_34(token, context);
          case 35:
            return this.matchTokenAt_35(token, context);
          case 36:
            return this.matchTokenAt_36(token, context);
          case 37:
            return this.matchTokenAt_37(token, context);
          case 38:
            return this.matchTokenAt_38(token, context);
          case 39:
            return this.matchTokenAt_39(token, context);
          case 40:
            return this.matchTokenAt_40(token, context);
          case 41:
            return this.matchTokenAt_41(token, context);
          case 43:
            return this.matchTokenAt_43(token, context);
          case 44:
            return this.matchTokenAt_44(token, context);
          case 45:
            return this.matchTokenAt_45(token, context);
          case 46:
            return this.matchTokenAt_46(token, context);
          case 47:
            return this.matchTokenAt_47(token, context);
          case 48:
            return this.matchTokenAt_48(token, context);
          case 49:
            return this.matchTokenAt_49(token, context);
          case 50:
            return this.matchTokenAt_50(token, context);
          default:
            throw new Error("Unknown state: " + state);
        }
      }
      matchTokenAt_0(token, context) {
        if (this.match_EOF(context, token)) {
          this.build(context, token);
          return 42;
        }
        if (this.match_Language(context, token)) {
          this.startRule(context, RuleType.Feature);
          this.startRule(context, RuleType.FeatureHeader);
          this.build(context, token);
          return 1;
        }
        if (this.match_TagLine(context, token)) {
          this.startRule(context, RuleType.Feature);
          this.startRule(context, RuleType.FeatureHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 2;
        }
        if (this.match_FeatureLine(context, token)) {
          this.startRule(context, RuleType.Feature);
          this.startRule(context, RuleType.FeatureHeader);
          this.build(context, token);
          return 3;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 0;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 0;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Language", "#TagLine", "#FeatureLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 0;
      }
      matchTokenAt_1(token, context) {
        if (this.match_TagLine(context, token)) {
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 2;
        }
        if (this.match_FeatureLine(context, token)) {
          this.build(context, token);
          return 3;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 1;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 1;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#FeatureLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 1;
      }
      matchTokenAt_2(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 2;
        }
        if (this.match_FeatureLine(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 3;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 2;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 2;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#FeatureLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 2;
      }
      matchTokenAt_3(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 3;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 6;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 4;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 3;
      }
      matchTokenAt_4(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 6;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 4;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 4;
      }
      matchTokenAt_5(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 5;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 6;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 5;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 5;
      }
      matchTokenAt_6(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 6;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 8;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 7;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 6;
      }
      matchTokenAt_7(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 8;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 7;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 7;
      }
      matchTokenAt_8(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 8;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 8;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 8;
      }
      matchTokenAt_9(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.DataTable);
          this.build(context, token);
          return 10;
        }
        if (this.match_DocStringSeparator(context, token)) {
          this.startRule(context, RuleType.DocString);
          this.build(context, token);
          return 49;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 9;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 9;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#DocStringSeparator", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 9;
      }
      matchTokenAt_10(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 10;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 10;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 10;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 10;
      }
      matchTokenAt_11(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 11;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 11;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 11;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#ScenarioLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 11;
      }
      matchTokenAt_12(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 12;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 14;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 13;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 12;
      }
      matchTokenAt_13(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 14;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 13;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 13;
      }
      matchTokenAt_14(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 14;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 14;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 14;
      }
      matchTokenAt_15(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.DataTable);
          this.build(context, token);
          return 16;
        }
        if (this.match_DocStringSeparator(context, token)) {
          this.startRule(context, RuleType.DocString);
          this.build(context, token);
          return 47;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 15;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 15;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#DocStringSeparator", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 15;
      }
      matchTokenAt_16(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 16;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 16;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 16;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 16;
      }
      matchTokenAt_17(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 17;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 17;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 17;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#ExamplesLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 17;
      }
      matchTokenAt_18(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 18;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 20;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 21;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 19;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 18;
      }
      matchTokenAt_19(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 20;
        }
        if (this.match_TableRow(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 21;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 19;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 19;
      }
      matchTokenAt_20(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 20;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 21;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 20;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 20;
      }
      matchTokenAt_21(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 21;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 21;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 21;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 21;
      }
      matchTokenAt_22(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 22;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 22;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 22;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 22;
      }
      matchTokenAt_23(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 25;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 26;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 24;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 23;
      }
      matchTokenAt_24(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 25;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 26;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 24;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 24;
      }
      matchTokenAt_25(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 25;
        }
        if (this.match_BackgroundLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Background);
          this.build(context, token);
          return 26;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 25;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#BackgroundLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 25;
      }
      matchTokenAt_26(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 26;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 28;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 27;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 26;
      }
      matchTokenAt_27(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 28;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 27;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 27;
      }
      matchTokenAt_28(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 28;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 28;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 28;
      }
      matchTokenAt_29(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.DataTable);
          this.build(context, token);
          return 30;
        }
        if (this.match_DocStringSeparator(context, token)) {
          this.startRule(context, RuleType.DocString);
          this.build(context, token);
          return 45;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 29;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 29;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#DocStringSeparator", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 29;
      }
      matchTokenAt_30(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 30;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 30;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 30;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 30;
      }
      matchTokenAt_31(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 31;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 31;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 31;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#ScenarioLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 31;
      }
      matchTokenAt_32(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 32;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 34;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 33;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 32;
      }
      matchTokenAt_33(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 34;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 33;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 33;
      }
      matchTokenAt_34(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 34;
        }
        if (this.match_StepLine(context, token)) {
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 34;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 34;
      }
      matchTokenAt_35(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.DataTable);
          this.build(context, token);
          return 36;
        }
        if (this.match_DocStringSeparator(context, token)) {
          this.startRule(context, RuleType.DocString);
          this.build(context, token);
          return 43;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 35;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 35;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#DocStringSeparator", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 35;
      }
      matchTokenAt_36(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 36;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 36;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 36;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 36;
      }
      matchTokenAt_37(token, context) {
        if (this.match_TagLine(context, token)) {
          this.build(context, token);
          return 37;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 37;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 37;
        }
        token.detach();
        const expectedTokens = ["#TagLine", "#ExamplesLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 37;
      }
      matchTokenAt_38(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 38;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 40;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 41;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.startRule(context, RuleType.Description);
          this.build(context, token);
          return 39;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Empty", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 38;
      }
      matchTokenAt_39(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.endRule(context);
          this.build(context, token);
          return 40;
        }
        if (this.match_TableRow(context, token)) {
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 41;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 39;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 39;
      }
      matchTokenAt_40(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 40;
        }
        if (this.match_TableRow(context, token)) {
          this.startRule(context, RuleType.ExamplesTable);
          this.build(context, token);
          return 41;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 40;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#Comment", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 40;
      }
      matchTokenAt_41(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_TableRow(context, token)) {
          this.build(context, token);
          return 41;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 41;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 41;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#TableRow", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 41;
      }
      matchTokenAt_43(token, context) {
        if (this.match_DocStringSeparator(context, token)) {
          this.build(context, token);
          return 44;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 43;
        }
        token.detach();
        const expectedTokens = ["#DocStringSeparator", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 43;
      }
      matchTokenAt_44(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 35;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 37;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 38;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 44;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 44;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 44;
      }
      matchTokenAt_45(token, context) {
        if (this.match_DocStringSeparator(context, token)) {
          this.build(context, token);
          return 46;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 45;
        }
        token.detach();
        const expectedTokens = ["#DocStringSeparator", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 45;
      }
      matchTokenAt_46(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 29;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 31;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 32;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 46;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 46;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 46;
      }
      matchTokenAt_47(token, context) {
        if (this.match_DocStringSeparator(context, token)) {
          this.build(context, token);
          return 48;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 47;
        }
        token.detach();
        const expectedTokens = ["#DocStringSeparator", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 47;
      }
      matchTokenAt_48(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 15;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_1(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ExamplesDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 17;
          }
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ExamplesLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ExamplesDefinition);
          this.startRule(context, RuleType.Examples);
          this.build(context, token);
          return 18;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 48;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 48;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#StepLine", "#TagLine", "#ExamplesLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 48;
      }
      matchTokenAt_49(token, context) {
        if (this.match_DocStringSeparator(context, token)) {
          this.build(context, token);
          return 50;
        }
        if (this.match_Other(context, token)) {
          this.build(context, token);
          return 49;
        }
        token.detach();
        const expectedTokens = ["#DocStringSeparator", "#Other"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 49;
      }
      matchTokenAt_50(token, context) {
        if (this.match_EOF(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.build(context, token);
          return 42;
        }
        if (this.match_StepLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Step);
          this.build(context, token);
          return 9;
        }
        if (this.match_TagLine(context, token)) {
          if (this.lookahead_0(context, token)) {
            this.endRule(context);
            this.endRule(context);
            this.endRule(context);
            this.startRule(context, RuleType.ScenarioDefinition);
            this.startRule(context, RuleType.Tags);
            this.build(context, token);
            return 11;
          }
        }
        if (this.match_TagLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.startRule(context, RuleType.Tags);
          this.build(context, token);
          return 22;
        }
        if (this.match_ScenarioLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.ScenarioDefinition);
          this.startRule(context, RuleType.Scenario);
          this.build(context, token);
          return 12;
        }
        if (this.match_RuleLine(context, token)) {
          this.endRule(context);
          this.endRule(context);
          this.endRule(context);
          this.startRule(context, RuleType.Rule);
          this.startRule(context, RuleType.RuleHeader);
          this.build(context, token);
          return 23;
        }
        if (this.match_Comment(context, token)) {
          this.build(context, token);
          return 50;
        }
        if (this.match_Empty(context, token)) {
          this.build(context, token);
          return 50;
        }
        token.detach();
        const expectedTokens = ["#EOF", "#StepLine", "#TagLine", "#ScenarioLine", "#RuleLine", "#Comment", "#Empty"];
        const error = token.isEof ? TokenExceptions_1.UnexpectedEOFException.create(token, expectedTokens) : TokenExceptions_1.UnexpectedTokenException.create(token, expectedTokens);
        if (this.stopAtFirstError)
          throw error;
        this.addError(context, error);
        return 50;
      }
      match_EOF(context, token) {
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_EOF(token));
      }
      match_Empty(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_Empty(token));
      }
      match_Comment(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_Comment(token));
      }
      match_TagLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_TagLine(token));
      }
      match_FeatureLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_FeatureLine(token));
      }
      match_RuleLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_RuleLine(token));
      }
      match_BackgroundLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_BackgroundLine(token));
      }
      match_ScenarioLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_ScenarioLine(token));
      }
      match_ExamplesLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_ExamplesLine(token));
      }
      match_StepLine(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_StepLine(token));
      }
      match_DocStringSeparator(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_DocStringSeparator(token));
      }
      match_TableRow(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_TableRow(token));
      }
      match_Language(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_Language(token));
      }
      match_Other(context, token) {
        if (token.isEof)
          return false;
        return this.handleExternalError(context, false, () => this.tokenMatcher.match_Other(token));
      }
      lookahead_0(context, currentToken) {
        currentToken.detach();
        let token;
        const queue = [];
        let match = false;
        do {
          token = this.readToken(this.context);
          token.detach();
          queue.push(token);
          if (this.match_ScenarioLine(context, token)) {
            match = true;
            break;
          }
        } while (this.match_Empty(context, token) || this.match_Comment(context, token) || this.match_TagLine(context, token));
        context.tokenQueue = context.tokenQueue.concat(queue);
        return match;
      }
      lookahead_1(context, currentToken) {
        currentToken.detach();
        let token;
        const queue = [];
        let match = false;
        do {
          token = this.readToken(this.context);
          token.detach();
          queue.push(token);
          if (this.match_ExamplesLine(context, token)) {
            match = true;
            break;
          }
        } while (this.match_Empty(context, token) || this.match_Comment(context, token) || this.match_TagLine(context, token));
        context.tokenQueue = context.tokenQueue.concat(queue);
        return match;
      }
    };
    exports2.default = Parser;
  }
});

// node_modules/@cucumber/gherkin/dist/src/gherkin-languages.json
var require_gherkin_languages = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/gherkin-languages.json"(exports2, module2) {
    module2.exports = {
      af: {
        and: [
          "* ",
          "En "
        ],
        background: [
          "Agtergrond"
        ],
        but: [
          "* ",
          "Maar "
        ],
        examples: [
          "Voorbeelde"
        ],
        feature: [
          "Funksie",
          "Besigheid Behoefte",
          "Vermo\xEB"
        ],
        given: [
          "* ",
          "Gegewe "
        ],
        name: "Afrikaans",
        native: "Afrikaans",
        rule: [
          "Regel"
        ],
        scenario: [
          "Voorbeeld",
          "Situasie"
        ],
        scenarioOutline: [
          "Situasie Uiteensetting"
        ],
        then: [
          "* ",
          "Dan "
        ],
        when: [
          "* ",
          "Wanneer "
        ]
      },
      am: {
        and: [
          "* ",
          "\u0535\u057E "
        ],
        background: [
          "\u053F\u0578\u0576\u057F\u0565\u0584\u057D\u057F"
        ],
        but: [
          "* ",
          "\u0532\u0561\u0575\u0581 "
        ],
        examples: [
          "\u0555\u0580\u056B\u0576\u0561\u056F\u0576\u0565\u0580"
        ],
        feature: [
          "\u0556\u0578\u0582\u0576\u056F\u0581\u056B\u0578\u0576\u0561\u056C\u0578\u0582\u0569\u0575\u0578\u0582\u0576",
          "\u0540\u0561\u057F\u056F\u0578\u0582\u0569\u0575\u0578\u0582\u0576"
        ],
        given: [
          "* ",
          "\u0534\u056B\u0581\u0578\u0582\u0584 "
        ],
        name: "Armenian",
        native: "\u0570\u0561\u0575\u0565\u0580\u0565\u0576",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0555\u0580\u056B\u0576\u0561\u056F",
          "\u054D\u0581\u0565\u0576\u0561\u0580"
        ],
        scenarioOutline: [
          "\u054D\u0581\u0565\u0576\u0561\u0580\u056B \u056F\u0561\u057C\u0578\u0582\u0581\u057E\u0561\u0581\u0584\u0568"
        ],
        then: [
          "* ",
          "\u0531\u057A\u0561 "
        ],
        when: [
          "* ",
          "\u0535\u0569\u0565 ",
          "\u0535\u0580\u0562 "
        ]
      },
      an: {
        and: [
          "* ",
          "Y ",
          "E "
        ],
        background: [
          "Antecedents"
        ],
        but: [
          "* ",
          "Pero "
        ],
        examples: [
          "Eixemplos"
        ],
        feature: [
          "Caracteristica"
        ],
        given: [
          "* ",
          "Dau ",
          "Dada ",
          "Daus ",
          "Dadas "
        ],
        name: "Aragonese",
        native: "Aragon\xE9s",
        rule: [
          "Rule"
        ],
        scenario: [
          "Eixemplo",
          "Caso"
        ],
        scenarioOutline: [
          "Esquema del caso"
        ],
        then: [
          "* ",
          "Alavez ",
          "Allora ",
          "Antonces "
        ],
        when: [
          "* ",
          "Cuan "
        ]
      },
      ar: {
        and: [
          "* ",
          "\u0648 "
        ],
        background: [
          "\u0627\u0644\u062E\u0644\u0641\u064A\u0629"
        ],
        but: [
          "* ",
          "\u0644\u0643\u0646 "
        ],
        examples: [
          "\u0627\u0645\u062B\u0644\u0629"
        ],
        feature: [
          "\u062E\u0627\u0635\u064A\u0629"
        ],
        given: [
          "* ",
          "\u0628\u0641\u0631\u0636 "
        ],
        name: "Arabic",
        native: "\u0627\u0644\u0639\u0631\u0628\u064A\u0629",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0645\u062B\u0627\u0644",
          "\u0633\u064A\u0646\u0627\u0631\u064A\u0648"
        ],
        scenarioOutline: [
          "\u0633\u064A\u0646\u0627\u0631\u064A\u0648 \u0645\u062E\u0637\u0637"
        ],
        then: [
          "* ",
          "\u0627\u0630\u0627\u064B ",
          "\u062B\u0645 "
        ],
        when: [
          "* ",
          "\u0645\u062A\u0649 ",
          "\u0639\u0646\u062F\u0645\u0627 "
        ]
      },
      ast: {
        and: [
          "* ",
          "Y ",
          "Ya "
        ],
        background: [
          "Antecedentes"
        ],
        but: [
          "* ",
          "Peru "
        ],
        examples: [
          "Exemplos"
        ],
        feature: [
          "Carauter\xEDstica"
        ],
        given: [
          "* ",
          "D\xE1u ",
          "Dada ",
          "Daos ",
          "Daes "
        ],
        name: "Asturian",
        native: "asturianu",
        rule: [
          "Rule"
        ],
        scenario: [
          "Exemplo",
          "Casu"
        ],
        scenarioOutline: [
          "Esbozu del casu"
        ],
        then: [
          "* ",
          "Ent\xF3s "
        ],
        when: [
          "* ",
          "Cuando "
        ]
      },
      az: {
        and: [
          "* ",
          "V\u0259 ",
          "H\u0259m "
        ],
        background: [
          "Ke\xE7mi\u015F",
          "Kontekst"
        ],
        but: [
          "* ",
          "Amma ",
          "Ancaq "
        ],
        examples: [
          "N\xFCmun\u0259l\u0259r"
        ],
        feature: [
          "\xD6z\u0259llik"
        ],
        given: [
          "* ",
          "Tutaq ki ",
          "Verilir "
        ],
        name: "Azerbaijani",
        native: "Az\u0259rbaycanca",
        rule: [
          "Rule"
        ],
        scenario: [
          "N\xFCmun\u0259",
          "Ssenari"
        ],
        scenarioOutline: [
          "Ssenarinin strukturu"
        ],
        then: [
          "* ",
          "O halda "
        ],
        when: [
          "* ",
          "\u018Fg\u0259r ",
          "N\u0259 vaxt ki "
        ]
      },
      bg: {
        and: [
          "* ",
          "\u0418 "
        ],
        background: [
          "\u041F\u0440\u0435\u0434\u0438\u0441\u0442\u043E\u0440\u0438\u044F"
        ],
        but: [
          "* ",
          "\u041D\u043E "
        ],
        examples: [
          "\u041F\u0440\u0438\u043C\u0435\u0440\u0438"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u043D\u043E\u0441\u0442"
        ],
        given: [
          "* ",
          "\u0414\u0430\u0434\u0435\u043D\u043E "
        ],
        name: "Bulgarian",
        native: "\u0431\u044A\u043B\u0433\u0430\u0440\u0441\u043A\u0438",
        rule: [
          "\u041F\u0440\u0430\u0432\u0438\u043B\u043E"
        ],
        scenario: [
          "\u041F\u0440\u0438\u043C\u0435\u0440",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439"
        ],
        scenarioOutline: [
          "\u0420\u0430\u043C\u043A\u0430 \u043D\u0430 \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0439"
        ],
        then: [
          "* ",
          "\u0422\u043E "
        ],
        when: [
          "* ",
          "\u041A\u043E\u0433\u0430\u0442\u043E "
        ]
      },
      bm: {
        and: [
          "* ",
          "Dan "
        ],
        background: [
          "Latar Belakang"
        ],
        but: [
          "* ",
          "Tetapi ",
          "Tapi "
        ],
        examples: [
          "Contoh"
        ],
        feature: [
          "Fungsi"
        ],
        given: [
          "* ",
          "Diberi ",
          "Bagi "
        ],
        name: "Malay",
        native: "Bahasa Melayu",
        rule: [
          "Rule"
        ],
        scenario: [
          "Senario",
          "Situasi",
          "Keadaan"
        ],
        scenarioOutline: [
          "Kerangka Senario",
          "Kerangka Situasi",
          "Kerangka Keadaan",
          "Garis Panduan Senario"
        ],
        then: [
          "* ",
          "Maka ",
          "Kemudian "
        ],
        when: [
          "* ",
          "Apabila "
        ]
      },
      bs: {
        and: [
          "* ",
          "I ",
          "A "
        ],
        background: [
          "Pozadina"
        ],
        but: [
          "* ",
          "Ali "
        ],
        examples: [
          "Primjeri"
        ],
        feature: [
          "Karakteristika"
        ],
        given: [
          "* ",
          "Dato "
        ],
        name: "Bosnian",
        native: "Bosanski",
        rule: [
          "Rule"
        ],
        scenario: [
          "Primjer",
          "Scenariju",
          "Scenario"
        ],
        scenarioOutline: [
          "Scenariju-obris",
          "Scenario-outline"
        ],
        then: [
          "* ",
          "Zatim "
        ],
        when: [
          "* ",
          "Kada "
        ]
      },
      ca: {
        and: [
          "* ",
          "I "
        ],
        background: [
          "Rerefons",
          "Antecedents"
        ],
        but: [
          "* ",
          "Per\xF2 "
        ],
        examples: [
          "Exemples"
        ],
        feature: [
          "Caracter\xEDstica",
          "Funcionalitat"
        ],
        given: [
          "* ",
          "Donat ",
          "Donada ",
          "At\xE8s ",
          "Atesa "
        ],
        name: "Catalan",
        native: "catal\xE0",
        rule: [
          "Rule"
        ],
        scenario: [
          "Exemple",
          "Escenari"
        ],
        scenarioOutline: [
          "Esquema de l'escenari"
        ],
        then: [
          "* ",
          "Aleshores ",
          "Cal "
        ],
        when: [
          "* ",
          "Quan "
        ]
      },
      cs: {
        and: [
          "* ",
          "A tak\xE9 ",
          "A "
        ],
        background: [
          "Pozad\xED",
          "Kontext"
        ],
        but: [
          "* ",
          "Ale "
        ],
        examples: [
          "P\u0159\xEDklady"
        ],
        feature: [
          "Po\u017Eadavek"
        ],
        given: [
          "* ",
          "Pokud ",
          "Za p\u0159edpokladu "
        ],
        name: "Czech",
        native: "\u010Cesky",
        rule: [
          "Pravidlo"
        ],
        scenario: [
          "P\u0159\xEDklad",
          "Sc\xE9n\xE1\u0159"
        ],
        scenarioOutline: [
          "N\xE1\u010Drt Sc\xE9n\xE1\u0159e",
          "Osnova sc\xE9n\xE1\u0159e"
        ],
        then: [
          "* ",
          "Pak "
        ],
        when: [
          "* ",
          "Kdy\u017E "
        ]
      },
      "cy-GB": {
        and: [
          "* ",
          "A "
        ],
        background: [
          "Cefndir"
        ],
        but: [
          "* ",
          "Ond "
        ],
        examples: [
          "Enghreifftiau"
        ],
        feature: [
          "Arwedd"
        ],
        given: [
          "* ",
          "Anrhegedig a "
        ],
        name: "Welsh",
        native: "Cymraeg",
        rule: [
          "Rule"
        ],
        scenario: [
          "Enghraifft",
          "Scenario"
        ],
        scenarioOutline: [
          "Scenario Amlinellol"
        ],
        then: [
          "* ",
          "Yna "
        ],
        when: [
          "* ",
          "Pryd "
        ]
      },
      da: {
        and: [
          "* ",
          "Og "
        ],
        background: [
          "Baggrund"
        ],
        but: [
          "* ",
          "Men "
        ],
        examples: [
          "Eksempler"
        ],
        feature: [
          "Egenskab"
        ],
        given: [
          "* ",
          "Givet "
        ],
        name: "Danish",
        native: "dansk",
        rule: [
          "Rule"
        ],
        scenario: [
          "Eksempel",
          "Scenarie"
        ],
        scenarioOutline: [
          "Abstrakt Scenario"
        ],
        then: [
          "* ",
          "S\xE5 "
        ],
        when: [
          "* ",
          "N\xE5r "
        ]
      },
      de: {
        and: [
          "* ",
          "Und "
        ],
        background: [
          "Grundlage",
          "Hintergrund",
          "Voraussetzungen",
          "Vorbedingungen"
        ],
        but: [
          "* ",
          "Aber "
        ],
        examples: [
          "Beispiele"
        ],
        feature: [
          "Funktionalit\xE4t",
          "Funktion"
        ],
        given: [
          "* ",
          "Angenommen ",
          "Gegeben sei ",
          "Gegeben seien "
        ],
        name: "German",
        native: "Deutsch",
        rule: [
          "Rule",
          "Regel"
        ],
        scenario: [
          "Beispiel",
          "Szenario"
        ],
        scenarioOutline: [
          "Szenariogrundriss",
          "Szenarien"
        ],
        then: [
          "* ",
          "Dann "
        ],
        when: [
          "* ",
          "Wenn "
        ]
      },
      el: {
        and: [
          "* ",
          "\u039A\u03B1\u03B9 "
        ],
        background: [
          "\u03A5\u03C0\u03CC\u03B2\u03B1\u03B8\u03C1\u03BF"
        ],
        but: [
          "* ",
          "\u0391\u03BB\u03BB\u03AC "
        ],
        examples: [
          "\u03A0\u03B1\u03C1\u03B1\u03B4\u03B5\u03AF\u03B3\u03BC\u03B1\u03C4\u03B1",
          "\u03A3\u03B5\u03BD\u03AC\u03C1\u03B9\u03B1"
        ],
        feature: [
          "\u0394\u03C5\u03BD\u03B1\u03C4\u03CC\u03C4\u03B7\u03C4\u03B1",
          "\u039B\u03B5\u03B9\u03C4\u03BF\u03C5\u03C1\u03B3\u03AF\u03B1"
        ],
        given: [
          "* ",
          "\u0394\u03B5\u03B4\u03BF\u03BC\u03AD\u03BD\u03BF\u03C5 "
        ],
        name: "Greek",
        native: "\u0395\u03BB\u03BB\u03B7\u03BD\u03B9\u03BA\u03AC",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u03A0\u03B1\u03C1\u03AC\u03B4\u03B5\u03B9\u03B3\u03BC\u03B1",
          "\u03A3\u03B5\u03BD\u03AC\u03C1\u03B9\u03BF"
        ],
        scenarioOutline: [
          "\u03A0\u03B5\u03C1\u03B9\u03B3\u03C1\u03B1\u03C6\u03AE \u03A3\u03B5\u03BD\u03B1\u03C1\u03AF\u03BF\u03C5",
          "\u03A0\u03B5\u03C1\u03AF\u03B3\u03C1\u03B1\u03BC\u03BC\u03B1 \u03A3\u03B5\u03BD\u03B1\u03C1\u03AF\u03BF\u03C5"
        ],
        then: [
          "* ",
          "\u03A4\u03CC\u03C4\u03B5 "
        ],
        when: [
          "* ",
          "\u038C\u03C4\u03B1\u03BD "
        ]
      },
      em: {
        and: [
          "* ",
          "\u{1F602}"
        ],
        background: [
          "\u{1F4A4}"
        ],
        but: [
          "* ",
          "\u{1F614}"
        ],
        examples: [
          "\u{1F4D3}"
        ],
        feature: [
          "\u{1F4DA}"
        ],
        given: [
          "* ",
          "\u{1F610}"
        ],
        name: "Emoji",
        native: "\u{1F600}",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u{1F952}",
          "\u{1F4D5}"
        ],
        scenarioOutline: [
          "\u{1F4D6}"
        ],
        then: [
          "* ",
          "\u{1F64F}"
        ],
        when: [
          "* ",
          "\u{1F3AC}"
        ]
      },
      en: {
        and: [
          "* ",
          "And "
        ],
        background: [
          "Background"
        ],
        but: [
          "* ",
          "But "
        ],
        examples: [
          "Examples",
          "Scenarios"
        ],
        feature: [
          "Feature",
          "Business Need",
          "Ability"
        ],
        given: [
          "* ",
          "Given "
        ],
        name: "English",
        native: "English",
        rule: [
          "Rule"
        ],
        scenario: [
          "Example",
          "Scenario"
        ],
        scenarioOutline: [
          "Scenario Outline",
          "Scenario Template"
        ],
        then: [
          "* ",
          "Then "
        ],
        when: [
          "* ",
          "When "
        ]
      },
      "en-Scouse": {
        and: [
          "* ",
          "An "
        ],
        background: [
          "Dis is what went down"
        ],
        but: [
          "* ",
          "Buh "
        ],
        examples: [
          "Examples"
        ],
        feature: [
          "Feature"
        ],
        given: [
          "* ",
          "Givun ",
          "Youse know when youse got "
        ],
        name: "Scouse",
        native: "Scouse",
        rule: [
          "Rule"
        ],
        scenario: [
          "The thing of it is"
        ],
        scenarioOutline: [
          "Wharrimean is"
        ],
        then: [
          "* ",
          "Dun ",
          "Den youse gotta "
        ],
        when: [
          "* ",
          "Wun ",
          "Youse know like when "
        ]
      },
      "en-au": {
        and: [
          "* ",
          "Too right "
        ],
        background: [
          "First off"
        ],
        but: [
          "* ",
          "Yeah nah "
        ],
        examples: [
          "You'll wanna"
        ],
        feature: [
          "Pretty much"
        ],
        given: [
          "* ",
          "Y'know "
        ],
        name: "Australian",
        native: "Australian",
        rule: [
          "Rule"
        ],
        scenario: [
          "Awww, look mate"
        ],
        scenarioOutline: [
          "Reckon it's like"
        ],
        then: [
          "* ",
          "But at the end of the day I reckon "
        ],
        when: [
          "* ",
          "It's just unbelievable "
        ]
      },
      "en-lol": {
        and: [
          "* ",
          "AN "
        ],
        background: [
          "B4"
        ],
        but: [
          "* ",
          "BUT "
        ],
        examples: [
          "EXAMPLZ"
        ],
        feature: [
          "OH HAI"
        ],
        given: [
          "* ",
          "I CAN HAZ "
        ],
        name: "LOLCAT",
        native: "LOLCAT",
        rule: [
          "Rule"
        ],
        scenario: [
          "MISHUN"
        ],
        scenarioOutline: [
          "MISHUN SRSLY"
        ],
        then: [
          "* ",
          "DEN "
        ],
        when: [
          "* ",
          "WEN "
        ]
      },
      "en-old": {
        and: [
          "* ",
          "Ond ",
          "7 "
        ],
        background: [
          "Aer",
          "\xC6r"
        ],
        but: [
          "* ",
          "Ac "
        ],
        examples: [
          "Se the",
          "Se \xFEe",
          "Se \xF0e"
        ],
        feature: [
          "Hwaet",
          "Hw\xE6t"
        ],
        given: [
          "* ",
          "Thurh ",
          "\xDEurh ",
          "\xD0urh "
        ],
        name: "Old English",
        native: "Englisc",
        rule: [
          "Rule"
        ],
        scenario: [
          "Swa"
        ],
        scenarioOutline: [
          "Swa hwaer swa",
          "Swa hw\xE6r swa"
        ],
        then: [
          "* ",
          "Tha ",
          "\xDEa ",
          "\xD0a ",
          "Tha the ",
          "\xDEa \xFEe ",
          "\xD0a \xF0e "
        ],
        when: [
          "* ",
          "B\xE6\xFEsealf ",
          "B\xE6\xFEsealfa ",
          "B\xE6\xFEsealfe ",
          "Ciric\xE6w ",
          "Ciric\xE6we ",
          "Ciric\xE6wa "
        ]
      },
      "en-pirate": {
        and: [
          "* ",
          "Aye "
        ],
        background: [
          "Yo-ho-ho"
        ],
        but: [
          "* ",
          "Avast! "
        ],
        examples: [
          "Dead men tell no tales"
        ],
        feature: [
          "Ahoy matey!"
        ],
        given: [
          "* ",
          "Gangway! "
        ],
        name: "Pirate",
        native: "Pirate",
        rule: [
          "Rule"
        ],
        scenario: [
          "Heave to"
        ],
        scenarioOutline: [
          "Shiver me timbers"
        ],
        then: [
          "* ",
          "Let go and haul "
        ],
        when: [
          "* ",
          "Blimey! "
        ]
      },
      "en-tx": {
        and: [
          "Come hell or high water "
        ],
        background: [
          "Lemme tell y'all a story"
        ],
        but: [
          "Well now hold on, I'll you what "
        ],
        examples: [
          "Now that's a story longer than a cattle drive in July"
        ],
        feature: [
          "This ain\u2019t my first rodeo",
          "All gussied up"
        ],
        given: [
          "Fixin' to ",
          "All git out "
        ],
        name: "Texas",
        native: "Texas",
        rule: [
          "Rule "
        ],
        scenario: [
          "All hat and no cattle"
        ],
        scenarioOutline: [
          "Serious as a snake bite",
          "Busy as a hound in flea season"
        ],
        then: [
          "There\u2019s no tree but bears some fruit "
        ],
        when: [
          "Quick out of the chute "
        ]
      },
      eo: {
        and: [
          "* ",
          "Kaj "
        ],
        background: [
          "Fono"
        ],
        but: [
          "* ",
          "Sed "
        ],
        examples: [
          "Ekzemploj"
        ],
        feature: [
          "Trajto"
        ],
        given: [
          "* ",
          "Donita\u0135o ",
          "Komence "
        ],
        name: "Esperanto",
        native: "Esperanto",
        rule: [
          "Rule"
        ],
        scenario: [
          "Ekzemplo",
          "Scenaro",
          "Kazo"
        ],
        scenarioOutline: [
          "Konturo de la scenaro",
          "Skizo",
          "Kazo-skizo"
        ],
        then: [
          "* ",
          "Do "
        ],
        when: [
          "* ",
          "Se "
        ]
      },
      es: {
        and: [
          "* ",
          "Y ",
          "E "
        ],
        background: [
          "Antecedentes"
        ],
        but: [
          "* ",
          "Pero "
        ],
        examples: [
          "Ejemplos"
        ],
        feature: [
          "Caracter\xEDstica",
          "Necesidad del negocio",
          "Requisito"
        ],
        given: [
          "* ",
          "Dado ",
          "Dada ",
          "Dados ",
          "Dadas "
        ],
        name: "Spanish",
        native: "espa\xF1ol",
        rule: [
          "Regla",
          "Regla de negocio"
        ],
        scenario: [
          "Ejemplo",
          "Escenario"
        ],
        scenarioOutline: [
          "Esquema del escenario"
        ],
        then: [
          "* ",
          "Entonces "
        ],
        when: [
          "* ",
          "Cuando "
        ]
      },
      et: {
        and: [
          "* ",
          "Ja "
        ],
        background: [
          "Taust"
        ],
        but: [
          "* ",
          "Kuid "
        ],
        examples: [
          "Juhtumid"
        ],
        feature: [
          "Omadus"
        ],
        given: [
          "* ",
          "Eeldades "
        ],
        name: "Estonian",
        native: "eesti keel",
        rule: [
          "Reegel"
        ],
        scenario: [
          "Juhtum",
          "Stsenaarium"
        ],
        scenarioOutline: [
          "Raamjuhtum",
          "Raamstsenaarium"
        ],
        then: [
          "* ",
          "Siis "
        ],
        when: [
          "* ",
          "Kui "
        ]
      },
      fa: {
        and: [
          "* ",
          "\u0648 "
        ],
        background: [
          "\u0632\u0645\u06CC\u0646\u0647"
        ],
        but: [
          "* ",
          "\u0627\u0645\u0627 "
        ],
        examples: [
          "\u0646\u0645\u0648\u0646\u0647 \u0647\u0627"
        ],
        feature: [
          "\u0648\u0650\u06CC\u0698\u06AF\u06CC"
        ],
        given: [
          "* ",
          "\u0628\u0627 \u0641\u0631\u0636 "
        ],
        name: "Persian",
        native: "\u0641\u0627\u0631\u0633\u06CC",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0645\u062B\u0627\u0644",
          "\u0633\u0646\u0627\u0631\u06CC\u0648"
        ],
        scenarioOutline: [
          "\u0627\u0644\u06AF\u0648\u06CC \u0633\u0646\u0627\u0631\u06CC\u0648"
        ],
        then: [
          "* ",
          "\u0622\u0646\u06AF\u0627\u0647 "
        ],
        when: [
          "* ",
          "\u0647\u0646\u06AF\u0627\u0645\u06CC "
        ]
      },
      fi: {
        and: [
          "* ",
          "Ja "
        ],
        background: [
          "Tausta"
        ],
        but: [
          "* ",
          "Mutta "
        ],
        examples: [
          "Tapaukset"
        ],
        feature: [
          "Ominaisuus"
        ],
        given: [
          "* ",
          "Oletetaan "
        ],
        name: "Finnish",
        native: "suomi",
        rule: [
          "Rule"
        ],
        scenario: [
          "Tapaus"
        ],
        scenarioOutline: [
          "Tapausaihio"
        ],
        then: [
          "* ",
          "Niin "
        ],
        when: [
          "* ",
          "Kun "
        ]
      },
      fr: {
        and: [
          "* ",
          "Et que ",
          "Et qu'",
          "Et "
        ],
        background: [
          "Contexte"
        ],
        but: [
          "* ",
          "Mais que ",
          "Mais qu'",
          "Mais "
        ],
        examples: [
          "Exemples"
        ],
        feature: [
          "Fonctionnalit\xE9"
        ],
        given: [
          "* ",
          "Soit ",
          "Sachant que ",
          "Sachant qu'",
          "Sachant ",
          "Etant donn\xE9 que ",
          "Etant donn\xE9 qu'",
          "Etant donn\xE9 ",
          "Etant donn\xE9e ",
          "Etant donn\xE9s ",
          "Etant donn\xE9es ",
          "\xC9tant donn\xE9 que ",
          "\xC9tant donn\xE9 qu'",
          "\xC9tant donn\xE9 ",
          "\xC9tant donn\xE9e ",
          "\xC9tant donn\xE9s ",
          "\xC9tant donn\xE9es "
        ],
        name: "French",
        native: "fran\xE7ais",
        rule: [
          "R\xE8gle"
        ],
        scenario: [
          "Exemple",
          "Sc\xE9nario"
        ],
        scenarioOutline: [
          "Plan du sc\xE9nario",
          "Plan du Sc\xE9nario"
        ],
        then: [
          "* ",
          "Alors ",
          "Donc "
        ],
        when: [
          "* ",
          "Quand ",
          "Lorsque ",
          "Lorsqu'"
        ]
      },
      ga: {
        and: [
          "* ",
          "Agus"
        ],
        background: [
          "C\xFAlra"
        ],
        but: [
          "* ",
          "Ach"
        ],
        examples: [
          "Sampla\xED"
        ],
        feature: [
          "Gn\xE9"
        ],
        given: [
          "* ",
          "Cuir i gc\xE1s go",
          "Cuir i gc\xE1s nach",
          "Cuir i gc\xE1s gur",
          "Cuir i gc\xE1s n\xE1r"
        ],
        name: "Irish",
        native: "Gaeilge",
        rule: [
          "Rule"
        ],
        scenario: [
          "Sampla",
          "C\xE1s"
        ],
        scenarioOutline: [
          "C\xE1s Achomair"
        ],
        then: [
          "* ",
          "Ansin"
        ],
        when: [
          "* ",
          "Nuair a",
          "Nuair nach",
          "Nuair ba",
          "Nuair n\xE1r"
        ]
      },
      gj: {
        and: [
          "* ",
          "\u0A85\u0AA8\u0AC7 "
        ],
        background: [
          "\u0AAC\u0AC7\u0A95\u0A97\u0ACD\u0AB0\u0ABE\u0A89\u0AA8\u0ACD\u0AA1"
        ],
        but: [
          "* ",
          "\u0AAA\u0AA3 "
        ],
        examples: [
          "\u0A89\u0AA6\u0ABE\u0AB9\u0AB0\u0AA3\u0ACB"
        ],
        feature: [
          "\u0AB2\u0A95\u0ACD\u0AB7\u0AA3",
          "\u0AB5\u0ACD\u0AAF\u0ABE\u0AAA\u0ABE\u0AB0 \u0A9C\u0AB0\u0AC2\u0AB0",
          "\u0A95\u0ACD\u0AB7\u0AAE\u0AA4\u0ABE"
        ],
        given: [
          "* ",
          "\u0A86\u0AAA\u0AC7\u0AB2 \u0A9B\u0AC7 "
        ],
        name: "Gujarati",
        native: "\u0A97\u0AC1\u0A9C\u0AB0\u0ABE\u0AA4\u0AC0",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0A89\u0AA6\u0ABE\u0AB9\u0AB0\u0AA3",
          "\u0AB8\u0ACD\u0AA5\u0ABF\u0AA4\u0ABF"
        ],
        scenarioOutline: [
          "\u0AAA\u0AB0\u0ABF\u0AA6\u0ACD\u0AA6\u0AB6\u0ACD\u0AAF \u0AB0\u0AC2\u0AAA\u0AB0\u0AC7\u0A96\u0ABE",
          "\u0AAA\u0AB0\u0ABF\u0AA6\u0ACD\u0AA6\u0AB6\u0ACD\u0AAF \u0AA2\u0ABE\u0A82\u0A9A\u0ACB"
        ],
        then: [
          "* ",
          "\u0AAA\u0A9B\u0AC0 "
        ],
        when: [
          "* ",
          "\u0A95\u0ACD\u0AAF\u0ABE\u0AB0\u0AC7 "
        ]
      },
      gl: {
        and: [
          "* ",
          "E "
        ],
        background: [
          "Contexto"
        ],
        but: [
          "* ",
          "Mais ",
          "Pero "
        ],
        examples: [
          "Exemplos"
        ],
        feature: [
          "Caracter\xEDstica"
        ],
        given: [
          "* ",
          "Dado ",
          "Dada ",
          "Dados ",
          "Dadas "
        ],
        name: "Galician",
        native: "galego",
        rule: [
          "Rule"
        ],
        scenario: [
          "Exemplo",
          "Escenario"
        ],
        scenarioOutline: [
          "Esbozo do escenario"
        ],
        then: [
          "* ",
          "Ent\xF3n ",
          "Logo "
        ],
        when: [
          "* ",
          "Cando "
        ]
      },
      he: {
        and: [
          "* ",
          "\u05D5\u05D2\u05DD "
        ],
        background: [
          "\u05E8\u05E7\u05E2"
        ],
        but: [
          "* ",
          "\u05D0\u05D1\u05DC "
        ],
        examples: [
          "\u05D3\u05D5\u05D2\u05DE\u05D0\u05D5\u05EA"
        ],
        feature: [
          "\u05EA\u05DB\u05D5\u05E0\u05D4"
        ],
        given: [
          "* ",
          "\u05D1\u05D4\u05D9\u05E0\u05EA\u05DF "
        ],
        name: "Hebrew",
        native: "\u05E2\u05D1\u05E8\u05D9\u05EA",
        rule: [
          "\u05DB\u05DC\u05DC"
        ],
        scenario: [
          "\u05D3\u05D5\u05D2\u05DE\u05D0",
          "\u05EA\u05E8\u05D7\u05D9\u05E9"
        ],
        scenarioOutline: [
          "\u05EA\u05D1\u05E0\u05D9\u05EA \u05EA\u05E8\u05D7\u05D9\u05E9"
        ],
        then: [
          "* ",
          "\u05D0\u05D6 ",
          "\u05D0\u05D6\u05D9 "
        ],
        when: [
          "* ",
          "\u05DB\u05D0\u05E9\u05E8 "
        ]
      },
      hi: {
        and: [
          "* ",
          "\u0914\u0930 ",
          "\u0924\u0925\u093E "
        ],
        background: [
          "\u092A\u0943\u0937\u094D\u0920\u092D\u0942\u092E\u093F"
        ],
        but: [
          "* ",
          "\u092A\u0930 ",
          "\u092A\u0930\u0928\u094D\u0924\u0941 ",
          "\u0915\u093F\u0928\u094D\u0924\u0941 "
        ],
        examples: [
          "\u0909\u0926\u093E\u0939\u0930\u0923"
        ],
        feature: [
          "\u0930\u0942\u092A \u0932\u0947\u0916"
        ],
        given: [
          "* ",
          "\u0905\u0917\u0930 ",
          "\u092F\u0926\u093F ",
          "\u091A\u0942\u0902\u0915\u093F "
        ],
        name: "Hindi",
        native: "\u0939\u093F\u0902\u0926\u0940",
        rule: [
          "\u0928\u093F\u092F\u092E"
        ],
        scenario: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F"
        ],
        scenarioOutline: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F \u0930\u0942\u092A\u0930\u0947\u0916\u093E"
        ],
        then: [
          "* ",
          "\u0924\u092C ",
          "\u0924\u0926\u093E "
        ],
        when: [
          "* ",
          "\u091C\u092C ",
          "\u0915\u0926\u093E "
        ]
      },
      hr: {
        and: [
          "* ",
          "I "
        ],
        background: [
          "Pozadina"
        ],
        but: [
          "* ",
          "Ali "
        ],
        examples: [
          "Primjeri",
          "Scenariji"
        ],
        feature: [
          "Osobina",
          "Mogu\u0107nost",
          "Mogucnost"
        ],
        given: [
          "* ",
          "Zadan ",
          "Zadani ",
          "Zadano ",
          "Ukoliko "
        ],
        name: "Croatian",
        native: "hrvatski",
        rule: [
          "Rule"
        ],
        scenario: [
          "Primjer",
          "Scenarij"
        ],
        scenarioOutline: [
          "Skica",
          "Koncept"
        ],
        then: [
          "* ",
          "Onda "
        ],
        when: [
          "* ",
          "Kada ",
          "Kad "
        ]
      },
      ht: {
        and: [
          "* ",
          "Ak ",
          "Epi ",
          "E "
        ],
        background: [
          "Kont\xE8ks",
          "Istorik"
        ],
        but: [
          "* ",
          "Men "
        ],
        examples: [
          "Egzanp"
        ],
        feature: [
          "Karakteristik",
          "Mak",
          "Fonksyonalite"
        ],
        given: [
          "* ",
          "Sipoze ",
          "Sipoze ke ",
          "Sipoze Ke "
        ],
        name: "Creole",
        native: "krey\xF2l",
        rule: [
          "Rule"
        ],
        scenario: [
          "Senaryo"
        ],
        scenarioOutline: [
          "Plan senaryo",
          "Plan Senaryo",
          "Senaryo deskripsyon",
          "Senaryo Deskripsyon",
          "Dyagram senaryo",
          "Dyagram Senaryo"
        ],
        then: [
          "* ",
          "L\xE8 sa a ",
          "Le sa a "
        ],
        when: [
          "* ",
          "L\xE8 ",
          "Le "
        ]
      },
      hu: {
        and: [
          "* ",
          "\xC9s "
        ],
        background: [
          "H\xE1tt\xE9r"
        ],
        but: [
          "* ",
          "De "
        ],
        examples: [
          "P\xE9ld\xE1k"
        ],
        feature: [
          "Jellemz\u0151"
        ],
        given: [
          "* ",
          "Amennyiben ",
          "Adott "
        ],
        name: "Hungarian",
        native: "magyar",
        rule: [
          "Szab\xE1ly"
        ],
        scenario: [
          "P\xE9lda",
          "Forgat\xF3k\xF6nyv"
        ],
        scenarioOutline: [
          "Forgat\xF3k\xF6nyv v\xE1zlat"
        ],
        then: [
          "* ",
          "Akkor "
        ],
        when: [
          "* ",
          "Majd ",
          "Ha ",
          "Amikor "
        ]
      },
      id: {
        and: [
          "* ",
          "Dan "
        ],
        background: [
          "Dasar",
          "Latar Belakang"
        ],
        but: [
          "* ",
          "Tapi ",
          "Tetapi "
        ],
        examples: [
          "Contoh",
          "Misal"
        ],
        feature: [
          "Fitur"
        ],
        given: [
          "* ",
          "Dengan ",
          "Diketahui ",
          "Diasumsikan ",
          "Bila ",
          "Jika "
        ],
        name: "Indonesian",
        native: "Bahasa Indonesia",
        rule: [
          "Rule",
          "Aturan"
        ],
        scenario: [
          "Skenario"
        ],
        scenarioOutline: [
          "Skenario konsep",
          "Garis-Besar Skenario"
        ],
        then: [
          "* ",
          "Maka ",
          "Kemudian "
        ],
        when: [
          "* ",
          "Ketika "
        ]
      },
      is: {
        and: [
          "* ",
          "Og "
        ],
        background: [
          "Bakgrunnur"
        ],
        but: [
          "* ",
          "En "
        ],
        examples: [
          "D\xE6mi",
          "Atbur\xF0ar\xE1sir"
        ],
        feature: [
          "Eiginleiki"
        ],
        given: [
          "* ",
          "Ef "
        ],
        name: "Icelandic",
        native: "\xCDslenska",
        rule: [
          "Rule"
        ],
        scenario: [
          "Atbur\xF0ar\xE1s"
        ],
        scenarioOutline: [
          "L\xFDsing Atbur\xF0ar\xE1sar",
          "L\xFDsing D\xE6ma"
        ],
        then: [
          "* ",
          "\xDE\xE1 "
        ],
        when: [
          "* ",
          "\xDEegar "
        ]
      },
      it: {
        and: [
          "* ",
          "E "
        ],
        background: [
          "Contesto"
        ],
        but: [
          "* ",
          "Ma "
        ],
        examples: [
          "Esempi"
        ],
        feature: [
          "Funzionalit\xE0",
          "Esigenza di Business",
          "Abilit\xE0"
        ],
        given: [
          "* ",
          "Dato ",
          "Data ",
          "Dati ",
          "Date "
        ],
        name: "Italian",
        native: "italiano",
        rule: [
          "Regola"
        ],
        scenario: [
          "Esempio",
          "Scenario"
        ],
        scenarioOutline: [
          "Schema dello scenario"
        ],
        then: [
          "* ",
          "Allora "
        ],
        when: [
          "* ",
          "Quando "
        ]
      },
      ja: {
        and: [
          "* ",
          "\u304B\u3064"
        ],
        background: [
          "\u80CC\u666F"
        ],
        but: [
          "* ",
          "\u3057\u304B\u3057",
          "\u4F46\u3057",
          "\u305F\u3060\u3057"
        ],
        examples: [
          "\u4F8B",
          "\u30B5\u30F3\u30D7\u30EB"
        ],
        feature: [
          "\u30D5\u30A3\u30FC\u30C1\u30E3",
          "\u6A5F\u80FD"
        ],
        given: [
          "* ",
          "\u524D\u63D0"
        ],
        name: "Japanese",
        native: "\u65E5\u672C\u8A9E",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u30B7\u30CA\u30EA\u30AA"
        ],
        scenarioOutline: [
          "\u30B7\u30CA\u30EA\u30AA\u30A2\u30A6\u30C8\u30E9\u30A4\u30F3",
          "\u30B7\u30CA\u30EA\u30AA\u30C6\u30F3\u30D7\u30EC\u30FC\u30C8",
          "\u30C6\u30F3\u30D7\u30EC",
          "\u30B7\u30CA\u30EA\u30AA\u30C6\u30F3\u30D7\u30EC"
        ],
        then: [
          "* ",
          "\u306A\u3089\u3070"
        ],
        when: [
          "* ",
          "\u3082\u3057"
        ]
      },
      jv: {
        and: [
          "* ",
          "Lan "
        ],
        background: [
          "Dasar"
        ],
        but: [
          "* ",
          "Tapi ",
          "Nanging ",
          "Ananging "
        ],
        examples: [
          "Conto",
          "Contone"
        ],
        feature: [
          "Fitur"
        ],
        given: [
          "* ",
          "Nalika ",
          "Nalikaning "
        ],
        name: "Javanese",
        native: "Basa Jawa",
        rule: [
          "Rule"
        ],
        scenario: [
          "Skenario"
        ],
        scenarioOutline: [
          "Konsep skenario"
        ],
        then: [
          "* ",
          "Njuk ",
          "Banjur "
        ],
        when: [
          "* ",
          "Manawa ",
          "Menawa "
        ]
      },
      ka: {
        and: [
          "* ",
          "\u10D3\u10D0"
        ],
        background: [
          "\u10D9\u10DD\u10DC\u10E2\u10D4\u10E5\u10E1\u10E2\u10D8"
        ],
        but: [
          "* ",
          "\u10DB\u10D0\u10D2\xAD\u10E0\u10D0\u10DB"
        ],
        examples: [
          "\u10DB\u10D0\u10D2\u10D0\u10DA\u10D8\u10D7\u10D4\u10D1\u10D8"
        ],
        feature: [
          "\u10D7\u10D5\u10D8\u10E1\u10D4\u10D1\u10D0"
        ],
        given: [
          "* ",
          "\u10DB\u10DD\u10EA\u10D4\u10DB\u10E3\u10DA\u10D8"
        ],
        name: "Georgian",
        native: "\u10E5\u10D0\u10E0\u10D7\u10D5\u10D4\u10DA\u10D8",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u10DB\u10D0\u10D2\u10D0\u10DA\u10D8\u10D7\u10D0\u10D3",
          "\u10E1\u10EA\u10D4\u10DC\u10D0\u10E0\u10D8\u10E1"
        ],
        scenarioOutline: [
          "\u10E1\u10EA\u10D4\u10DC\u10D0\u10E0\u10D8\u10E1 \u10DC\u10D8\u10DB\u10E3\u10E8\u10D8"
        ],
        then: [
          "* ",
          "\u10DB\u10D0\u10E8\u10D8\u10DC"
        ],
        when: [
          "* ",
          "\u10E0\u10DD\u10D3\u10D4\u10E1\u10D0\u10EA"
        ]
      },
      kn: {
        and: [
          "* ",
          "\u0CAE\u0CA4\u0CCD\u0CA4\u0CC1 "
        ],
        background: [
          "\u0CB9\u0CBF\u0CA8\u0CCD\u0CA8\u0CC6\u0CB2\u0CC6"
        ],
        but: [
          "* ",
          "\u0C86\u0CA6\u0CB0\u0CC6 "
        ],
        examples: [
          "\u0C89\u0CA6\u0CBE\u0CB9\u0CB0\u0CA3\u0CC6\u0C97\u0CB3\u0CC1"
        ],
        feature: [
          "\u0CB9\u0CC6\u0C9A\u0CCD\u0C9A\u0CB3"
        ],
        given: [
          "* ",
          "\u0CA8\u0CBF\u0CD5\u0CA1\u0CBF\u0CA6 "
        ],
        name: "Kannada",
        native: "\u0C95\u0CA8\u0CCD\u0CA8\u0CA1",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0C89\u0CA6\u0CBE\u0CB9\u0CB0\u0CA3\u0CC6",
          "\u0C95\u0CA5\u0CBE\u0CB8\u0CBE\u0CB0\u0CBE\u0C82\u0CB6"
        ],
        scenarioOutline: [
          "\u0CB5\u0CBF\u0CB5\u0CB0\u0CA3\u0CC6"
        ],
        then: [
          "* ",
          "\u0CA8\u0C82\u0CA4\u0CB0 "
        ],
        when: [
          "* ",
          "\u0CB8\u0CCD\u0CA5\u0CBF\u0CA4\u0CBF\u0CAF\u0CA8\u0CCD\u0CA8\u0CC1 "
        ]
      },
      ko: {
        and: [
          "* ",
          "\uADF8\uB9AC\uACE0"
        ],
        background: [
          "\uBC30\uACBD"
        ],
        but: [
          "* ",
          "\uD558\uC9C0\uB9CC",
          "\uB2E8"
        ],
        examples: [
          "\uC608"
        ],
        feature: [
          "\uAE30\uB2A5"
        ],
        given: [
          "* ",
          "\uC870\uAC74",
          "\uBA3C\uC800"
        ],
        name: "Korean",
        native: "\uD55C\uAD6D\uC5B4",
        rule: [
          "Rule"
        ],
        scenario: [
          "\uC2DC\uB098\uB9AC\uC624"
        ],
        scenarioOutline: [
          "\uC2DC\uB098\uB9AC\uC624 \uAC1C\uC694"
        ],
        then: [
          "* ",
          "\uADF8\uB7EC\uBA74"
        ],
        when: [
          "* ",
          "\uB9CC\uC77C",
          "\uB9CC\uC57D"
        ]
      },
      lt: {
        and: [
          "* ",
          "Ir "
        ],
        background: [
          "Kontekstas"
        ],
        but: [
          "* ",
          "Bet "
        ],
        examples: [
          "Pavyzd\u017Eiai",
          "Scenarijai",
          "Variantai"
        ],
        feature: [
          "Savyb\u0117"
        ],
        given: [
          "* ",
          "Duota "
        ],
        name: "Lithuanian",
        native: "lietuvi\u0173 kalba",
        rule: [
          "Rule"
        ],
        scenario: [
          "Pavyzdys",
          "Scenarijus"
        ],
        scenarioOutline: [
          "Scenarijaus \u0161ablonas"
        ],
        then: [
          "* ",
          "Tada "
        ],
        when: [
          "* ",
          "Kai "
        ]
      },
      lu: {
        and: [
          "* ",
          "an ",
          "a "
        ],
        background: [
          "Hannergrond"
        ],
        but: [
          "* ",
          "awer ",
          "m\xE4 "
        ],
        examples: [
          "Beispiller"
        ],
        feature: [
          "Funktionalit\xE9it"
        ],
        given: [
          "* ",
          "ugeholl "
        ],
        name: "Luxemburgish",
        native: "L\xEBtzebuergesch",
        rule: [
          "Rule"
        ],
        scenario: [
          "Beispill",
          "Szenario"
        ],
        scenarioOutline: [
          "Plang vum Szenario"
        ],
        then: [
          "* ",
          "dann "
        ],
        when: [
          "* ",
          "wann "
        ]
      },
      lv: {
        and: [
          "* ",
          "Un "
        ],
        background: [
          "Konteksts",
          "Situ\u0101cija"
        ],
        but: [
          "* ",
          "Bet "
        ],
        examples: [
          "Piem\u0113ri",
          "Paraugs"
        ],
        feature: [
          "Funkcionalit\u0101te",
          "F\u012B\u010Da"
        ],
        given: [
          "* ",
          "Kad "
        ],
        name: "Latvian",
        native: "latvie\u0161u",
        rule: [
          "Rule"
        ],
        scenario: [
          "Piem\u0113rs",
          "Scen\u0101rijs"
        ],
        scenarioOutline: [
          "Scen\u0101rijs p\u0113c parauga"
        ],
        then: [
          "* ",
          "Tad "
        ],
        when: [
          "* ",
          "Ja "
        ]
      },
      "mk-Cyrl": {
        and: [
          "* ",
          "\u0418 "
        ],
        background: [
          "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442",
          "\u0421\u043E\u0434\u0440\u0436\u0438\u043D\u0430"
        ],
        but: [
          "* ",
          "\u041D\u043E "
        ],
        examples: [
          "\u041F\u0440\u0438\u043C\u0435\u0440\u0438",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0458\u0430"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u043D\u043E\u0441\u0442",
          "\u0411\u0438\u0437\u043D\u0438\u0441 \u043F\u043E\u0442\u0440\u0435\u0431\u0430",
          "\u041C\u043E\u0436\u043D\u043E\u0441\u0442"
        ],
        given: [
          "* ",
          "\u0414\u0430\u0434\u0435\u043D\u043E ",
          "\u0414\u0430\u0434\u0435\u043D\u0430 "
        ],
        name: "Macedonian",
        native: "\u041C\u0430\u043A\u0435\u0434\u043E\u043D\u0441\u043A\u0438",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u041F\u0440\u0438\u043C\u0435\u0440",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u043E",
          "\u041D\u0430 \u043F\u0440\u0438\u043C\u0435\u0440"
        ],
        scenarioOutline: [
          "\u041F\u0440\u0435\u0433\u043B\u0435\u0434 \u043D\u0430 \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0458\u0430",
          "\u0421\u043A\u0438\u0446\u0430",
          "\u041A\u043E\u043D\u0446\u0435\u043F\u0442"
        ],
        then: [
          "* ",
          "\u0422\u043E\u0433\u0430\u0448 "
        ],
        when: [
          "* ",
          "\u041A\u043E\u0433\u0430 "
        ]
      },
      "mk-Latn": {
        and: [
          "* ",
          "I "
        ],
        background: [
          "Kontekst",
          "Sodrzhina"
        ],
        but: [
          "* ",
          "No "
        ],
        examples: [
          "Primeri",
          "Scenaria"
        ],
        feature: [
          "Funkcionalnost",
          "Biznis potreba",
          "Mozhnost"
        ],
        given: [
          "* ",
          "Dadeno ",
          "Dadena "
        ],
        name: "Macedonian (Latin)",
        native: "Makedonski (Latinica)",
        rule: [
          "Rule"
        ],
        scenario: [
          "Scenario",
          "Na primer"
        ],
        scenarioOutline: [
          "Pregled na scenarija",
          "Skica",
          "Koncept"
        ],
        then: [
          "* ",
          "Togash "
        ],
        when: [
          "* ",
          "Koga "
        ]
      },
      mn: {
        and: [
          "* ",
          "\u041C\u04E9\u043D ",
          "\u0422\u044D\u0433\u044D\u044D\u0434 "
        ],
        background: [
          "\u0410\u0433\u0443\u0443\u043B\u0433\u0430"
        ],
        but: [
          "* ",
          "\u0413\u044D\u0445\u0434\u044D\u044D ",
          "\u0425\u0430\u0440\u0438\u043D "
        ],
        examples: [
          "\u0422\u0443\u0445\u0430\u0439\u043B\u0431\u0430\u043B"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446",
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B"
        ],
        given: [
          "* ",
          "\u04E8\u0433\u04E9\u0433\u0434\u0441\u04E9\u043D \u043D\u044C ",
          "\u0410\u043D\u0445 "
        ],
        name: "Mongolian",
        native: "\u043C\u043E\u043D\u0433\u043E\u043B",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0421\u0446\u0435\u043D\u0430\u0440"
        ],
        scenarioOutline: [
          "\u0421\u0446\u0435\u043D\u0430\u0440\u044B\u043D \u0442\u04E9\u043B\u04E9\u0432\u043B\u04E9\u0433\u04E9\u04E9"
        ],
        then: [
          "* ",
          "\u0422\u044D\u0433\u044D\u0445\u044D\u0434 ",
          "\u04AE\u04AF\u043D\u0438\u0439 \u0434\u0430\u0440\u0430\u0430 "
        ],
        when: [
          "* ",
          "\u0425\u044D\u0440\u044D\u0432 "
        ]
      },
      ne: {
        and: [
          "* ",
          "\u0930 ",
          "\u0905\u0928\u093F "
        ],
        background: [
          "\u092A\u0943\u0937\u094D\u0920\u092D\u0942\u092E\u0940"
        ],
        but: [
          "* ",
          "\u0924\u0930 "
        ],
        examples: [
          "\u0909\u0926\u093E\u0939\u0930\u0923",
          "\u0909\u0926\u093E\u0939\u0930\u0923\u0939\u0930\u0941"
        ],
        feature: [
          "\u0938\u0941\u0935\u093F\u0927\u093E",
          "\u0935\u093F\u0936\u0947\u0937\u0924\u093E"
        ],
        given: [
          "* ",
          "\u0926\u093F\u0907\u090F\u0915\u094B ",
          "\u0926\u093F\u090F\u0915\u094B ",
          "\u092F\u0926\u093F "
        ],
        name: "Nepali",
        native: "\u0928\u0947\u092A\u093E\u0932\u0940",
        rule: [
          "\u0928\u093F\u092F\u092E"
        ],
        scenario: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F"
        ],
        scenarioOutline: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F \u0930\u0942\u092A\u0930\u0947\u0916\u093E"
        ],
        then: [
          "* ",
          "\u0924\u094D\u092F\u0938\u092A\u091B\u093F ",
          "\u0905\u0928\u0940 "
        ],
        when: [
          "* ",
          "\u091C\u092C "
        ]
      },
      nl: {
        and: [
          "* ",
          "En "
        ],
        background: [
          "Achtergrond"
        ],
        but: [
          "* ",
          "Maar "
        ],
        examples: [
          "Voorbeelden"
        ],
        feature: [
          "Functionaliteit"
        ],
        given: [
          "* ",
          "Gegeven ",
          "Stel "
        ],
        name: "Dutch",
        native: "Nederlands",
        rule: [
          "Rule"
        ],
        scenario: [
          "Voorbeeld",
          "Scenario"
        ],
        scenarioOutline: [
          "Abstract Scenario"
        ],
        then: [
          "* ",
          "Dan "
        ],
        when: [
          "* ",
          "Als ",
          "Wanneer "
        ]
      },
      no: {
        and: [
          "* ",
          "Og "
        ],
        background: [
          "Bakgrunn"
        ],
        but: [
          "* ",
          "Men "
        ],
        examples: [
          "Eksempler"
        ],
        feature: [
          "Egenskap"
        ],
        given: [
          "* ",
          "Gitt "
        ],
        name: "Norwegian",
        native: "norsk",
        rule: [
          "Regel"
        ],
        scenario: [
          "Eksempel",
          "Scenario"
        ],
        scenarioOutline: [
          "Scenariomal",
          "Abstrakt Scenario"
        ],
        then: [
          "* ",
          "S\xE5 "
        ],
        when: [
          "* ",
          "N\xE5r "
        ]
      },
      pa: {
        and: [
          "* ",
          "\u0A05\u0A24\u0A47 "
        ],
        background: [
          "\u0A2A\u0A3F\u0A1B\u0A4B\u0A15\u0A5C"
        ],
        but: [
          "* ",
          "\u0A2A\u0A30 "
        ],
        examples: [
          "\u0A09\u0A26\u0A3E\u0A39\u0A30\u0A28\u0A3E\u0A02"
        ],
        feature: [
          "\u0A16\u0A3E\u0A38\u0A40\u0A05\u0A24",
          "\u0A2E\u0A41\u0A39\u0A3E\u0A02\u0A26\u0A30\u0A3E",
          "\u0A28\u0A15\u0A36 \u0A28\u0A41\u0A39\u0A3E\u0A30"
        ],
        given: [
          "* ",
          "\u0A1C\u0A47\u0A15\u0A30 ",
          "\u0A1C\u0A3F\u0A35\u0A47\u0A02 \u0A15\u0A3F "
        ],
        name: "Panjabi",
        native: "\u0A2A\u0A70\u0A1C\u0A3E\u0A2C\u0A40",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0A09\u0A26\u0A3E\u0A39\u0A30\u0A28",
          "\u0A2A\u0A1F\u0A15\u0A25\u0A3E"
        ],
        scenarioOutline: [
          "\u0A2A\u0A1F\u0A15\u0A25\u0A3E \u0A22\u0A3E\u0A02\u0A1A\u0A3E",
          "\u0A2A\u0A1F\u0A15\u0A25\u0A3E \u0A30\u0A42\u0A2A \u0A30\u0A47\u0A16\u0A3E"
        ],
        then: [
          "* ",
          "\u0A24\u0A26 "
        ],
        when: [
          "* ",
          "\u0A1C\u0A26\u0A4B\u0A02 "
        ]
      },
      pl: {
        and: [
          "* ",
          "Oraz ",
          "I "
        ],
        background: [
          "Za\u0142o\u017Cenia"
        ],
        but: [
          "* ",
          "Ale "
        ],
        examples: [
          "Przyk\u0142ady"
        ],
        feature: [
          "W\u0142a\u015Bciwo\u015B\u0107",
          "Funkcja",
          "Aspekt",
          "Potrzeba biznesowa"
        ],
        given: [
          "* ",
          "Zak\u0142adaj\u0105c ",
          "Maj\u0105c ",
          "Zak\u0142adaj\u0105c, \u017Ce "
        ],
        name: "Polish",
        native: "polski",
        rule: [
          "Zasada",
          "Regu\u0142a"
        ],
        scenario: [
          "Przyk\u0142ad",
          "Scenariusz"
        ],
        scenarioOutline: [
          "Szablon scenariusza"
        ],
        then: [
          "* ",
          "Wtedy "
        ],
        when: [
          "* ",
          "Je\u017Celi ",
          "Je\u015Bli ",
          "Gdy ",
          "Kiedy "
        ]
      },
      pt: {
        and: [
          "* ",
          "E "
        ],
        background: [
          "Contexto",
          "Cen\xE1rio de Fundo",
          "Cenario de Fundo",
          "Fundo"
        ],
        but: [
          "* ",
          "Mas "
        ],
        examples: [
          "Exemplos",
          "Cen\xE1rios",
          "Cenarios"
        ],
        feature: [
          "Funcionalidade",
          "Caracter\xEDstica",
          "Caracteristica"
        ],
        given: [
          "* ",
          "Dado ",
          "Dada ",
          "Dados ",
          "Dadas "
        ],
        name: "Portuguese",
        native: "portugu\xEAs",
        rule: [
          "Regra"
        ],
        scenario: [
          "Exemplo",
          "Cen\xE1rio",
          "Cenario"
        ],
        scenarioOutline: [
          "Esquema do Cen\xE1rio",
          "Esquema do Cenario",
          "Delinea\xE7\xE3o do Cen\xE1rio",
          "Delineacao do Cenario"
        ],
        then: [
          "* ",
          "Ent\xE3o ",
          "Entao "
        ],
        when: [
          "* ",
          "Quando "
        ]
      },
      ro: {
        and: [
          "* ",
          "Si ",
          "\u0218i ",
          "\u015Ei "
        ],
        background: [
          "Context"
        ],
        but: [
          "* ",
          "Dar "
        ],
        examples: [
          "Exemple"
        ],
        feature: [
          "Functionalitate",
          "Func\u021Bionalitate",
          "Func\u0163ionalitate"
        ],
        given: [
          "* ",
          "Date fiind ",
          "Dat fiind ",
          "Dat\u0103 fiind",
          "Dati fiind ",
          "Da\u021Bi fiind ",
          "Da\u0163i fiind "
        ],
        name: "Romanian",
        native: "rom\xE2n\u0103",
        rule: [
          "Rule"
        ],
        scenario: [
          "Exemplu",
          "Scenariu"
        ],
        scenarioOutline: [
          "Structura scenariu",
          "Structur\u0103 scenariu"
        ],
        then: [
          "* ",
          "Atunci "
        ],
        when: [
          "* ",
          "Cand ",
          "C\xE2nd "
        ]
      },
      ru: {
        and: [
          "* ",
          "\u0418 ",
          "\u041A \u0442\u043E\u043C\u0443 \u0436\u0435 ",
          "\u0422\u0430\u043A\u0436\u0435 "
        ],
        background: [
          "\u041F\u0440\u0435\u0434\u044B\u0441\u0442\u043E\u0440\u0438\u044F",
          "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442"
        ],
        but: [
          "* ",
          "\u041D\u043E ",
          "\u0410 ",
          "\u0418\u043D\u0430\u0447\u0435 "
        ],
        examples: [
          "\u041F\u0440\u0438\u043C\u0435\u0440\u044B"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0438\u044F",
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B",
          "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u043E"
        ],
        given: [
          "* ",
          "\u0414\u043E\u043F\u0443\u0441\u0442\u0438\u043C ",
          "\u0414\u0430\u043D\u043E ",
          "\u041F\u0443\u0441\u0442\u044C "
        ],
        name: "Russian",
        native: "\u0440\u0443\u0441\u0441\u043A\u0438\u0439",
        rule: [
          "\u041F\u0440\u0430\u0432\u0438\u043B\u043E"
        ],
        scenario: [
          "\u041F\u0440\u0438\u043C\u0435\u0440",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439"
        ],
        scenarioOutline: [
          "\u0421\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430 \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u044F",
          "\u0428\u0430\u0431\u043B\u043E\u043D \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u044F"
        ],
        then: [
          "* ",
          "\u0422\u043E ",
          "\u0417\u0430\u0442\u0435\u043C ",
          "\u0422\u043E\u0433\u0434\u0430 "
        ],
        when: [
          "* ",
          "\u041A\u043E\u0433\u0434\u0430 ",
          "\u0415\u0441\u043B\u0438 "
        ]
      },
      sk: {
        and: [
          "* ",
          "A ",
          "A tie\u017E ",
          "A taktie\u017E ",
          "A z\xE1rove\u0148 "
        ],
        background: [
          "Pozadie"
        ],
        but: [
          "* ",
          "Ale "
        ],
        examples: [
          "Pr\xEDklady"
        ],
        feature: [
          "Po\u017Eiadavka",
          "Funkcia",
          "Vlastnos\u0165"
        ],
        given: [
          "* ",
          "Pokia\u013E ",
          "Za predpokladu "
        ],
        name: "Slovak",
        native: "Slovensky",
        rule: [
          "Rule"
        ],
        scenario: [
          "Pr\xEDklad",
          "Scen\xE1r"
        ],
        scenarioOutline: [
          "N\xE1\u010Drt Scen\xE1ru",
          "N\xE1\u010Drt Scen\xE1ra",
          "Osnova Scen\xE1ra"
        ],
        then: [
          "* ",
          "Tak ",
          "Potom "
        ],
        when: [
          "* ",
          "Ke\u010F ",
          "Ak "
        ]
      },
      sl: {
        and: [
          "In ",
          "Ter "
        ],
        background: [
          "Kontekst",
          "Osnova",
          "Ozadje"
        ],
        but: [
          "Toda ",
          "Ampak ",
          "Vendar "
        ],
        examples: [
          "Primeri",
          "Scenariji"
        ],
        feature: [
          "Funkcionalnost",
          "Funkcija",
          "Mo\u017Enosti",
          "Moznosti",
          "Lastnost",
          "Zna\u010Dilnost"
        ],
        given: [
          "Dano ",
          "Podano ",
          "Zaradi ",
          "Privzeto "
        ],
        name: "Slovenian",
        native: "Slovenski",
        rule: [
          "Rule"
        ],
        scenario: [
          "Primer",
          "Scenarij"
        ],
        scenarioOutline: [
          "Struktura scenarija",
          "Skica",
          "Koncept",
          "Oris scenarija",
          "Osnutek"
        ],
        then: [
          "Nato ",
          "Potem ",
          "Takrat "
        ],
        when: [
          "Ko ",
          "Ce ",
          "\u010Ce ",
          "Kadar "
        ]
      },
      "sr-Cyrl": {
        and: [
          "* ",
          "\u0418 "
        ],
        background: [
          "\u041A\u043E\u043D\u0442\u0435\u043A\u0441\u0442",
          "\u041E\u0441\u043D\u043E\u0432\u0430",
          "\u041F\u043E\u0437\u0430\u0434\u0438\u043D\u0430"
        ],
        but: [
          "* ",
          "\u0410\u043B\u0438 "
        ],
        examples: [
          "\u041F\u0440\u0438\u043C\u0435\u0440\u0438",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0458\u0438"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B\u043D\u043E\u0441\u0442",
          "\u041C\u043E\u0433\u0443\u045B\u043D\u043E\u0441\u0442",
          "\u041E\u0441\u043E\u0431\u0438\u043D\u0430"
        ],
        given: [
          "* ",
          "\u0417\u0430 \u0434\u0430\u0442\u043E ",
          "\u0417\u0430 \u0434\u0430\u0442\u0435 ",
          "\u0417\u0430 \u0434\u0430\u0442\u0438 "
        ],
        name: "Serbian",
        native: "\u0421\u0440\u043F\u0441\u043A\u0438",
        rule: [
          "\u041F\u0440\u0430\u0432\u0438\u043B\u043E"
        ],
        scenario: [
          "\u041F\u0440\u0438\u043C\u0435\u0440",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u043E",
          "\u041F\u0440\u0438\u043C\u0435\u0440"
        ],
        scenarioOutline: [
          "\u0421\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430 \u0441\u0446\u0435\u043D\u0430\u0440\u0438\u0458\u0430",
          "\u0421\u043A\u0438\u0446\u0430",
          "\u041A\u043E\u043D\u0446\u0435\u043F\u0442"
        ],
        then: [
          "* ",
          "\u041E\u043D\u0434\u0430 "
        ],
        when: [
          "* ",
          "\u041A\u0430\u0434\u0430 ",
          "\u041A\u0430\u0434 "
        ]
      },
      "sr-Latn": {
        and: [
          "* ",
          "I "
        ],
        background: [
          "Kontekst",
          "Osnova",
          "Pozadina"
        ],
        but: [
          "* ",
          "Ali "
        ],
        examples: [
          "Primeri",
          "Scenariji"
        ],
        feature: [
          "Funkcionalnost",
          "Mogu\u0107nost",
          "Mogucnost",
          "Osobina"
        ],
        given: [
          "* ",
          "Za dato ",
          "Za date ",
          "Za dati "
        ],
        name: "Serbian (Latin)",
        native: "Srpski (Latinica)",
        rule: [
          "Pravilo"
        ],
        scenario: [
          "Scenario",
          "Primer"
        ],
        scenarioOutline: [
          "Struktura scenarija",
          "Skica",
          "Koncept"
        ],
        then: [
          "* ",
          "Onda "
        ],
        when: [
          "* ",
          "Kada ",
          "Kad "
        ]
      },
      sv: {
        and: [
          "* ",
          "Och "
        ],
        background: [
          "Bakgrund"
        ],
        but: [
          "* ",
          "Men "
        ],
        examples: [
          "Exempel"
        ],
        feature: [
          "Egenskap"
        ],
        given: [
          "* ",
          "Givet "
        ],
        name: "Swedish",
        native: "Svenska",
        rule: [
          "Regel"
        ],
        scenario: [
          "Scenario"
        ],
        scenarioOutline: [
          "Abstrakt Scenario",
          "Scenariomall"
        ],
        then: [
          "* ",
          "S\xE5 "
        ],
        when: [
          "* ",
          "N\xE4r "
        ]
      },
      ta: {
        and: [
          "* ",
          "\u0BAE\u0BC7\u0BB2\u0BC1\u0BAE\u0BCD  ",
          "\u0BAE\u0BB1\u0BCD\u0BB1\u0BC1\u0BAE\u0BCD "
        ],
        background: [
          "\u0BAA\u0BBF\u0BA9\u0BCD\u0BA9\u0BA3\u0BBF"
        ],
        but: [
          "* ",
          "\u0B86\u0BA9\u0BBE\u0BB2\u0BCD  "
        ],
        examples: [
          "\u0B8E\u0B9F\u0BC1\u0BA4\u0BCD\u0BA4\u0BC1\u0B95\u0BCD\u0B95\u0BBE\u0B9F\u0BCD\u0B9F\u0BC1\u0B95\u0BB3\u0BCD",
          "\u0B95\u0BBE\u0B9F\u0BCD\u0B9A\u0BBF\u0B95\u0BB3\u0BCD",
          "\u0BA8\u0BBF\u0BB2\u0BC8\u0BAE\u0BC8\u0B95\u0BB3\u0BBF\u0BB2\u0BCD"
        ],
        feature: [
          "\u0B85\u0BAE\u0BCD\u0B9A\u0BAE\u0BCD",
          "\u0BB5\u0BA3\u0BBF\u0B95 \u0BA4\u0BC7\u0BB5\u0BC8",
          "\u0BA4\u0BBF\u0BB1\u0BA9\u0BCD"
        ],
        given: [
          "* ",
          "\u0B95\u0BC6\u0BBE\u0B9F\u0BC1\u0B95\u0BCD\u0B95\u0BAA\u0BCD\u0BAA\u0B9F\u0BCD\u0B9F "
        ],
        name: "Tamil",
        native: "\u0BA4\u0BAE\u0BBF\u0BB4\u0BCD",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0B89\u0BA4\u0BBE\u0BB0\u0BA3\u0BAE\u0BBE\u0B95",
          "\u0B95\u0BBE\u0B9F\u0BCD\u0B9A\u0BBF"
        ],
        scenarioOutline: [
          "\u0B95\u0BBE\u0B9F\u0BCD\u0B9A\u0BBF \u0B9A\u0BC1\u0BB0\u0BC1\u0B95\u0BCD\u0B95\u0BAE\u0BCD",
          "\u0B95\u0BBE\u0B9F\u0BCD\u0B9A\u0BBF \u0BB5\u0BBE\u0BB0\u0BCD\u0BAA\u0BCD\u0BAA\u0BC1\u0BB0\u0BC1"
        ],
        then: [
          "* ",
          "\u0B85\u0BAA\u0BCD\u0BAA\u0BC6\u0BBE\u0BB4\u0BC1\u0BA4\u0BC1 "
        ],
        when: [
          "* ",
          "\u0B8E\u0BAA\u0BCD\u0BAA\u0BC7\u0BBE\u0BA4\u0BC1 "
        ]
      },
      th: {
        and: [
          "* ",
          "\u0E41\u0E25\u0E30 "
        ],
        background: [
          "\u0E41\u0E19\u0E27\u0E04\u0E34\u0E14"
        ],
        but: [
          "* ",
          "\u0E41\u0E15\u0E48 "
        ],
        examples: [
          "\u0E0A\u0E38\u0E14\u0E02\u0E2D\u0E07\u0E15\u0E31\u0E27\u0E2D\u0E22\u0E48\u0E32\u0E07",
          "\u0E0A\u0E38\u0E14\u0E02\u0E2D\u0E07\u0E40\u0E2B\u0E15\u0E38\u0E01\u0E32\u0E23\u0E13\u0E4C"
        ],
        feature: [
          "\u0E42\u0E04\u0E23\u0E07\u0E2B\u0E25\u0E31\u0E01",
          "\u0E04\u0E27\u0E32\u0E21\u0E15\u0E49\u0E2D\u0E07\u0E01\u0E32\u0E23\u0E17\u0E32\u0E07\u0E18\u0E38\u0E23\u0E01\u0E34\u0E08",
          "\u0E04\u0E27\u0E32\u0E21\u0E2A\u0E32\u0E21\u0E32\u0E23\u0E16"
        ],
        given: [
          "* ",
          "\u0E01\u0E33\u0E2B\u0E19\u0E14\u0E43\u0E2B\u0E49 "
        ],
        name: "Thai",
        native: "\u0E44\u0E17\u0E22",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0E40\u0E2B\u0E15\u0E38\u0E01\u0E32\u0E23\u0E13\u0E4C"
        ],
        scenarioOutline: [
          "\u0E2A\u0E23\u0E38\u0E1B\u0E40\u0E2B\u0E15\u0E38\u0E01\u0E32\u0E23\u0E13\u0E4C",
          "\u0E42\u0E04\u0E23\u0E07\u0E2A\u0E23\u0E49\u0E32\u0E07\u0E02\u0E2D\u0E07\u0E40\u0E2B\u0E15\u0E38\u0E01\u0E32\u0E23\u0E13\u0E4C"
        ],
        then: [
          "* ",
          "\u0E14\u0E31\u0E07\u0E19\u0E31\u0E49\u0E19 "
        ],
        when: [
          "* ",
          "\u0E40\u0E21\u0E37\u0E48\u0E2D "
        ]
      },
      te: {
        and: [
          "* ",
          "\u0C2E\u0C30\u0C3F\u0C2F\u0C41 "
        ],
        background: [
          "\u0C28\u0C47\u0C2A\u0C25\u0C4D\u0C2F\u0C02"
        ],
        but: [
          "* ",
          "\u0C15\u0C3E\u0C28\u0C3F "
        ],
        examples: [
          "\u0C09\u0C26\u0C3E\u0C39\u0C30\u0C23\u0C32\u0C41"
        ],
        feature: [
          "\u0C17\u0C41\u0C23\u0C2E\u0C41"
        ],
        given: [
          "* ",
          "\u0C1A\u0C46\u0C2A\u0C4D\u0C2A\u0C2C\u0C21\u0C3F\u0C28\u0C26\u0C3F "
        ],
        name: "Telugu",
        native: "\u0C24\u0C46\u0C32\u0C41\u0C17\u0C41",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0C09\u0C26\u0C3E\u0C39\u0C30\u0C23",
          "\u0C38\u0C28\u0C4D\u0C28\u0C3F\u0C35\u0C47\u0C36\u0C02"
        ],
        scenarioOutline: [
          "\u0C15\u0C25\u0C28\u0C02"
        ],
        then: [
          "* ",
          "\u0C05\u0C2A\u0C4D\u0C2A\u0C41\u0C21\u0C41 "
        ],
        when: [
          "* ",
          "\u0C08 \u0C2A\u0C30\u0C3F\u0C38\u0C4D\u0C25\u0C3F\u0C24\u0C3F\u0C32\u0C4B "
        ]
      },
      tlh: {
        and: [
          "* ",
          "'ej ",
          "latlh "
        ],
        background: [
          "mo'"
        ],
        but: [
          "* ",
          "'ach ",
          "'a "
        ],
        examples: [
          "ghantoH",
          "lutmey"
        ],
        feature: [
          "Qap",
          "Qu'meH 'ut",
          "perbogh",
          "poQbogh malja'",
          "laH"
        ],
        given: [
          "* ",
          "ghu' noblu' ",
          "DaH ghu' bejlu' "
        ],
        name: "Klingon",
        native: "tlhIngan",
        rule: [
          "Rule"
        ],
        scenario: [
          "lut"
        ],
        scenarioOutline: [
          "lut chovnatlh"
        ],
        then: [
          "* ",
          "vaj "
        ],
        when: [
          "* ",
          "qaSDI' "
        ]
      },
      tr: {
        and: [
          "* ",
          "Ve "
        ],
        background: [
          "Ge\xE7mi\u015F"
        ],
        but: [
          "* ",
          "Fakat ",
          "Ama "
        ],
        examples: [
          "\xD6rnekler"
        ],
        feature: [
          "\xD6zellik"
        ],
        given: [
          "* ",
          "Diyelim ki "
        ],
        name: "Turkish",
        native: "T\xFCrk\xE7e",
        rule: [
          "Kural"
        ],
        scenario: [
          "\xD6rnek",
          "Senaryo"
        ],
        scenarioOutline: [
          "Senaryo tasla\u011F\u0131"
        ],
        then: [
          "* ",
          "O zaman "
        ],
        when: [
          "* ",
          "E\u011Fer ki "
        ]
      },
      tt: {
        and: [
          "* ",
          "\u04BA\u04D9\u043C ",
          "\u0412\u04D9 "
        ],
        background: [
          "\u041A\u0435\u0440\u0435\u0448"
        ],
        but: [
          "* ",
          "\u041B\u04D9\u043A\u0438\u043D ",
          "\u04D8\u043C\u043C\u0430 "
        ],
        examples: [
          "\u04AE\u0440\u043D\u04D9\u043A\u043B\u04D9\u0440",
          "\u041C\u0438\u0441\u0430\u043B\u043B\u0430\u0440"
        ],
        feature: [
          "\u041C\u04E9\u043C\u043A\u0438\u043D\u043B\u0435\u043A",
          "\u04AE\u0437\u0435\u043D\u0447\u04D9\u043B\u0435\u043A\u043B\u0435\u043B\u0435\u043A"
        ],
        given: [
          "* ",
          "\u04D8\u0439\u0442\u0438\u043A "
        ],
        name: "Tatar",
        native: "\u0422\u0430\u0442\u0430\u0440\u0447\u0430",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439"
        ],
        scenarioOutline: [
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439\u043D\u044B\u04A3 \u0442\u04E9\u0437\u0435\u043B\u0435\u0448\u0435"
        ],
        then: [
          "* ",
          "\u041D\u04D9\u0442\u0438\u0497\u04D9\u0434\u04D9 "
        ],
        when: [
          "* ",
          "\u04D8\u0433\u04D9\u0440 "
        ]
      },
      uk: {
        and: [
          "* ",
          "\u0406 ",
          "\u0410 \u0442\u0430\u043A\u043E\u0436 ",
          "\u0422\u0430 "
        ],
        background: [
          "\u041F\u0435\u0440\u0435\u0434\u0443\u043C\u043E\u0432\u0430"
        ],
        but: [
          "* ",
          "\u0410\u043B\u0435 "
        ],
        examples: [
          "\u041F\u0440\u0438\u043A\u043B\u0430\u0434\u0438"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0456\u043E\u043D\u0430\u043B"
        ],
        given: [
          "* ",
          "\u041F\u0440\u0438\u043F\u0443\u0441\u0442\u0438\u043C\u043E ",
          "\u041F\u0440\u0438\u043F\u0443\u0441\u0442\u0438\u043C\u043E, \u0449\u043E ",
          "\u041D\u0435\u0445\u0430\u0439 ",
          "\u0414\u0430\u043D\u043E "
        ],
        name: "Ukrainian",
        native: "\u0423\u043A\u0440\u0430\u0457\u043D\u0441\u044C\u043A\u0430",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u041F\u0440\u0438\u043A\u043B\u0430\u0434",
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0456\u0439"
        ],
        scenarioOutline: [
          "\u0421\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430 \u0441\u0446\u0435\u043D\u0430\u0440\u0456\u044E"
        ],
        then: [
          "* ",
          "\u0422\u043E ",
          "\u0422\u043E\u0434\u0456 "
        ],
        when: [
          "* ",
          "\u042F\u043A\u0449\u043E ",
          "\u041A\u043E\u043B\u0438 "
        ]
      },
      ur: {
        and: [
          "* ",
          "\u0627\u0648\u0631 "
        ],
        background: [
          "\u067E\u0633 \u0645\u0646\u0638\u0631"
        ],
        but: [
          "* ",
          "\u0644\u06CC\u06A9\u0646 "
        ],
        examples: [
          "\u0645\u062B\u0627\u0644\u06CC\u06BA"
        ],
        feature: [
          "\u0635\u0644\u0627\u062D\u06CC\u062A",
          "\u06A9\u0627\u0631\u0648\u0628\u0627\u0631 \u06A9\u06CC \u0636\u0631\u0648\u0631\u062A",
          "\u062E\u0635\u0648\u0635\u06CC\u062A"
        ],
        given: [
          "* ",
          "\u0627\u06AF\u0631 ",
          "\u0628\u0627\u0644\u0641\u0631\u0636 ",
          "\u0641\u0631\u0636 \u06A9\u06CC\u0627 "
        ],
        name: "Urdu",
        native: "\u0627\u0631\u062F\u0648",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0645\u0646\u0638\u0631\u0646\u0627\u0645\u06C1"
        ],
        scenarioOutline: [
          "\u0645\u0646\u0638\u0631 \u0646\u0627\u0645\u06D2 \u06A9\u0627 \u062E\u0627\u06A9\u06C1"
        ],
        then: [
          "* ",
          "\u067E\u06BE\u0631 ",
          "\u062A\u0628 "
        ],
        when: [
          "* ",
          "\u062C\u0628 "
        ]
      },
      uz: {
        and: [
          "* ",
          "\u0412\u0430 "
        ],
        background: [
          "\u0422\u0430\u0440\u0438\u0445"
        ],
        but: [
          "* ",
          "\u041B\u0435\u043A\u0438\u043D ",
          "\u0411\u0438\u0440\u043E\u043A ",
          "\u0410\u043C\u043C\u043E "
        ],
        examples: [
          "\u041C\u0438\u0441\u043E\u043B\u043B\u0430\u0440"
        ],
        feature: [
          "\u0424\u0443\u043D\u043A\u0446\u0438\u043E\u043D\u0430\u043B"
        ],
        given: [
          "* ",
          "Belgilangan "
        ],
        name: "Uzbek",
        native: "\u0423\u0437\u0431\u0435\u043A\u0447\u0430",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439"
        ],
        scenarioOutline: [
          "\u0421\u0446\u0435\u043D\u0430\u0440\u0438\u0439 \u0441\u0442\u0440\u0443\u043A\u0442\u0443\u0440\u0430\u0441\u0438"
        ],
        then: [
          "* ",
          "\u0423\u043D\u0434\u0430 "
        ],
        when: [
          "* ",
          "\u0410\u0433\u0430\u0440 "
        ]
      },
      vi: {
        and: [
          "* ",
          "V\xE0 "
        ],
        background: [
          "B\u1ED1i c\u1EA3nh"
        ],
        but: [
          "* ",
          "Nh\u01B0ng "
        ],
        examples: [
          "D\u1EEF li\u1EC7u"
        ],
        feature: [
          "T\xEDnh n\u0103ng"
        ],
        given: [
          "* ",
          "Bi\u1EBFt ",
          "Cho "
        ],
        name: "Vietnamese",
        native: "Ti\u1EBFng Vi\u1EC7t",
        rule: [
          "Rule"
        ],
        scenario: [
          "T\xECnh hu\u1ED1ng",
          "K\u1ECBch b\u1EA3n"
        ],
        scenarioOutline: [
          "Khung t\xECnh hu\u1ED1ng",
          "Khung k\u1ECBch b\u1EA3n"
        ],
        then: [
          "* ",
          "Th\xEC "
        ],
        when: [
          "* ",
          "Khi "
        ]
      },
      "zh-CN": {
        and: [
          "* ",
          "\u800C\u4E14",
          "\u5E76\u4E14",
          "\u540C\u65F6"
        ],
        background: [
          "\u80CC\u666F"
        ],
        but: [
          "* ",
          "\u4F46\u662F"
        ],
        examples: [
          "\u4F8B\u5B50"
        ],
        feature: [
          "\u529F\u80FD"
        ],
        given: [
          "* ",
          "\u5047\u5982",
          "\u5047\u8BBE",
          "\u5047\u5B9A"
        ],
        name: "Chinese simplified",
        native: "\u7B80\u4F53\u4E2D\u6587",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u573A\u666F",
          "\u5267\u672C"
        ],
        scenarioOutline: [
          "\u573A\u666F\u5927\u7EB2",
          "\u5267\u672C\u5927\u7EB2"
        ],
        then: [
          "* ",
          "\u90A3\u4E48"
        ],
        when: [
          "* ",
          "\u5F53"
        ]
      },
      "zh-TW": {
        and: [
          "* ",
          "\u800C\u4E14",
          "\u4E26\u4E14",
          "\u540C\u6642"
        ],
        background: [
          "\u80CC\u666F"
        ],
        but: [
          "* ",
          "\u4F46\u662F"
        ],
        examples: [
          "\u4F8B\u5B50"
        ],
        feature: [
          "\u529F\u80FD"
        ],
        given: [
          "* ",
          "\u5047\u5982",
          "\u5047\u8A2D",
          "\u5047\u5B9A"
        ],
        name: "Chinese traditional",
        native: "\u7E41\u9AD4\u4E2D\u6587",
        rule: [
          "Rule"
        ],
        scenario: [
          "\u5834\u666F",
          "\u5287\u672C"
        ],
        scenarioOutline: [
          "\u5834\u666F\u5927\u7DB1",
          "\u5287\u672C\u5927\u7DB1"
        ],
        then: [
          "* ",
          "\u90A3\u9EBC"
        ],
        when: [
          "* ",
          "\u7576"
        ]
      },
      mr: {
        and: [
          "* ",
          "\u0906\u0923\u093F ",
          "\u0924\u0938\u0947\u091A "
        ],
        background: [
          "\u092A\u093E\u0930\u094D\u0936\u094D\u0935\u092D\u0942\u092E\u0940"
        ],
        but: [
          "* ",
          "\u092A\u0923 ",
          "\u092A\u0930\u0902\u0924\u0941 "
        ],
        examples: [
          "\u0909\u0926\u093E\u0939\u0930\u0923"
        ],
        feature: [
          "\u0935\u0948\u0936\u093F\u0937\u094D\u091F\u094D\u092F",
          "\u0938\u0941\u0935\u093F\u0927\u093E"
        ],
        given: [
          "* ",
          "\u091C\u0930",
          "\u0926\u093F\u0932\u0947\u0932\u094D\u092F\u093E \u092A\u094D\u0930\u092E\u093E\u0923\u0947 "
        ],
        name: "Marathi",
        native: "\u092E\u0930\u093E\u0920\u0940",
        rule: [
          "\u0928\u093F\u092F\u092E"
        ],
        scenario: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F"
        ],
        scenarioOutline: [
          "\u092A\u0930\u093F\u0926\u0943\u0936\u094D\u092F \u0930\u0942\u092A\u0930\u0947\u0916\u093E"
        ],
        then: [
          "* ",
          "\u092E\u0917 ",
          "\u0924\u0947\u0935\u094D\u0939\u093E "
        ],
        when: [
          "* ",
          "\u091C\u0947\u0935\u094D\u0939\u093E "
        ]
      }
    };
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/TimeConversion.js
var require_TimeConversion = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/TimeConversion.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.addDurations = exports2.durationToMilliseconds = exports2.timestampToMillisecondsSinceEpoch = exports2.millisecondsToDuration = exports2.millisecondsSinceEpochToTimestamp = void 0;
    var MILLISECONDS_PER_SECOND = 1e3;
    var NANOSECONDS_PER_MILLISECOND = 1e6;
    var NANOSECONDS_PER_SECOND = 1e9;
    function millisecondsSinceEpochToTimestamp(millisecondsSinceEpoch) {
      return toSecondsAndNanos(millisecondsSinceEpoch);
    }
    exports2.millisecondsSinceEpochToTimestamp = millisecondsSinceEpochToTimestamp;
    function millisecondsToDuration(durationInMilliseconds) {
      return toSecondsAndNanos(durationInMilliseconds);
    }
    exports2.millisecondsToDuration = millisecondsToDuration;
    function timestampToMillisecondsSinceEpoch(timestamp) {
      var seconds = timestamp.seconds, nanos = timestamp.nanos;
      return toMillis(seconds, nanos);
    }
    exports2.timestampToMillisecondsSinceEpoch = timestampToMillisecondsSinceEpoch;
    function durationToMilliseconds(duration) {
      var seconds = duration.seconds, nanos = duration.nanos;
      return toMillis(seconds, nanos);
    }
    exports2.durationToMilliseconds = durationToMilliseconds;
    function addDurations(durationA, durationB) {
      var seconds = +durationA.seconds + +durationB.seconds;
      var nanos = durationA.nanos + durationB.nanos;
      if (nanos >= NANOSECONDS_PER_SECOND) {
        seconds += 1;
        nanos -= NANOSECONDS_PER_SECOND;
      }
      return { seconds, nanos };
    }
    exports2.addDurations = addDurations;
    function toSecondsAndNanos(milliseconds) {
      var seconds = Math.floor(milliseconds / MILLISECONDS_PER_SECOND);
      var nanos = Math.floor(milliseconds % MILLISECONDS_PER_SECOND * NANOSECONDS_PER_MILLISECOND);
      return { seconds, nanos };
    }
    function toMillis(seconds, nanos) {
      var secondMillis = +seconds * MILLISECONDS_PER_SECOND;
      var nanoMillis = nanos / NANOSECONDS_PER_MILLISECOND;
      return secondMillis + nanoMillis;
    }
  }
});

// node_modules/uuid/dist/rng.js
var require_rng = __commonJS({
  "node_modules/uuid/dist/rng.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = rng;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var rnds8Pool = new Uint8Array(256);
    var poolPtr = rnds8Pool.length;
    function rng() {
      if (poolPtr > rnds8Pool.length - 16) {
        _crypto.default.randomFillSync(rnds8Pool);
        poolPtr = 0;
      }
      return rnds8Pool.slice(poolPtr, poolPtr += 16);
    }
  }
});

// node_modules/uuid/dist/regex.js
var require_regex = __commonJS({
  "node_modules/uuid/dist/regex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/validate.js
var require_validate = __commonJS({
  "node_modules/uuid/dist/validate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    var _default = validate;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/stringify.js
var require_stringify = __commonJS({
  "node_modules/uuid/dist/stringify.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).substr(1));
    }
    function stringify(arr, offset = 0) {
      const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    var _default = stringify;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/v1.js
var require_v1 = __commonJS({
  "node_modules/uuid/dist/v1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b[i++] = tl >>> 24 & 255;
      b[i++] = tl >>> 16 & 255;
      b[i++] = tl >>> 8 & 255;
      b[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b[i++] = tmh >>> 8 & 255;
      b[i++] = tmh & 255;
      b[i++] = tmh >>> 24 & 15 | 16;
      b[i++] = tmh >>> 16 & 255;
      b[i++] = clockseq >>> 8 | 128;
      b[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b[i + n] = node[n];
      }
      return buf || (0, _stringify.default)(b);
    }
    var _default = v1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/parse.js
var require_parse = __commonJS({
  "node_modules/uuid/dist/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function parse(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v;
      const arr = new Uint8Array(16);
      arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v >>> 16 & 255;
      arr[2] = v >>> 8 & 255;
      arr[3] = v & 255;
      arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v & 255;
      arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v & 255;
      arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v & 255;
      arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v / 4294967296 & 255;
      arr[12] = v >>> 24 & 255;
      arr[13] = v >>> 16 & 255;
      arr[14] = v >>> 8 & 255;
      arr[15] = v & 255;
      return arr;
    }
    var _default = parse;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/v35.js
var require_v35 = __commonJS({
  "node_modules/uuid/dist/v35.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _default;
    exports2.URL = exports2.DNS = void 0;
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports2.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports2.URL = URL2;
    function _default(name, version, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (namespace.length !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.default)(bytes);
      }
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
  }
});

// node_modules/uuid/dist/md5.js
var require_md5 = __commonJS({
  "node_modules/uuid/dist/md5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function md5(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("md5").update(bytes).digest();
    }
    var _default = md5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/v3.js
var require_v3 = __commonJS({
  "node_modules/uuid/dist/v3.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/v4.js
var require_v4 = __commonJS({
  "node_modules/uuid/dist/v4.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = _interopRequireDefault(require_stringify());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function v4(options, buf, offset) {
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.default)(rnds);
    }
    var _default = v4;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/sha1.js
var require_sha1 = __commonJS({
  "node_modules/uuid/dist/sha1.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _crypto = _interopRequireDefault(require("crypto"));
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function sha1(bytes) {
      if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
      } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
      }
      return _crypto.default.createHash("sha1").update(bytes).digest();
    }
    var _default = sha1;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/v5.js
var require_v5 = __commonJS({
  "node_modules/uuid/dist/v5.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/nil.js
var require_nil = __commonJS({
  "node_modules/uuid/dist/nil.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/version.js
var require_version = __commonJS({
  "node_modules/uuid/dist/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function version(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.substr(14, 1), 16);
    }
    var _default = version;
    exports2.default = _default;
  }
});

// node_modules/uuid/dist/index.js
var require_dist = __commonJS({
  "node_modules/uuid/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    Object.defineProperty(exports2, "v1", {
      enumerable: true,
      get: function() {
        return _v.default;
      }
    });
    Object.defineProperty(exports2, "v3", {
      enumerable: true,
      get: function() {
        return _v2.default;
      }
    });
    Object.defineProperty(exports2, "v4", {
      enumerable: true,
      get: function() {
        return _v3.default;
      }
    });
    Object.defineProperty(exports2, "v5", {
      enumerable: true,
      get: function() {
        return _v4.default;
      }
    });
    Object.defineProperty(exports2, "NIL", {
      enumerable: true,
      get: function() {
        return _nil.default;
      }
    });
    Object.defineProperty(exports2, "version", {
      enumerable: true,
      get: function() {
        return _version.default;
      }
    });
    Object.defineProperty(exports2, "validate", {
      enumerable: true,
      get: function() {
        return _validate.default;
      }
    });
    Object.defineProperty(exports2, "stringify", {
      enumerable: true,
      get: function() {
        return _stringify.default;
      }
    });
    Object.defineProperty(exports2, "parse", {
      enumerable: true,
      get: function() {
        return _parse.default;
      }
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/IdGenerator.js
var require_IdGenerator = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/IdGenerator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.incrementing = exports2.uuid = void 0;
    var uuid_1 = require_dist();
    function uuid() {
      return function() {
        return (0, uuid_1.v4)();
      };
    }
    exports2.uuid = uuid;
    function incrementing() {
      var next = 0;
      return function() {
        return (next++).toString();
      };
    }
    exports2.incrementing = incrementing;
  }
});

// node_modules/class-transformer/cjs/enums/transformation-type.enum.js
var require_transformation_type_enum = __commonJS({
  "node_modules/class-transformer/cjs/enums/transformation-type.enum.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformationType = void 0;
    var TransformationType;
    (function(TransformationType2) {
      TransformationType2[TransformationType2["PLAIN_TO_CLASS"] = 0] = "PLAIN_TO_CLASS";
      TransformationType2[TransformationType2["CLASS_TO_PLAIN"] = 1] = "CLASS_TO_PLAIN";
      TransformationType2[TransformationType2["CLASS_TO_CLASS"] = 2] = "CLASS_TO_CLASS";
    })(TransformationType = exports2.TransformationType || (exports2.TransformationType = {}));
  }
});

// node_modules/class-transformer/cjs/enums/index.js
var require_enums = __commonJS({
  "node_modules/class-transformer/cjs/enums/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_transformation_type_enum(), exports2);
  }
});

// node_modules/class-transformer/cjs/MetadataStorage.js
var require_MetadataStorage = __commonJS({
  "node_modules/class-transformer/cjs/MetadataStorage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MetadataStorage = void 0;
    var enums_1 = require_enums();
    var MetadataStorage = class {
      constructor() {
        this._typeMetadatas = /* @__PURE__ */ new Map();
        this._transformMetadatas = /* @__PURE__ */ new Map();
        this._exposeMetadatas = /* @__PURE__ */ new Map();
        this._excludeMetadatas = /* @__PURE__ */ new Map();
        this._ancestorsMap = /* @__PURE__ */ new Map();
      }
      addTypeMetadata(metadata) {
        if (!this._typeMetadatas.has(metadata.target)) {
          this._typeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._typeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      addTransformMetadata(metadata) {
        if (!this._transformMetadatas.has(metadata.target)) {
          this._transformMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        if (!this._transformMetadatas.get(metadata.target).has(metadata.propertyName)) {
          this._transformMetadatas.get(metadata.target).set(metadata.propertyName, []);
        }
        this._transformMetadatas.get(metadata.target).get(metadata.propertyName).push(metadata);
      }
      addExposeMetadata(metadata) {
        if (!this._exposeMetadatas.has(metadata.target)) {
          this._exposeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._exposeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      addExcludeMetadata(metadata) {
        if (!this._excludeMetadatas.has(metadata.target)) {
          this._excludeMetadatas.set(metadata.target, /* @__PURE__ */ new Map());
        }
        this._excludeMetadatas.get(metadata.target).set(metadata.propertyName, metadata);
      }
      findTransformMetadatas(target, propertyName, transformationType) {
        return this.findMetadatas(this._transformMetadatas, target, propertyName).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        });
      }
      findExcludeMetadata(target, propertyName) {
        return this.findMetadata(this._excludeMetadatas, target, propertyName);
      }
      findExposeMetadata(target, propertyName) {
        return this.findMetadata(this._exposeMetadatas, target, propertyName);
      }
      findExposeMetadataByCustomName(target, name) {
        return this.getExposedMetadatas(target).find((metadata) => {
          return metadata.options && metadata.options.name === name;
        });
      }
      findTypeMetadata(target, propertyName) {
        return this.findMetadata(this._typeMetadatas, target, propertyName);
      }
      getStrategy(target) {
        const excludeMap = this._excludeMetadatas.get(target);
        const exclude = excludeMap && excludeMap.get(void 0);
        const exposeMap = this._exposeMetadatas.get(target);
        const expose = exposeMap && exposeMap.get(void 0);
        if (exclude && expose || !exclude && !expose)
          return "none";
        return exclude ? "excludeAll" : "exposeAll";
      }
      getExposedMetadatas(target) {
        return this.getMetadata(this._exposeMetadatas, target);
      }
      getExcludedMetadatas(target) {
        return this.getMetadata(this._excludeMetadatas, target);
      }
      getExposedProperties(target, transformationType) {
        return this.getExposedMetadatas(target).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map((metadata) => metadata.propertyName);
      }
      getExcludedProperties(target, transformationType) {
        return this.getExcludedMetadatas(target).filter((metadata) => {
          if (!metadata.options)
            return true;
          if (metadata.options.toClassOnly === true && metadata.options.toPlainOnly === true)
            return true;
          if (metadata.options.toClassOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_CLASS || transformationType === enums_1.TransformationType.PLAIN_TO_CLASS;
          }
          if (metadata.options.toPlainOnly === true) {
            return transformationType === enums_1.TransformationType.CLASS_TO_PLAIN;
          }
          return true;
        }).map((metadata) => metadata.propertyName);
      }
      clear() {
        this._typeMetadatas.clear();
        this._exposeMetadatas.clear();
        this._excludeMetadatas.clear();
        this._ancestorsMap.clear();
      }
      getMetadata(metadatas, target) {
        const metadataFromTargetMap = metadatas.get(target);
        let metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = Array.from(metadataFromTargetMap.values()).filter((meta) => meta.propertyName !== void 0);
        }
        const metadataFromAncestors = [];
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            const metadataFromAncestor = Array.from(ancestorMetadataMap.values()).filter((meta) => meta.propertyName !== void 0);
            metadataFromAncestors.push(...metadataFromAncestor);
          }
        }
        return metadataFromAncestors.concat(metadataFromTarget || []);
      }
      findMetadata(metadatas, target, propertyName) {
        const metadataFromTargetMap = metadatas.get(target);
        if (metadataFromTargetMap) {
          const metadataFromTarget = metadataFromTargetMap.get(propertyName);
          if (metadataFromTarget) {
            return metadataFromTarget;
          }
        }
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            const ancestorResult = ancestorMetadataMap.get(propertyName);
            if (ancestorResult) {
              return ancestorResult;
            }
          }
        }
        return void 0;
      }
      findMetadatas(metadatas, target, propertyName) {
        const metadataFromTargetMap = metadatas.get(target);
        let metadataFromTarget;
        if (metadataFromTargetMap) {
          metadataFromTarget = metadataFromTargetMap.get(propertyName);
        }
        const metadataFromAncestorsTarget = [];
        for (const ancestor of this.getAncestors(target)) {
          const ancestorMetadataMap = metadatas.get(ancestor);
          if (ancestorMetadataMap) {
            if (ancestorMetadataMap.has(propertyName)) {
              metadataFromAncestorsTarget.push(...ancestorMetadataMap.get(propertyName));
            }
          }
        }
        return metadataFromAncestorsTarget.slice().reverse().concat((metadataFromTarget || []).slice().reverse());
      }
      getAncestors(target) {
        if (!target)
          return [];
        if (!this._ancestorsMap.has(target)) {
          const ancestors = [];
          for (let baseClass = Object.getPrototypeOf(target.prototype.constructor); typeof baseClass.prototype !== "undefined"; baseClass = Object.getPrototypeOf(baseClass.prototype.constructor)) {
            ancestors.push(baseClass);
          }
          this._ancestorsMap.set(target, ancestors);
        }
        return this._ancestorsMap.get(target);
      }
    };
    exports2.MetadataStorage = MetadataStorage;
  }
});

// node_modules/class-transformer/cjs/storage.js
var require_storage = __commonJS({
  "node_modules/class-transformer/cjs/storage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultMetadataStorage = void 0;
    var MetadataStorage_1 = require_MetadataStorage();
    exports2.defaultMetadataStorage = new MetadataStorage_1.MetadataStorage();
  }
});

// node_modules/class-transformer/cjs/utils/get-global.util.js
var require_get_global_util = __commonJS({
  "node_modules/class-transformer/cjs/utils/get-global.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGlobal = void 0;
    function getGlobal() {
      if (typeof globalThis !== "undefined") {
        return globalThis;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof self !== "undefined") {
        return self;
      }
    }
    exports2.getGlobal = getGlobal;
  }
});

// node_modules/class-transformer/cjs/utils/is-promise.util.js
var require_is_promise_util = __commonJS({
  "node_modules/class-transformer/cjs/utils/is-promise.util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isPromise = void 0;
    function isPromise(p) {
      return p !== null && typeof p === "object" && typeof p.then === "function";
    }
    exports2.isPromise = isPromise;
  }
});

// node_modules/class-transformer/cjs/utils/index.js
var require_utils = __commonJS({
  "node_modules/class-transformer/cjs/utils/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_get_global_util(), exports2);
    __exportStar(require_is_promise_util(), exports2);
  }
});

// node_modules/class-transformer/cjs/TransformOperationExecutor.js
var require_TransformOperationExecutor = __commonJS({
  "node_modules/class-transformer/cjs/TransformOperationExecutor.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformOperationExecutor = void 0;
    var storage_1 = require_storage();
    var enums_1 = require_enums();
    var utils_1 = require_utils();
    function instantiateArrayType(arrayType) {
      const array = new arrayType();
      if (!(array instanceof Set) && !("push" in array)) {
        return [];
      }
      return array;
    }
    var TransformOperationExecutor = class {
      constructor(transformationType, options) {
        this.transformationType = transformationType;
        this.options = options;
        this.recursionStack = /* @__PURE__ */ new Set();
      }
      transform(source, value, targetType, arrayType, isMap, level = 0) {
        if (Array.isArray(value) || value instanceof Set) {
          const newValue = arrayType && this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS ? instantiateArrayType(arrayType) : [];
          value.forEach((subValue, index) => {
            const subSource = source ? source[index] : void 0;
            if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
              let realTargetType;
              if (typeof targetType !== "function" && targetType && targetType.options && targetType.options.discriminator && targetType.options.discriminator.property && targetType.options.discriminator.subTypes) {
                if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                  realTargetType = targetType.options.discriminator.subTypes.find((subType) => subType.name === subValue[targetType.options.discriminator.property]);
                  const options = { newObject: newValue, object: subValue, property: void 0 };
                  const newType = targetType.typeFunction(options);
                  realTargetType === void 0 ? realTargetType = newType : realTargetType = realTargetType.value;
                  if (!targetType.options.keepDiscriminatorProperty)
                    delete subValue[targetType.options.discriminator.property];
                }
                if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                  realTargetType = subValue.constructor;
                }
                if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                  subValue[targetType.options.discriminator.property] = targetType.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
                }
              } else {
                realTargetType = targetType;
              }
              const value2 = this.transform(subSource, subValue, realTargetType, void 0, subValue instanceof Map, level + 1);
              if (newValue instanceof Set) {
                newValue.add(value2);
              } else {
                newValue.push(value2);
              }
            } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
              if (newValue instanceof Set) {
                newValue.add(subValue);
              } else {
                newValue.push(subValue);
              }
            }
          });
          return newValue;
        } else if (targetType === String && !isMap) {
          if (value === null || value === void 0)
            return value;
          return String(value);
        } else if (targetType === Number && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Number(value);
        } else if (targetType === Boolean && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Boolean(value);
        } else if ((targetType === Date || value instanceof Date) && !isMap) {
          if (value instanceof Date) {
            return new Date(value.valueOf());
          }
          if (value === null || value === void 0)
            return value;
          return new Date(value);
        } else if (!!(0, utils_1.getGlobal)().Buffer && (targetType === Buffer || value instanceof Buffer) && !isMap) {
          if (value === null || value === void 0)
            return value;
          return Buffer.from(value);
        } else if ((0, utils_1.isPromise)(value) && !isMap) {
          return new Promise((resolve, reject) => {
            value.then((data) => resolve(this.transform(void 0, data, targetType, void 0, void 0, level + 1)), reject);
          });
        } else if (!isMap && value !== null && typeof value === "object" && typeof value.then === "function") {
          return value;
        } else if (typeof value === "object" && value !== null) {
          if (!targetType && value.constructor !== Object)
            if (!Array.isArray(value) && value.constructor === Array) {
            } else {
              targetType = value.constructor;
            }
          if (!targetType && source)
            targetType = source.constructor;
          if (this.options.enableCircularCheck) {
            this.recursionStack.add(value);
          }
          const keys = this.getKeys(targetType, value, isMap);
          let newValue = source ? source : {};
          if (!source && (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS)) {
            if (isMap) {
              newValue = /* @__PURE__ */ new Map();
            } else if (targetType) {
              newValue = new targetType();
            } else {
              newValue = {};
            }
          }
          for (const key of keys) {
            if (key === "__proto__" || key === "constructor") {
              continue;
            }
            const valueKey = key;
            let newValueKey = key, propertyName = key;
            if (!this.options.ignoreDecorators && targetType) {
              if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadataByCustomName(targetType, key);
                if (exposeMetadata) {
                  propertyName = exposeMetadata.propertyName;
                  newValueKey = exposeMetadata.propertyName;
                }
              } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(targetType, key);
                if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                  newValueKey = exposeMetadata.options.name;
                }
              }
            }
            let subValue = void 0;
            if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
              subValue = value[valueKey];
            } else {
              if (value instanceof Map) {
                subValue = value.get(valueKey);
              } else if (value[valueKey] instanceof Function) {
                subValue = value[valueKey]();
              } else {
                subValue = value[valueKey];
              }
            }
            let type = void 0, isSubValueMap = subValue instanceof Map;
            if (targetType && isMap) {
              type = targetType;
            } else if (targetType) {
              const metadata = storage_1.defaultMetadataStorage.findTypeMetadata(targetType, propertyName);
              if (metadata) {
                const options = { newObject: newValue, object: value, property: propertyName };
                const newType = metadata.typeFunction ? metadata.typeFunction(options) : metadata.reflectedType;
                if (metadata.options && metadata.options.discriminator && metadata.options.discriminator.property && metadata.options.discriminator.subTypes) {
                  if (!(value[valueKey] instanceof Array)) {
                    if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                      type = metadata.options.discriminator.subTypes.find((subType) => {
                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {
                          return subType.name === subValue[metadata.options.discriminator.property];
                        }
                      });
                      type === void 0 ? type = newType : type = type.value;
                      if (!metadata.options.keepDiscriminatorProperty) {
                        if (subValue && subValue instanceof Object && metadata.options.discriminator.property in subValue) {
                          delete subValue[metadata.options.discriminator.property];
                        }
                      }
                    }
                    if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
                      type = subValue.constructor;
                    }
                    if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                      if (subValue) {
                        subValue[metadata.options.discriminator.property] = metadata.options.discriminator.subTypes.find((subType) => subType.value === subValue.constructor).name;
                      }
                    }
                  } else {
                    type = metadata;
                  }
                } else {
                  type = newType;
                }
                isSubValueMap = isSubValueMap || metadata.reflectedType === Map;
              } else if (this.options.targetMaps) {
                this.options.targetMaps.filter((map) => map.target === targetType && !!map.properties[propertyName]).forEach((map) => type = map.properties[propertyName]);
              } else if (this.options.enableImplicitConversion && this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
                const reflectedType = Reflect.getMetadata("design:type", targetType.prototype, propertyName);
                if (reflectedType) {
                  type = reflectedType;
                }
              }
            }
            const arrayType2 = Array.isArray(value[valueKey]) ? this.getReflectedType(targetType, propertyName) : void 0;
            const subSource = source ? source[valueKey] : void 0;
            if (newValue.constructor.prototype) {
              const descriptor = Object.getOwnPropertyDescriptor(newValue.constructor.prototype, newValueKey);
              if ((this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS || this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) && (descriptor && !descriptor.set || newValue[newValueKey] instanceof Function))
                continue;
            }
            if (!this.options.enableCircularCheck || !this.isCircular(subValue)) {
              const transformKey = this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS ? newValueKey : key;
              let finalValue;
              if (this.transformationType === enums_1.TransformationType.CLASS_TO_PLAIN) {
                finalValue = value[transformKey];
                finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);
                finalValue = value[transformKey] === finalValue ? subValue : finalValue;
                finalValue = this.transform(subSource, finalValue, type, arrayType2, isSubValueMap, level + 1);
              } else {
                if (subValue === void 0 && this.options.exposeDefaultValues) {
                  finalValue = newValue[newValueKey];
                } else {
                  finalValue = this.transform(subSource, subValue, type, arrayType2, isSubValueMap, level + 1);
                  finalValue = this.applyCustomTransformations(finalValue, targetType, transformKey, value, this.transformationType);
                }
              }
              if (finalValue !== void 0 || this.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            } else if (this.transformationType === enums_1.TransformationType.CLASS_TO_CLASS) {
              let finalValue = subValue;
              finalValue = this.applyCustomTransformations(finalValue, targetType, key, value, this.transformationType);
              if (finalValue !== void 0 || this.options.exposeUnsetFields) {
                if (newValue instanceof Map) {
                  newValue.set(newValueKey, finalValue);
                } else {
                  newValue[newValueKey] = finalValue;
                }
              }
            }
          }
          if (this.options.enableCircularCheck) {
            this.recursionStack.delete(value);
          }
          return newValue;
        } else {
          return value;
        }
      }
      applyCustomTransformations(value, target, key, obj, transformationType) {
        let metadatas = storage_1.defaultMetadataStorage.findTransformMetadatas(target, key, this.transformationType);
        if (this.options.version !== void 0) {
          metadatas = metadatas.filter((metadata) => {
            if (!metadata.options)
              return true;
            return this.checkVersion(metadata.options.since, metadata.options.until);
          });
        }
        if (this.options.groups && this.options.groups.length) {
          metadatas = metadatas.filter((metadata) => {
            if (!metadata.options)
              return true;
            return this.checkGroups(metadata.options.groups);
          });
        } else {
          metadatas = metadatas.filter((metadata) => {
            return !metadata.options || !metadata.options.groups || !metadata.options.groups.length;
          });
        }
        metadatas.forEach((metadata) => {
          value = metadata.transformFn({ value, key, obj, type: transformationType, options: this.options });
        });
        return value;
      }
      isCircular(object) {
        return this.recursionStack.has(object);
      }
      getReflectedType(target, propertyName) {
        if (!target)
          return void 0;
        const meta = storage_1.defaultMetadataStorage.findTypeMetadata(target, propertyName);
        return meta ? meta.reflectedType : void 0;
      }
      getKeys(target, object, isMap) {
        let strategy = storage_1.defaultMetadataStorage.getStrategy(target);
        if (strategy === "none")
          strategy = this.options.strategy || "exposeAll";
        let keys = [];
        if (strategy === "exposeAll" || isMap) {
          if (object instanceof Map) {
            keys = Array.from(object.keys());
          } else {
            keys = Object.keys(object);
          }
        }
        if (isMap) {
          return keys;
        }
        if (this.options.ignoreDecorators && this.options.excludeExtraneousValues && target) {
          const exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          const excludedProperties = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          keys = [...exposedProperties, ...excludedProperties];
        }
        if (!this.options.ignoreDecorators && target) {
          let exposedProperties = storage_1.defaultMetadataStorage.getExposedProperties(target, this.transformationType);
          if (this.transformationType === enums_1.TransformationType.PLAIN_TO_CLASS) {
            exposedProperties = exposedProperties.map((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (exposeMetadata && exposeMetadata.options && exposeMetadata.options.name) {
                return exposeMetadata.options.name;
              }
              return key;
            });
          }
          if (this.options.excludeExtraneousValues) {
            keys = exposedProperties;
          } else {
            keys = keys.concat(exposedProperties);
          }
          const excludedProperties = storage_1.defaultMetadataStorage.getExcludedProperties(target, this.transformationType);
          if (excludedProperties.length > 0) {
            keys = keys.filter((key) => {
              return !excludedProperties.includes(key);
            });
          }
          if (this.options.version !== void 0) {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return this.checkVersion(exposeMetadata.options.since, exposeMetadata.options.until);
            });
          }
          if (this.options.groups && this.options.groups.length) {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              if (!exposeMetadata || !exposeMetadata.options)
                return true;
              return this.checkGroups(exposeMetadata.options.groups);
            });
          } else {
            keys = keys.filter((key) => {
              const exposeMetadata = storage_1.defaultMetadataStorage.findExposeMetadata(target, key);
              return !exposeMetadata || !exposeMetadata.options || !exposeMetadata.options.groups || !exposeMetadata.options.groups.length;
            });
          }
        }
        if (this.options.excludePrefixes && this.options.excludePrefixes.length) {
          keys = keys.filter((key) => this.options.excludePrefixes.every((prefix) => {
            return key.substr(0, prefix.length) !== prefix;
          }));
        }
        keys = keys.filter((key, index, self2) => {
          return self2.indexOf(key) === index;
        });
        return keys;
      }
      checkVersion(since, until) {
        let decision = true;
        if (decision && since)
          decision = this.options.version >= since;
        if (decision && until)
          decision = this.options.version < until;
        return decision;
      }
      checkGroups(groups) {
        if (!groups)
          return true;
        return this.options.groups.some((optionGroup) => groups.includes(optionGroup));
      }
    };
    exports2.TransformOperationExecutor = TransformOperationExecutor;
  }
});

// node_modules/class-transformer/cjs/constants/default-options.constant.js
var require_default_options_constant = __commonJS({
  "node_modules/class-transformer/cjs/constants/default-options.constant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultOptions = void 0;
    exports2.defaultOptions = {
      enableCircularCheck: false,
      enableImplicitConversion: false,
      excludeExtraneousValues: false,
      excludePrefixes: void 0,
      exposeDefaultValues: false,
      exposeUnsetFields: true,
      groups: void 0,
      ignoreDecorators: false,
      strategy: void 0,
      targetMaps: void 0,
      version: void 0
    };
  }
});

// node_modules/class-transformer/cjs/ClassTransformer.js
var require_ClassTransformer = __commonJS({
  "node_modules/class-transformer/cjs/ClassTransformer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClassTransformer = void 0;
    var TransformOperationExecutor_1 = require_TransformOperationExecutor();
    var enums_1 = require_enums();
    var default_options_constant_1 = require_default_options_constant();
    var ClassTransformer = class {
      instanceToPlain(object, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_PLAIN, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      }
      classToPlainFromExist(object, plainObject, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_PLAIN, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(plainObject, object, void 0, void 0, void 0, void 0);
      }
      plainToInstance(cls, plain, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.PLAIN_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, plain, cls, void 0, void 0, void 0);
      }
      plainToClassFromExist(clsObject, plain, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.PLAIN_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(clsObject, plain, void 0, void 0, void 0, void 0);
      }
      instanceToInstance(object, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(void 0, object, void 0, void 0, void 0, void 0);
      }
      classToClassFromExist(object, fromObject, options) {
        const executor = new TransformOperationExecutor_1.TransformOperationExecutor(enums_1.TransformationType.CLASS_TO_CLASS, {
          ...default_options_constant_1.defaultOptions,
          ...options
        });
        return executor.transform(fromObject, object, void 0, void 0, void 0, void 0);
      }
      serialize(object, options) {
        return JSON.stringify(this.instanceToPlain(object, options));
      }
      deserialize(cls, json, options) {
        const jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      }
      deserializeArray(cls, json, options) {
        const jsonObject = JSON.parse(json);
        return this.plainToInstance(cls, jsonObject, options);
      }
    };
    exports2.ClassTransformer = ClassTransformer;
  }
});

// node_modules/class-transformer/cjs/decorators/exclude.decorator.js
var require_exclude_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/exclude.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Exclude = void 0;
    var storage_1 = require_storage();
    function Exclude(options = {}) {
      return function(object, propertyName) {
        storage_1.defaultMetadataStorage.addExcludeMetadata({
          target: object instanceof Function ? object : object.constructor,
          propertyName,
          options
        });
      };
    }
    exports2.Exclude = Exclude;
  }
});

// node_modules/class-transformer/cjs/decorators/expose.decorator.js
var require_expose_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/expose.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Expose = void 0;
    var storage_1 = require_storage();
    function Expose(options = {}) {
      return function(object, propertyName) {
        storage_1.defaultMetadataStorage.addExposeMetadata({
          target: object instanceof Function ? object : object.constructor,
          propertyName,
          options
        });
      };
    }
    exports2.Expose = Expose;
  }
});

// node_modules/class-transformer/cjs/decorators/transform-instance-to-instance.decorator.js
var require_transform_instance_to_instance_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/transform-instance-to-instance.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformInstanceToInstance = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformInstanceToInstance(params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.instanceToInstance(data, params)) : classTransformer.instanceToInstance(result, params);
        };
      };
    }
    exports2.TransformInstanceToInstance = TransformInstanceToInstance;
  }
});

// node_modules/class-transformer/cjs/decorators/transform-instance-to-plain.decorator.js
var require_transform_instance_to_plain_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/transform-instance-to-plain.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformInstanceToPlain = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformInstanceToPlain(params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.instanceToPlain(data, params)) : classTransformer.instanceToPlain(result, params);
        };
      };
    }
    exports2.TransformInstanceToPlain = TransformInstanceToPlain;
  }
});

// node_modules/class-transformer/cjs/decorators/transform-plain-to-instance.decorator.js
var require_transform_plain_to_instance_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/transform-plain-to-instance.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TransformPlainToInstance = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    function TransformPlainToInstance(classType, params) {
      return function(target, propertyKey, descriptor) {
        const classTransformer = new ClassTransformer_1.ClassTransformer();
        const originalMethod = descriptor.value;
        descriptor.value = function(...args) {
          const result = originalMethod.apply(this, args);
          const isPromise = !!result && (typeof result === "object" || typeof result === "function") && typeof result.then === "function";
          return isPromise ? result.then((data) => classTransformer.plainToInstance(classType, data, params)) : classTransformer.plainToInstance(classType, result, params);
        };
      };
    }
    exports2.TransformPlainToInstance = TransformPlainToInstance;
  }
});

// node_modules/class-transformer/cjs/decorators/transform.decorator.js
var require_transform_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/transform.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transform = void 0;
    var storage_1 = require_storage();
    function Transform(transformFn, options = {}) {
      return function(target, propertyName) {
        storage_1.defaultMetadataStorage.addTransformMetadata({
          target: target.constructor,
          propertyName,
          transformFn,
          options
        });
      };
    }
    exports2.Transform = Transform;
  }
});

// node_modules/class-transformer/cjs/decorators/type.decorator.js
var require_type_decorator = __commonJS({
  "node_modules/class-transformer/cjs/decorators/type.decorator.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Type = void 0;
    var storage_1 = require_storage();
    function Type(typeFunction, options = {}) {
      return function(target, propertyName) {
        const reflectedType = Reflect.getMetadata("design:type", target, propertyName);
        storage_1.defaultMetadataStorage.addTypeMetadata({
          target: target.constructor,
          propertyName,
          reflectedType,
          typeFunction,
          options
        });
      };
    }
    exports2.Type = Type;
  }
});

// node_modules/class-transformer/cjs/decorators/index.js
var require_decorators = __commonJS({
  "node_modules/class-transformer/cjs/decorators/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_exclude_decorator(), exports2);
    __exportStar(require_expose_decorator(), exports2);
    __exportStar(require_transform_instance_to_instance_decorator(), exports2);
    __exportStar(require_transform_instance_to_plain_decorator(), exports2);
    __exportStar(require_transform_plain_to_instance_decorator(), exports2);
    __exportStar(require_transform_decorator(), exports2);
    __exportStar(require_type_decorator(), exports2);
  }
});

// node_modules/class-transformer/cjs/interfaces/decorator-options/expose-options.interface.js
var require_expose_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/decorator-options/expose-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/decorator-options/exclude-options.interface.js
var require_exclude_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/decorator-options/exclude-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/decorator-options/transform-options.interface.js
var require_transform_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/decorator-options/transform-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/decorator-options/type-discriminator-descriptor.interface.js
var require_type_discriminator_descriptor_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/decorator-options/type-discriminator-descriptor.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/decorator-options/type-options.interface.js
var require_type_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/decorator-options/type-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/metadata/exclude-metadata.interface.js
var require_exclude_metadata_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/metadata/exclude-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/metadata/expose-metadata.interface.js
var require_expose_metadata_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/metadata/expose-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/metadata/transform-metadata.interface.js
var require_transform_metadata_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/metadata/transform-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/metadata/transform-fn-params.interface.js
var require_transform_fn_params_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/metadata/transform-fn-params.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/metadata/type-metadata.interface.js
var require_type_metadata_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/metadata/type-metadata.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/class-constructor.type.js
var require_class_constructor_type = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/class-constructor.type.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/class-transformer-options.interface.js
var require_class_transformer_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/class-transformer-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/target-map.interface.js
var require_target_map_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/target-map.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/type-help-options.interface.js
var require_type_help_options_interface = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/type-help-options.interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/class-transformer/cjs/interfaces/index.js
var require_interfaces = __commonJS({
  "node_modules/class-transformer/cjs/interfaces/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_expose_options_interface(), exports2);
    __exportStar(require_exclude_options_interface(), exports2);
    __exportStar(require_transform_options_interface(), exports2);
    __exportStar(require_type_discriminator_descriptor_interface(), exports2);
    __exportStar(require_type_options_interface(), exports2);
    __exportStar(require_exclude_metadata_interface(), exports2);
    __exportStar(require_expose_metadata_interface(), exports2);
    __exportStar(require_transform_metadata_interface(), exports2);
    __exportStar(require_transform_fn_params_interface(), exports2);
    __exportStar(require_type_metadata_interface(), exports2);
    __exportStar(require_class_constructor_type(), exports2);
    __exportStar(require_class_transformer_options_interface(), exports2);
    __exportStar(require_target_map_interface(), exports2);
    __exportStar(require_type_help_options_interface(), exports2);
  }
});

// node_modules/class-transformer/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/class-transformer/cjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.deserializeArray = exports2.deserialize = exports2.serialize = exports2.classToClassFromExist = exports2.instanceToInstance = exports2.plainToClassFromExist = exports2.plainToInstance = exports2.plainToClass = exports2.classToPlainFromExist = exports2.instanceToPlain = exports2.classToPlain = exports2.ClassTransformer = void 0;
    var ClassTransformer_1 = require_ClassTransformer();
    var ClassTransformer_2 = require_ClassTransformer();
    Object.defineProperty(exports2, "ClassTransformer", { enumerable: true, get: function() {
      return ClassTransformer_2.ClassTransformer;
    } });
    __exportStar(require_decorators(), exports2);
    __exportStar(require_interfaces(), exports2);
    __exportStar(require_enums(), exports2);
    var classTransformer = new ClassTransformer_1.ClassTransformer();
    function classToPlain(object, options) {
      return classTransformer.instanceToPlain(object, options);
    }
    exports2.classToPlain = classToPlain;
    function instanceToPlain(object, options) {
      return classTransformer.instanceToPlain(object, options);
    }
    exports2.instanceToPlain = instanceToPlain;
    function classToPlainFromExist(object, plainObject, options) {
      return classTransformer.classToPlainFromExist(object, plainObject, options);
    }
    exports2.classToPlainFromExist = classToPlainFromExist;
    function plainToClass(cls, plain, options) {
      return classTransformer.plainToInstance(cls, plain, options);
    }
    exports2.plainToClass = plainToClass;
    function plainToInstance(cls, plain, options) {
      return classTransformer.plainToInstance(cls, plain, options);
    }
    exports2.plainToInstance = plainToInstance;
    function plainToClassFromExist(clsObject, plain, options) {
      return classTransformer.plainToClassFromExist(clsObject, plain, options);
    }
    exports2.plainToClassFromExist = plainToClassFromExist;
    function instanceToInstance(object, options) {
      return classTransformer.instanceToInstance(object, options);
    }
    exports2.instanceToInstance = instanceToInstance;
    function classToClassFromExist(object, fromObject, options) {
      return classTransformer.classToClassFromExist(object, fromObject, options);
    }
    exports2.classToClassFromExist = classToClassFromExist;
    function serialize(object, options) {
      return classTransformer.serialize(object, options);
    }
    exports2.serialize = serialize;
    function deserialize(cls, json, options) {
      return classTransformer.deserialize(cls, json, options);
    }
    exports2.deserialize = deserialize;
    function deserializeArray(cls, json, options) {
      return classTransformer.deserializeArray(cls, json, options);
    }
    exports2.deserializeArray = deserializeArray;
  }
});

// node_modules/reflect-metadata/Reflect.js
var require_Reflect = __commonJS({
  "node_modules/reflect-metadata/Reflect.js"() {
    var Reflect2;
    (function(Reflect3) {
      (function(factory) {
        var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : Function("return this;")();
        var exporter = makeExporter(Reflect3);
        if (typeof root.Reflect === "undefined") {
          root.Reflect = Reflect3;
        } else {
          exporter = makeExporter(root.Reflect, exporter);
        }
        factory(exporter);
        function makeExporter(target, previous) {
          return function(key, value) {
            if (typeof target[key] !== "function") {
              Object.defineProperty(target, key, { configurable: true, writable: true, value });
            }
            if (previous)
              previous(key, value);
          };
        }
      })(function(exporter) {
        var hasOwn = Object.prototype.hasOwnProperty;
        var supportsSymbol = typeof Symbol === "function";
        var toPrimitiveSymbol = supportsSymbol && typeof Symbol.toPrimitive !== "undefined" ? Symbol.toPrimitive : "@@toPrimitive";
        var iteratorSymbol = supportsSymbol && typeof Symbol.iterator !== "undefined" ? Symbol.iterator : "@@iterator";
        var supportsCreate = typeof Object.create === "function";
        var supportsProto = { __proto__: [] } instanceof Array;
        var downLevel = !supportsCreate && !supportsProto;
        var HashMap = {
          create: supportsCreate ? function() {
            return MakeDictionary(/* @__PURE__ */ Object.create(null));
          } : supportsProto ? function() {
            return MakeDictionary({ __proto__: null });
          } : function() {
            return MakeDictionary({});
          },
          has: downLevel ? function(map, key) {
            return hasOwn.call(map, key);
          } : function(map, key) {
            return key in map;
          },
          get: downLevel ? function(map, key) {
            return hasOwn.call(map, key) ? map[key] : void 0;
          } : function(map, key) {
            return map[key];
          }
        };
        var functionPrototype = Object.getPrototypeOf(Function);
        var usePolyfill = typeof process === "object" && process.env && process.env["REFLECT_METADATA_USE_MAP_POLYFILL"] === "true";
        var _Map = !usePolyfill && typeof Map === "function" && typeof Map.prototype.entries === "function" ? Map : CreateMapPolyfill();
        var _Set = !usePolyfill && typeof Set === "function" && typeof Set.prototype.entries === "function" ? Set : CreateSetPolyfill();
        var _WeakMap = !usePolyfill && typeof WeakMap === "function" ? WeakMap : CreateWeakMapPolyfill();
        var Metadata = new _WeakMap();
        function decorate(decorators, target, propertyKey, attributes) {
          if (!IsUndefined(propertyKey)) {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsObject(target))
              throw new TypeError();
            if (!IsObject(attributes) && !IsUndefined(attributes) && !IsNull(attributes))
              throw new TypeError();
            if (IsNull(attributes))
              attributes = void 0;
            propertyKey = ToPropertyKey(propertyKey);
            return DecorateProperty(decorators, target, propertyKey, attributes);
          } else {
            if (!IsArray(decorators))
              throw new TypeError();
            if (!IsConstructor(target))
              throw new TypeError();
            return DecorateConstructor(decorators, target);
          }
        }
        exporter("decorate", decorate);
        function metadata(metadataKey, metadataValue) {
          function decorator(target, propertyKey) {
            if (!IsObject(target))
              throw new TypeError();
            if (!IsUndefined(propertyKey) && !IsPropertyKey(propertyKey))
              throw new TypeError();
            OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
          }
          return decorator;
        }
        exporter("metadata", metadata);
        function defineMetadata(metadataKey, metadataValue, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryDefineOwnMetadata(metadataKey, metadataValue, target, propertyKey);
        }
        exporter("defineMetadata", defineMetadata);
        function hasMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasMetadata", hasMetadata);
        function hasOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryHasOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("hasOwnMetadata", hasOwnMetadata);
        function getMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetMetadata(metadataKey, target, propertyKey);
        }
        exporter("getMetadata", getMetadata);
        function getOwnMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryGetOwnMetadata(metadataKey, target, propertyKey);
        }
        exporter("getOwnMetadata", getOwnMetadata);
        function getMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryMetadataKeys(target, propertyKey);
        }
        exporter("getMetadataKeys", getMetadataKeys);
        function getOwnMetadataKeys(target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          return OrdinaryOwnMetadataKeys(target, propertyKey);
        }
        exporter("getOwnMetadataKeys", getOwnMetadataKeys);
        function deleteMetadata(metadataKey, target, propertyKey) {
          if (!IsObject(target))
            throw new TypeError();
          if (!IsUndefined(propertyKey))
            propertyKey = ToPropertyKey(propertyKey);
          var metadataMap = GetOrCreateMetadataMap(target, propertyKey, false);
          if (IsUndefined(metadataMap))
            return false;
          if (!metadataMap.delete(metadataKey))
            return false;
          if (metadataMap.size > 0)
            return true;
          var targetMetadata = Metadata.get(target);
          targetMetadata.delete(propertyKey);
          if (targetMetadata.size > 0)
            return true;
          Metadata.delete(target);
          return true;
        }
        exporter("deleteMetadata", deleteMetadata);
        function DecorateConstructor(decorators, target) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsConstructor(decorated))
                throw new TypeError();
              target = decorated;
            }
          }
          return target;
        }
        function DecorateProperty(decorators, target, propertyKey, descriptor) {
          for (var i = decorators.length - 1; i >= 0; --i) {
            var decorator = decorators[i];
            var decorated = decorator(target, propertyKey, descriptor);
            if (!IsUndefined(decorated) && !IsNull(decorated)) {
              if (!IsObject(decorated))
                throw new TypeError();
              descriptor = decorated;
            }
          }
          return descriptor;
        }
        function GetOrCreateMetadataMap(O, P, Create) {
          var targetMetadata = Metadata.get(O);
          if (IsUndefined(targetMetadata)) {
            if (!Create)
              return void 0;
            targetMetadata = new _Map();
            Metadata.set(O, targetMetadata);
          }
          var metadataMap = targetMetadata.get(P);
          if (IsUndefined(metadataMap)) {
            if (!Create)
              return void 0;
            metadataMap = new _Map();
            targetMetadata.set(P, metadataMap);
          }
          return metadataMap;
        }
        function OrdinaryHasMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return true;
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryHasMetadata(MetadataKey, parent, P);
          return false;
        }
        function OrdinaryHasOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return false;
          return ToBoolean(metadataMap.has(MetadataKey));
        }
        function OrdinaryGetMetadata(MetadataKey, O, P) {
          var hasOwn2 = OrdinaryHasOwnMetadata(MetadataKey, O, P);
          if (hasOwn2)
            return OrdinaryGetOwnMetadata(MetadataKey, O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (!IsNull(parent))
            return OrdinaryGetMetadata(MetadataKey, parent, P);
          return void 0;
        }
        function OrdinaryGetOwnMetadata(MetadataKey, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return void 0;
          return metadataMap.get(MetadataKey);
        }
        function OrdinaryDefineOwnMetadata(MetadataKey, MetadataValue, O, P) {
          var metadataMap = GetOrCreateMetadataMap(O, P, true);
          metadataMap.set(MetadataKey, MetadataValue);
        }
        function OrdinaryMetadataKeys(O, P) {
          var ownKeys = OrdinaryOwnMetadataKeys(O, P);
          var parent = OrdinaryGetPrototypeOf(O);
          if (parent === null)
            return ownKeys;
          var parentKeys = OrdinaryMetadataKeys(parent, P);
          if (parentKeys.length <= 0)
            return ownKeys;
          if (ownKeys.length <= 0)
            return parentKeys;
          var set = new _Set();
          var keys = [];
          for (var _i = 0, ownKeys_1 = ownKeys; _i < ownKeys_1.length; _i++) {
            var key = ownKeys_1[_i];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          for (var _a = 0, parentKeys_1 = parentKeys; _a < parentKeys_1.length; _a++) {
            var key = parentKeys_1[_a];
            var hasKey = set.has(key);
            if (!hasKey) {
              set.add(key);
              keys.push(key);
            }
          }
          return keys;
        }
        function OrdinaryOwnMetadataKeys(O, P) {
          var keys = [];
          var metadataMap = GetOrCreateMetadataMap(O, P, false);
          if (IsUndefined(metadataMap))
            return keys;
          var keysObj = metadataMap.keys();
          var iterator = GetIterator(keysObj);
          var k = 0;
          while (true) {
            var next = IteratorStep(iterator);
            if (!next) {
              keys.length = k;
              return keys;
            }
            var nextValue = IteratorValue(next);
            try {
              keys[k] = nextValue;
            } catch (e) {
              try {
                IteratorClose(iterator);
              } finally {
                throw e;
              }
            }
            k++;
          }
        }
        function Type(x) {
          if (x === null)
            return 1;
          switch (typeof x) {
            case "undefined":
              return 0;
            case "boolean":
              return 2;
            case "string":
              return 3;
            case "symbol":
              return 4;
            case "number":
              return 5;
            case "object":
              return x === null ? 1 : 6;
            default:
              return 6;
          }
        }
        function IsUndefined(x) {
          return x === void 0;
        }
        function IsNull(x) {
          return x === null;
        }
        function IsSymbol(x) {
          return typeof x === "symbol";
        }
        function IsObject(x) {
          return typeof x === "object" ? x !== null : typeof x === "function";
        }
        function ToPrimitive(input, PreferredType) {
          switch (Type(input)) {
            case 0:
              return input;
            case 1:
              return input;
            case 2:
              return input;
            case 3:
              return input;
            case 4:
              return input;
            case 5:
              return input;
          }
          var hint = PreferredType === 3 ? "string" : PreferredType === 5 ? "number" : "default";
          var exoticToPrim = GetMethod(input, toPrimitiveSymbol);
          if (exoticToPrim !== void 0) {
            var result = exoticToPrim.call(input, hint);
            if (IsObject(result))
              throw new TypeError();
            return result;
          }
          return OrdinaryToPrimitive(input, hint === "default" ? "number" : hint);
        }
        function OrdinaryToPrimitive(O, hint) {
          if (hint === "string") {
            var toString_1 = O.toString;
            if (IsCallable(toString_1)) {
              var result = toString_1.call(O);
              if (!IsObject(result))
                return result;
            }
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
          } else {
            var valueOf = O.valueOf;
            if (IsCallable(valueOf)) {
              var result = valueOf.call(O);
              if (!IsObject(result))
                return result;
            }
            var toString_2 = O.toString;
            if (IsCallable(toString_2)) {
              var result = toString_2.call(O);
              if (!IsObject(result))
                return result;
            }
          }
          throw new TypeError();
        }
        function ToBoolean(argument) {
          return !!argument;
        }
        function ToString(argument) {
          return "" + argument;
        }
        function ToPropertyKey(argument) {
          var key = ToPrimitive(argument, 3);
          if (IsSymbol(key))
            return key;
          return ToString(key);
        }
        function IsArray(argument) {
          return Array.isArray ? Array.isArray(argument) : argument instanceof Object ? argument instanceof Array : Object.prototype.toString.call(argument) === "[object Array]";
        }
        function IsCallable(argument) {
          return typeof argument === "function";
        }
        function IsConstructor(argument) {
          return typeof argument === "function";
        }
        function IsPropertyKey(argument) {
          switch (Type(argument)) {
            case 3:
              return true;
            case 4:
              return true;
            default:
              return false;
          }
        }
        function GetMethod(V, P) {
          var func = V[P];
          if (func === void 0 || func === null)
            return void 0;
          if (!IsCallable(func))
            throw new TypeError();
          return func;
        }
        function GetIterator(obj) {
          var method = GetMethod(obj, iteratorSymbol);
          if (!IsCallable(method))
            throw new TypeError();
          var iterator = method.call(obj);
          if (!IsObject(iterator))
            throw new TypeError();
          return iterator;
        }
        function IteratorValue(iterResult) {
          return iterResult.value;
        }
        function IteratorStep(iterator) {
          var result = iterator.next();
          return result.done ? false : result;
        }
        function IteratorClose(iterator) {
          var f = iterator["return"];
          if (f)
            f.call(iterator);
        }
        function OrdinaryGetPrototypeOf(O) {
          var proto = Object.getPrototypeOf(O);
          if (typeof O !== "function" || O === functionPrototype)
            return proto;
          if (proto !== functionPrototype)
            return proto;
          var prototype = O.prototype;
          var prototypeProto = prototype && Object.getPrototypeOf(prototype);
          if (prototypeProto == null || prototypeProto === Object.prototype)
            return proto;
          var constructor = prototypeProto.constructor;
          if (typeof constructor !== "function")
            return proto;
          if (constructor === O)
            return proto;
          return constructor;
        }
        function CreateMapPolyfill() {
          var cacheSentinel = {};
          var arraySentinel = [];
          var MapIterator = function() {
            function MapIterator2(keys, values, selector) {
              this._index = 0;
              this._keys = keys;
              this._values = values;
              this._selector = selector;
            }
            MapIterator2.prototype["@@iterator"] = function() {
              return this;
            };
            MapIterator2.prototype[iteratorSymbol] = function() {
              return this;
            };
            MapIterator2.prototype.next = function() {
              var index = this._index;
              if (index >= 0 && index < this._keys.length) {
                var result = this._selector(this._keys[index], this._values[index]);
                if (index + 1 >= this._keys.length) {
                  this._index = -1;
                  this._keys = arraySentinel;
                  this._values = arraySentinel;
                } else {
                  this._index++;
                }
                return { value: result, done: false };
              }
              return { value: void 0, done: true };
            };
            MapIterator2.prototype.throw = function(error) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              throw error;
            };
            MapIterator2.prototype.return = function(value) {
              if (this._index >= 0) {
                this._index = -1;
                this._keys = arraySentinel;
                this._values = arraySentinel;
              }
              return { value, done: true };
            };
            return MapIterator2;
          }();
          return function() {
            function Map2() {
              this._keys = [];
              this._values = [];
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            }
            Object.defineProperty(Map2.prototype, "size", {
              get: function() {
                return this._keys.length;
              },
              enumerable: true,
              configurable: true
            });
            Map2.prototype.has = function(key) {
              return this._find(key, false) >= 0;
            };
            Map2.prototype.get = function(key) {
              var index = this._find(key, false);
              return index >= 0 ? this._values[index] : void 0;
            };
            Map2.prototype.set = function(key, value) {
              var index = this._find(key, true);
              this._values[index] = value;
              return this;
            };
            Map2.prototype.delete = function(key) {
              var index = this._find(key, false);
              if (index >= 0) {
                var size = this._keys.length;
                for (var i = index + 1; i < size; i++) {
                  this._keys[i - 1] = this._keys[i];
                  this._values[i - 1] = this._values[i];
                }
                this._keys.length--;
                this._values.length--;
                if (key === this._cacheKey) {
                  this._cacheKey = cacheSentinel;
                  this._cacheIndex = -2;
                }
                return true;
              }
              return false;
            };
            Map2.prototype.clear = function() {
              this._keys.length = 0;
              this._values.length = 0;
              this._cacheKey = cacheSentinel;
              this._cacheIndex = -2;
            };
            Map2.prototype.keys = function() {
              return new MapIterator(this._keys, this._values, getKey);
            };
            Map2.prototype.values = function() {
              return new MapIterator(this._keys, this._values, getValue);
            };
            Map2.prototype.entries = function() {
              return new MapIterator(this._keys, this._values, getEntry);
            };
            Map2.prototype["@@iterator"] = function() {
              return this.entries();
            };
            Map2.prototype[iteratorSymbol] = function() {
              return this.entries();
            };
            Map2.prototype._find = function(key, insert) {
              if (this._cacheKey !== key) {
                this._cacheIndex = this._keys.indexOf(this._cacheKey = key);
              }
              if (this._cacheIndex < 0 && insert) {
                this._cacheIndex = this._keys.length;
                this._keys.push(key);
                this._values.push(void 0);
              }
              return this._cacheIndex;
            };
            return Map2;
          }();
          function getKey(key, _) {
            return key;
          }
          function getValue(_, value) {
            return value;
          }
          function getEntry(key, value) {
            return [key, value];
          }
        }
        function CreateSetPolyfill() {
          return function() {
            function Set2() {
              this._map = new _Map();
            }
            Object.defineProperty(Set2.prototype, "size", {
              get: function() {
                return this._map.size;
              },
              enumerable: true,
              configurable: true
            });
            Set2.prototype.has = function(value) {
              return this._map.has(value);
            };
            Set2.prototype.add = function(value) {
              return this._map.set(value, value), this;
            };
            Set2.prototype.delete = function(value) {
              return this._map.delete(value);
            };
            Set2.prototype.clear = function() {
              this._map.clear();
            };
            Set2.prototype.keys = function() {
              return this._map.keys();
            };
            Set2.prototype.values = function() {
              return this._map.values();
            };
            Set2.prototype.entries = function() {
              return this._map.entries();
            };
            Set2.prototype["@@iterator"] = function() {
              return this.keys();
            };
            Set2.prototype[iteratorSymbol] = function() {
              return this.keys();
            };
            return Set2;
          }();
        }
        function CreateWeakMapPolyfill() {
          var UUID_SIZE = 16;
          var keys = HashMap.create();
          var rootKey = CreateUniqueKey();
          return function() {
            function WeakMap2() {
              this._key = CreateUniqueKey();
            }
            WeakMap2.prototype.has = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.has(table, this._key) : false;
            };
            WeakMap2.prototype.get = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? HashMap.get(table, this._key) : void 0;
            };
            WeakMap2.prototype.set = function(target, value) {
              var table = GetOrCreateWeakMapTable(target, true);
              table[this._key] = value;
              return this;
            };
            WeakMap2.prototype.delete = function(target) {
              var table = GetOrCreateWeakMapTable(target, false);
              return table !== void 0 ? delete table[this._key] : false;
            };
            WeakMap2.prototype.clear = function() {
              this._key = CreateUniqueKey();
            };
            return WeakMap2;
          }();
          function CreateUniqueKey() {
            var key;
            do
              key = "@@WeakMap@@" + CreateUUID();
            while (HashMap.has(keys, key));
            keys[key] = true;
            return key;
          }
          function GetOrCreateWeakMapTable(target, create) {
            if (!hasOwn.call(target, rootKey)) {
              if (!create)
                return void 0;
              Object.defineProperty(target, rootKey, { value: HashMap.create() });
            }
            return target[rootKey];
          }
          function FillRandomBytes(buffer, size) {
            for (var i = 0; i < size; ++i)
              buffer[i] = Math.random() * 255 | 0;
            return buffer;
          }
          function GenRandomBytes(size) {
            if (typeof Uint8Array === "function") {
              if (typeof crypto !== "undefined")
                return crypto.getRandomValues(new Uint8Array(size));
              if (typeof msCrypto !== "undefined")
                return msCrypto.getRandomValues(new Uint8Array(size));
              return FillRandomBytes(new Uint8Array(size), size);
            }
            return FillRandomBytes(new Array(size), size);
          }
          function CreateUUID() {
            var data = GenRandomBytes(UUID_SIZE);
            data[6] = data[6] & 79 | 64;
            data[8] = data[8] & 191 | 128;
            var result = "";
            for (var offset = 0; offset < UUID_SIZE; ++offset) {
              var byte = data[offset];
              if (offset === 4 || offset === 6 || offset === 8)
                result += "-";
              if (byte < 16)
                result += "0";
              result += byte.toString(16).toLowerCase();
            }
            return result;
          }
        }
        function MakeDictionary(obj) {
          obj.__ = void 0;
          delete obj.__;
          return obj;
        }
      });
    })(Reflect2 || (Reflect2 = {}));
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/messages.js
var require_messages3 = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/messages.js"(exports2) {
    "use strict";
    var __decorate = exports2 && exports2.__decorate || function(decorators, target, key, desc) {
      var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
      if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
        r = Reflect.decorate(decorators, target, key, desc);
      else
        for (var i = decorators.length - 1; i >= 0; i--)
          if (d = decorators[i])
            r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
      return c > 3 && r && Object.defineProperty(target, key, r), r;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestStepFinished = exports2.TestRunStarted = exports2.TestRunFinished = exports2.TestCaseStarted = exports2.TestCaseFinished = exports2.TestStep = exports2.StepMatchArgumentsList = exports2.StepMatchArgument = exports2.Group = exports2.TestCase = exports2.StepDefinitionPattern = exports2.StepDefinition = exports2.JavaStackTraceElement = exports2.JavaMethod = exports2.SourceReference = exports2.Source = exports2.PickleTag = exports2.PickleTableRow = exports2.PickleTableCell = exports2.PickleTable = exports2.PickleStepArgument = exports2.PickleStep = exports2.PickleDocString = exports2.Pickle = exports2.ParseError = exports2.ParameterType = exports2.Product = exports2.Git = exports2.Ci = exports2.Meta = exports2.Location = exports2.Hook = exports2.Tag = exports2.TableRow = exports2.TableCell = exports2.Step = exports2.Scenario = exports2.RuleChild = exports2.Rule = exports2.FeatureChild = exports2.Feature = exports2.Examples = exports2.DocString = exports2.DataTable = exports2.Comment = exports2.Background = exports2.GherkinDocument = exports2.Envelope = exports2.Duration = exports2.Attachment = void 0;
    exports2.TestStepResultStatus = exports2.StepKeywordType = exports2.StepDefinitionPatternType = exports2.SourceMediaType = exports2.PickleStepType = exports2.AttachmentContentEncoding = exports2.UndefinedParameterType = exports2.Timestamp = exports2.TestStepStarted = exports2.TestStepResult = void 0;
    var class_transformer_1 = require_cjs();
    require_Reflect();
    var Attachment = function() {
      function Attachment2() {
        this.body = "";
        this.contentEncoding = AttachmentContentEncoding.IDENTITY;
        this.mediaType = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Source;
        })
      ], Attachment2.prototype, "source", void 0);
      return Attachment2;
    }();
    exports2.Attachment = Attachment;
    var Duration = function() {
      function Duration2() {
        this.seconds = 0;
        this.nanos = 0;
      }
      return Duration2;
    }();
    exports2.Duration = Duration;
    var Envelope = function() {
      function Envelope2() {
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Attachment;
        })
      ], Envelope2.prototype, "attachment", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return GherkinDocument;
        })
      ], Envelope2.prototype, "gherkinDocument", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Hook;
        })
      ], Envelope2.prototype, "hook", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Meta;
        })
      ], Envelope2.prototype, "meta", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return ParameterType;
        })
      ], Envelope2.prototype, "parameterType", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return ParseError;
        })
      ], Envelope2.prototype, "parseError", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Pickle;
        })
      ], Envelope2.prototype, "pickle", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Source;
        })
      ], Envelope2.prototype, "source", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return StepDefinition;
        })
      ], Envelope2.prototype, "stepDefinition", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestCase;
        })
      ], Envelope2.prototype, "testCase", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestCaseFinished;
        })
      ], Envelope2.prototype, "testCaseFinished", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestCaseStarted;
        })
      ], Envelope2.prototype, "testCaseStarted", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestRunFinished;
        })
      ], Envelope2.prototype, "testRunFinished", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestRunStarted;
        })
      ], Envelope2.prototype, "testRunStarted", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestStepFinished;
        })
      ], Envelope2.prototype, "testStepFinished", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestStepStarted;
        })
      ], Envelope2.prototype, "testStepStarted", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return UndefinedParameterType;
        })
      ], Envelope2.prototype, "undefinedParameterType", void 0);
      return Envelope2;
    }();
    exports2.Envelope = Envelope;
    var GherkinDocument = function() {
      function GherkinDocument2() {
        this.comments = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Feature;
        })
      ], GherkinDocument2.prototype, "feature", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Comment;
        })
      ], GherkinDocument2.prototype, "comments", void 0);
      return GherkinDocument2;
    }();
    exports2.GherkinDocument = GherkinDocument;
    var Background = function() {
      function Background2() {
        this.location = new Location();
        this.keyword = "";
        this.name = "";
        this.description = "";
        this.steps = [];
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Background2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Step;
        })
      ], Background2.prototype, "steps", void 0);
      return Background2;
    }();
    exports2.Background = Background;
    var Comment = function() {
      function Comment2() {
        this.location = new Location();
        this.text = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Comment2.prototype, "location", void 0);
      return Comment2;
    }();
    exports2.Comment = Comment;
    var DataTable = function() {
      function DataTable2() {
        this.location = new Location();
        this.rows = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], DataTable2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TableRow;
        })
      ], DataTable2.prototype, "rows", void 0);
      return DataTable2;
    }();
    exports2.DataTable = DataTable;
    var DocString = function() {
      function DocString2() {
        this.location = new Location();
        this.content = "";
        this.delimiter = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], DocString2.prototype, "location", void 0);
      return DocString2;
    }();
    exports2.DocString = DocString;
    var Examples = function() {
      function Examples2() {
        this.location = new Location();
        this.tags = [];
        this.keyword = "";
        this.name = "";
        this.description = "";
        this.tableBody = [];
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Examples2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Tag;
        })
      ], Examples2.prototype, "tags", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TableRow;
        })
      ], Examples2.prototype, "tableHeader", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TableRow;
        })
      ], Examples2.prototype, "tableBody", void 0);
      return Examples2;
    }();
    exports2.Examples = Examples;
    var Feature = function() {
      function Feature2() {
        this.location = new Location();
        this.tags = [];
        this.language = "";
        this.keyword = "";
        this.name = "";
        this.description = "";
        this.children = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Feature2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Tag;
        })
      ], Feature2.prototype, "tags", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return FeatureChild;
        })
      ], Feature2.prototype, "children", void 0);
      return Feature2;
    }();
    exports2.Feature = Feature;
    var FeatureChild = function() {
      function FeatureChild2() {
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Rule;
        })
      ], FeatureChild2.prototype, "rule", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Background;
        })
      ], FeatureChild2.prototype, "background", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Scenario;
        })
      ], FeatureChild2.prototype, "scenario", void 0);
      return FeatureChild2;
    }();
    exports2.FeatureChild = FeatureChild;
    var Rule = function() {
      function Rule2() {
        this.location = new Location();
        this.tags = [];
        this.keyword = "";
        this.name = "";
        this.description = "";
        this.children = [];
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Rule2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Tag;
        })
      ], Rule2.prototype, "tags", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return RuleChild;
        })
      ], Rule2.prototype, "children", void 0);
      return Rule2;
    }();
    exports2.Rule = Rule;
    var RuleChild = function() {
      function RuleChild2() {
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Background;
        })
      ], RuleChild2.prototype, "background", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Scenario;
        })
      ], RuleChild2.prototype, "scenario", void 0);
      return RuleChild2;
    }();
    exports2.RuleChild = RuleChild;
    var Scenario = function() {
      function Scenario2() {
        this.location = new Location();
        this.tags = [];
        this.keyword = "";
        this.name = "";
        this.description = "";
        this.steps = [];
        this.examples = [];
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Scenario2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Tag;
        })
      ], Scenario2.prototype, "tags", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Step;
        })
      ], Scenario2.prototype, "steps", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Examples;
        })
      ], Scenario2.prototype, "examples", void 0);
      return Scenario2;
    }();
    exports2.Scenario = Scenario;
    var Step = function() {
      function Step2() {
        this.location = new Location();
        this.keyword = "";
        this.text = "";
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Step2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return DocString;
        })
      ], Step2.prototype, "docString", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return DataTable;
        })
      ], Step2.prototype, "dataTable", void 0);
      return Step2;
    }();
    exports2.Step = Step;
    var TableCell = function() {
      function TableCell2() {
        this.location = new Location();
        this.value = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], TableCell2.prototype, "location", void 0);
      return TableCell2;
    }();
    exports2.TableCell = TableCell;
    var TableRow = function() {
      function TableRow2() {
        this.location = new Location();
        this.cells = [];
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], TableRow2.prototype, "location", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TableCell;
        })
      ], TableRow2.prototype, "cells", void 0);
      return TableRow2;
    }();
    exports2.TableRow = TableRow;
    var Tag = function() {
      function Tag2() {
        this.location = new Location();
        this.name = "";
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], Tag2.prototype, "location", void 0);
      return Tag2;
    }();
    exports2.Tag = Tag;
    var Hook = function() {
      function Hook2() {
        this.id = "";
        this.sourceReference = new SourceReference();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return SourceReference;
        })
      ], Hook2.prototype, "sourceReference", void 0);
      return Hook2;
    }();
    exports2.Hook = Hook;
    var Location = function() {
      function Location2() {
        this.line = 0;
      }
      return Location2;
    }();
    exports2.Location = Location;
    var Meta = function() {
      function Meta2() {
        this.protocolVersion = "";
        this.implementation = new Product();
        this.runtime = new Product();
        this.os = new Product();
        this.cpu = new Product();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Product;
        })
      ], Meta2.prototype, "implementation", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Product;
        })
      ], Meta2.prototype, "runtime", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Product;
        })
      ], Meta2.prototype, "os", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Product;
        })
      ], Meta2.prototype, "cpu", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Ci;
        })
      ], Meta2.prototype, "ci", void 0);
      return Meta2;
    }();
    exports2.Meta = Meta;
    var Ci = function() {
      function Ci2() {
        this.name = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Git;
        })
      ], Ci2.prototype, "git", void 0);
      return Ci2;
    }();
    exports2.Ci = Ci;
    var Git = function() {
      function Git2() {
        this.remote = "";
        this.revision = "";
      }
      return Git2;
    }();
    exports2.Git = Git;
    var Product = function() {
      function Product2() {
        this.name = "";
      }
      return Product2;
    }();
    exports2.Product = Product;
    var ParameterType = function() {
      function ParameterType2() {
        this.name = "";
        this.regularExpressions = [];
        this.preferForRegularExpressionMatch = false;
        this.useForSnippets = false;
        this.id = "";
      }
      return ParameterType2;
    }();
    exports2.ParameterType = ParameterType;
    var ParseError = function() {
      function ParseError2() {
        this.source = new SourceReference();
        this.message = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return SourceReference;
        })
      ], ParseError2.prototype, "source", void 0);
      return ParseError2;
    }();
    exports2.ParseError = ParseError;
    var Pickle = function() {
      function Pickle2() {
        this.id = "";
        this.uri = "";
        this.name = "";
        this.language = "";
        this.steps = [];
        this.tags = [];
        this.astNodeIds = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleStep;
        })
      ], Pickle2.prototype, "steps", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleTag;
        })
      ], Pickle2.prototype, "tags", void 0);
      return Pickle2;
    }();
    exports2.Pickle = Pickle;
    var PickleDocString = function() {
      function PickleDocString2() {
        this.content = "";
      }
      return PickleDocString2;
    }();
    exports2.PickleDocString = PickleDocString;
    var PickleStep = function() {
      function PickleStep2() {
        this.astNodeIds = [];
        this.id = "";
        this.text = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleStepArgument;
        })
      ], PickleStep2.prototype, "argument", void 0);
      return PickleStep2;
    }();
    exports2.PickleStep = PickleStep;
    var PickleStepArgument = function() {
      function PickleStepArgument2() {
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleDocString;
        })
      ], PickleStepArgument2.prototype, "docString", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleTable;
        })
      ], PickleStepArgument2.prototype, "dataTable", void 0);
      return PickleStepArgument2;
    }();
    exports2.PickleStepArgument = PickleStepArgument;
    var PickleTable = function() {
      function PickleTable2() {
        this.rows = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleTableRow;
        })
      ], PickleTable2.prototype, "rows", void 0);
      return PickleTable2;
    }();
    exports2.PickleTable = PickleTable;
    var PickleTableCell = function() {
      function PickleTableCell2() {
        this.value = "";
      }
      return PickleTableCell2;
    }();
    exports2.PickleTableCell = PickleTableCell;
    var PickleTableRow = function() {
      function PickleTableRow2() {
        this.cells = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return PickleTableCell;
        })
      ], PickleTableRow2.prototype, "cells", void 0);
      return PickleTableRow2;
    }();
    exports2.PickleTableRow = PickleTableRow;
    var PickleTag = function() {
      function PickleTag2() {
        this.name = "";
        this.astNodeId = "";
      }
      return PickleTag2;
    }();
    exports2.PickleTag = PickleTag;
    var Source = function() {
      function Source2() {
        this.uri = "";
        this.data = "";
        this.mediaType = SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_PLAIN;
      }
      return Source2;
    }();
    exports2.Source = Source;
    var SourceReference = function() {
      function SourceReference2() {
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return JavaMethod;
        })
      ], SourceReference2.prototype, "javaMethod", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return JavaStackTraceElement;
        })
      ], SourceReference2.prototype, "javaStackTraceElement", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Location;
        })
      ], SourceReference2.prototype, "location", void 0);
      return SourceReference2;
    }();
    exports2.SourceReference = SourceReference;
    var JavaMethod = function() {
      function JavaMethod2() {
        this.className = "";
        this.methodName = "";
        this.methodParameterTypes = [];
      }
      return JavaMethod2;
    }();
    exports2.JavaMethod = JavaMethod;
    var JavaStackTraceElement = function() {
      function JavaStackTraceElement2() {
        this.className = "";
        this.fileName = "";
        this.methodName = "";
      }
      return JavaStackTraceElement2;
    }();
    exports2.JavaStackTraceElement = JavaStackTraceElement;
    var StepDefinition = function() {
      function StepDefinition2() {
        this.id = "";
        this.pattern = new StepDefinitionPattern();
        this.sourceReference = new SourceReference();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return StepDefinitionPattern;
        })
      ], StepDefinition2.prototype, "pattern", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return SourceReference;
        })
      ], StepDefinition2.prototype, "sourceReference", void 0);
      return StepDefinition2;
    }();
    exports2.StepDefinition = StepDefinition;
    var StepDefinitionPattern = function() {
      function StepDefinitionPattern2() {
        this.source = "";
        this.type = StepDefinitionPatternType.CUCUMBER_EXPRESSION;
      }
      return StepDefinitionPattern2;
    }();
    exports2.StepDefinitionPattern = StepDefinitionPattern;
    var TestCase = function() {
      function TestCase2() {
        this.id = "";
        this.pickleId = "";
        this.testSteps = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestStep;
        })
      ], TestCase2.prototype, "testSteps", void 0);
      return TestCase2;
    }();
    exports2.TestCase = TestCase;
    var Group = function() {
      function Group2() {
        this.children = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Group2;
        })
      ], Group2.prototype, "children", void 0);
      return Group2;
    }();
    exports2.Group = Group;
    var StepMatchArgument = function() {
      function StepMatchArgument2() {
        this.group = new Group();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Group;
        })
      ], StepMatchArgument2.prototype, "group", void 0);
      return StepMatchArgument2;
    }();
    exports2.StepMatchArgument = StepMatchArgument;
    var StepMatchArgumentsList = function() {
      function StepMatchArgumentsList2() {
        this.stepMatchArguments = [];
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return StepMatchArgument;
        })
      ], StepMatchArgumentsList2.prototype, "stepMatchArguments", void 0);
      return StepMatchArgumentsList2;
    }();
    exports2.StepMatchArgumentsList = StepMatchArgumentsList;
    var TestStep = function() {
      function TestStep2() {
        this.id = "";
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return StepMatchArgumentsList;
        })
      ], TestStep2.prototype, "stepMatchArgumentsLists", void 0);
      return TestStep2;
    }();
    exports2.TestStep = TestStep;
    var TestCaseFinished = function() {
      function TestCaseFinished2() {
        this.testCaseStartedId = "";
        this.timestamp = new Timestamp();
        this.willBeRetried = false;
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestCaseFinished2.prototype, "timestamp", void 0);
      return TestCaseFinished2;
    }();
    exports2.TestCaseFinished = TestCaseFinished;
    var TestCaseStarted = function() {
      function TestCaseStarted2() {
        this.attempt = 0;
        this.id = "";
        this.testCaseId = "";
        this.timestamp = new Timestamp();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestCaseStarted2.prototype, "timestamp", void 0);
      return TestCaseStarted2;
    }();
    exports2.TestCaseStarted = TestCaseStarted;
    var TestRunFinished = function() {
      function TestRunFinished2() {
        this.success = false;
        this.timestamp = new Timestamp();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestRunFinished2.prototype, "timestamp", void 0);
      return TestRunFinished2;
    }();
    exports2.TestRunFinished = TestRunFinished;
    var TestRunStarted = function() {
      function TestRunStarted2() {
        this.timestamp = new Timestamp();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestRunStarted2.prototype, "timestamp", void 0);
      return TestRunStarted2;
    }();
    exports2.TestRunStarted = TestRunStarted;
    var TestStepFinished = function() {
      function TestStepFinished2() {
        this.testCaseStartedId = "";
        this.testStepId = "";
        this.testStepResult = new TestStepResult();
        this.timestamp = new Timestamp();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return TestStepResult;
        })
      ], TestStepFinished2.prototype, "testStepResult", void 0);
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestStepFinished2.prototype, "timestamp", void 0);
      return TestStepFinished2;
    }();
    exports2.TestStepFinished = TestStepFinished;
    var TestStepResult = function() {
      function TestStepResult2() {
        this.duration = new Duration();
        this.status = TestStepResultStatus.UNKNOWN;
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Duration;
        })
      ], TestStepResult2.prototype, "duration", void 0);
      return TestStepResult2;
    }();
    exports2.TestStepResult = TestStepResult;
    var TestStepStarted = function() {
      function TestStepStarted2() {
        this.testCaseStartedId = "";
        this.testStepId = "";
        this.timestamp = new Timestamp();
      }
      __decorate([
        (0, class_transformer_1.Type)(function() {
          return Timestamp;
        })
      ], TestStepStarted2.prototype, "timestamp", void 0);
      return TestStepStarted2;
    }();
    exports2.TestStepStarted = TestStepStarted;
    var Timestamp = function() {
      function Timestamp2() {
        this.seconds = 0;
        this.nanos = 0;
      }
      return Timestamp2;
    }();
    exports2.Timestamp = Timestamp;
    var UndefinedParameterType = function() {
      function UndefinedParameterType2() {
        this.expression = "";
        this.name = "";
      }
      return UndefinedParameterType2;
    }();
    exports2.UndefinedParameterType = UndefinedParameterType;
    var AttachmentContentEncoding;
    (function(AttachmentContentEncoding2) {
      AttachmentContentEncoding2["IDENTITY"] = "IDENTITY";
      AttachmentContentEncoding2["BASE64"] = "BASE64";
    })(AttachmentContentEncoding = exports2.AttachmentContentEncoding || (exports2.AttachmentContentEncoding = {}));
    var PickleStepType;
    (function(PickleStepType2) {
      PickleStepType2["UNKNOWN"] = "Unknown";
      PickleStepType2["CONTEXT"] = "Context";
      PickleStepType2["ACTION"] = "Action";
      PickleStepType2["OUTCOME"] = "Outcome";
    })(PickleStepType = exports2.PickleStepType || (exports2.PickleStepType = {}));
    var SourceMediaType;
    (function(SourceMediaType2) {
      SourceMediaType2["TEXT_X_CUCUMBER_GHERKIN_PLAIN"] = "text/x.cucumber.gherkin+plain";
      SourceMediaType2["TEXT_X_CUCUMBER_GHERKIN_MARKDOWN"] = "text/x.cucumber.gherkin+markdown";
    })(SourceMediaType = exports2.SourceMediaType || (exports2.SourceMediaType = {}));
    var StepDefinitionPatternType;
    (function(StepDefinitionPatternType2) {
      StepDefinitionPatternType2["CUCUMBER_EXPRESSION"] = "CUCUMBER_EXPRESSION";
      StepDefinitionPatternType2["REGULAR_EXPRESSION"] = "REGULAR_EXPRESSION";
    })(StepDefinitionPatternType = exports2.StepDefinitionPatternType || (exports2.StepDefinitionPatternType = {}));
    var StepKeywordType;
    (function(StepKeywordType2) {
      StepKeywordType2["UNKNOWN"] = "Unknown";
      StepKeywordType2["CONTEXT"] = "Context";
      StepKeywordType2["ACTION"] = "Action";
      StepKeywordType2["OUTCOME"] = "Outcome";
      StepKeywordType2["CONJUNCTION"] = "Conjunction";
    })(StepKeywordType = exports2.StepKeywordType || (exports2.StepKeywordType = {}));
    var TestStepResultStatus;
    (function(TestStepResultStatus2) {
      TestStepResultStatus2["UNKNOWN"] = "UNKNOWN";
      TestStepResultStatus2["PASSED"] = "PASSED";
      TestStepResultStatus2["SKIPPED"] = "SKIPPED";
      TestStepResultStatus2["PENDING"] = "PENDING";
      TestStepResultStatus2["UNDEFINED"] = "UNDEFINED";
      TestStepResultStatus2["AMBIGUOUS"] = "AMBIGUOUS";
      TestStepResultStatus2["FAILED"] = "FAILED";
    })(TestStepResultStatus = exports2.TestStepResultStatus || (exports2.TestStepResultStatus = {}));
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/parseEnvelope.js
var require_parseEnvelope = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/parseEnvelope.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseEnvelope = void 0;
    var messages_js_1 = require_messages3();
    var class_transformer_1 = require_cjs();
    function parseEnvelope(json) {
      var plain = JSON.parse(json);
      return (0, class_transformer_1.plainToClass)(messages_js_1.Envelope, plain);
    }
    exports2.parseEnvelope = parseEnvelope;
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/getWorstTestStepResult.js
var require_getWorstTestStepResult = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/getWorstTestStepResult.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWorstTestStepResult = void 0;
    var messages_js_1 = require_messages3();
    var TimeConversion_js_1 = require_TimeConversion();
    function getWorstTestStepResult(testStepResults) {
      return testStepResults.slice().sort(function(r1, r2) {
        return ordinal(r2.status) - ordinal(r1.status);
      })[0] || {
        status: messages_js_1.TestStepResultStatus.UNKNOWN,
        duration: (0, TimeConversion_js_1.millisecondsToDuration)(0)
      };
    }
    exports2.getWorstTestStepResult = getWorstTestStepResult;
    function ordinal(status) {
      return [
        messages_js_1.TestStepResultStatus.UNKNOWN,
        messages_js_1.TestStepResultStatus.PASSED,
        messages_js_1.TestStepResultStatus.SKIPPED,
        messages_js_1.TestStepResultStatus.PENDING,
        messages_js_1.TestStepResultStatus.UNDEFINED,
        messages_js_1.TestStepResultStatus.AMBIGUOUS,
        messages_js_1.TestStepResultStatus.FAILED
      ].indexOf(status);
    }
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/version.js
var require_version2 = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = "19.0.0";
  }
});

// node_modules/@cucumber/messages/dist/cjs/src/index.js
var require_src3 = __commonJS({
  "node_modules/@cucumber/messages/dist/cjs/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getWorstTestStepResult = exports2.parseEnvelope = exports2.version = exports2.IdGenerator = exports2.TimeConversion = void 0;
    var TimeConversion = __importStar(require_TimeConversion());
    exports2.TimeConversion = TimeConversion;
    var IdGenerator = __importStar(require_IdGenerator());
    exports2.IdGenerator = IdGenerator;
    var parseEnvelope_js_1 = require_parseEnvelope();
    Object.defineProperty(exports2, "parseEnvelope", { enumerable: true, get: function() {
      return parseEnvelope_js_1.parseEnvelope;
    } });
    var getWorstTestStepResult_js_1 = require_getWorstTestStepResult();
    Object.defineProperty(exports2, "getWorstTestStepResult", { enumerable: true, get: function() {
      return getWorstTestStepResult_js_1.getWorstTestStepResult;
    } });
    var version_js_1 = require_version2();
    Object.defineProperty(exports2, "version", { enumerable: true, get: function() {
      return version_js_1.version;
    } });
    __exportStar(require_messages3(), exports2);
  }
});

// node_modules/@cucumber/gherkin/dist/src/GherkinClassicTokenMatcher.js
var require_GherkinClassicTokenMatcher = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/GherkinClassicTokenMatcher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var gherkin_languages_json_1 = __importDefault(require_gherkin_languages());
    var Errors_1 = require_Errors();
    var messages = __importStar(require_src3());
    var Parser_1 = require_Parser();
    var countSymbols_1 = __importDefault(require_countSymbols());
    var DIALECT_DICT = gherkin_languages_json_1.default;
    var LANGUAGE_PATTERN = /^\s*#\s*language\s*:\s*([a-zA-Z\-_]+)\s*$/;
    function addKeywordTypeMappings(h, keywords, keywordType) {
      for (const k of keywords) {
        if (!(k in h)) {
          h[k] = [];
        }
        h[k].push(keywordType);
      }
    }
    var GherkinClassicTokenMatcher = class {
      constructor(defaultDialectName = "en") {
        this.defaultDialectName = defaultDialectName;
        this.reset();
      }
      changeDialect(newDialectName, location) {
        const newDialect = DIALECT_DICT[newDialectName];
        if (!newDialect) {
          throw Errors_1.NoSuchLanguageException.create(newDialectName, location);
        }
        this.dialectName = newDialectName;
        this.dialect = newDialect;
        this.initializeKeywordTypes();
      }
      reset() {
        if (this.dialectName !== this.defaultDialectName) {
          this.changeDialect(this.defaultDialectName);
        }
        this.activeDocStringSeparator = null;
        this.indentToRemove = 0;
      }
      initializeKeywordTypes() {
        this.keywordTypesMap = {};
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.given, messages.StepKeywordType.CONTEXT);
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.when, messages.StepKeywordType.ACTION);
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.then, messages.StepKeywordType.OUTCOME);
        addKeywordTypeMappings(this.keywordTypesMap, [].concat(this.dialect.and).concat(this.dialect.but), messages.StepKeywordType.CONJUNCTION);
      }
      match_TagLine(token) {
        if (token.line.startsWith("@")) {
          this.setTokenMatched(token, Parser_1.TokenType.TagLine, null, null, null, null, this.getTags(token.line));
          return true;
        }
        return false;
      }
      match_FeatureLine(token) {
        return this.matchTitleLine(token, Parser_1.TokenType.FeatureLine, this.dialect.feature);
      }
      match_ScenarioLine(token) {
        return this.matchTitleLine(token, Parser_1.TokenType.ScenarioLine, this.dialect.scenario) || this.matchTitleLine(token, Parser_1.TokenType.ScenarioLine, this.dialect.scenarioOutline);
      }
      match_BackgroundLine(token) {
        return this.matchTitleLine(token, Parser_1.TokenType.BackgroundLine, this.dialect.background);
      }
      match_ExamplesLine(token) {
        return this.matchTitleLine(token, Parser_1.TokenType.ExamplesLine, this.dialect.examples);
      }
      match_RuleLine(token) {
        return this.matchTitleLine(token, Parser_1.TokenType.RuleLine, this.dialect.rule);
      }
      match_TableRow(token) {
        if (token.line.startsWith("|")) {
          this.setTokenMatched(token, Parser_1.TokenType.TableRow, null, null, null, null, token.line.getTableCells());
          return true;
        }
        return false;
      }
      match_Empty(token) {
        if (token.line.isEmpty) {
          this.setTokenMatched(token, Parser_1.TokenType.Empty, null, null, 0);
          return true;
        }
        return false;
      }
      match_Comment(token) {
        if (token.line.startsWith("#")) {
          const text = token.line.getLineText(0);
          this.setTokenMatched(token, Parser_1.TokenType.Comment, text, null, 0);
          return true;
        }
        return false;
      }
      match_Language(token) {
        const match = token.line.trimmedLineText.match(LANGUAGE_PATTERN);
        if (match) {
          const newDialectName = match[1];
          this.setTokenMatched(token, Parser_1.TokenType.Language, newDialectName);
          this.changeDialect(newDialectName, token.location);
          return true;
        }
        return false;
      }
      match_DocStringSeparator(token) {
        return this.activeDocStringSeparator == null ? this._match_DocStringSeparator(token, '"""', true) || this._match_DocStringSeparator(token, "```", true) : this._match_DocStringSeparator(token, this.activeDocStringSeparator, false);
      }
      _match_DocStringSeparator(token, separator, isOpen) {
        if (token.line.startsWith(separator)) {
          let mediaType = null;
          if (isOpen) {
            mediaType = token.line.getRestTrimmed(separator.length);
            this.activeDocStringSeparator = separator;
            this.indentToRemove = token.line.indent;
          } else {
            this.activeDocStringSeparator = null;
            this.indentToRemove = 0;
          }
          this.setTokenMatched(token, Parser_1.TokenType.DocStringSeparator, mediaType, separator);
          return true;
        }
        return false;
      }
      match_EOF(token) {
        if (token.isEof) {
          this.setTokenMatched(token, Parser_1.TokenType.EOF);
          return true;
        }
        return false;
      }
      match_StepLine(token) {
        const keywords = [].concat(this.dialect.given).concat(this.dialect.when).concat(this.dialect.then).concat(this.dialect.and).concat(this.dialect.but);
        for (const keyword of keywords) {
          if (token.line.startsWith(keyword)) {
            const title = token.line.getRestTrimmed(keyword.length);
            const keywordTypes = this.keywordTypesMap[keyword];
            let keywordType = keywordTypes[0];
            if (keywordTypes.length > 1) {
              keywordType = messages.StepKeywordType.UNKNOWN;
            }
            this.setTokenMatched(token, Parser_1.TokenType.StepLine, title, keyword, null, keywordType);
            return true;
          }
        }
        return false;
      }
      match_Other(token) {
        const text = token.line.getLineText(this.indentToRemove);
        this.setTokenMatched(token, Parser_1.TokenType.Other, this.unescapeDocString(text), null, 0);
        return true;
      }
      getTags(line) {
        const uncommentedLine = line.trimmedLineText.split(/\s#/g, 2)[0];
        let column = line.indent + 1;
        const items = uncommentedLine.split("@");
        const tags = [];
        for (let i = 0; i < items.length; i++) {
          const item = items[i].trimRight();
          if (item.length == 0) {
            continue;
          }
          if (!item.match(/^\S+$/)) {
            throw Errors_1.ParserException.create("A tag may not contain whitespace", line.lineNumber, column);
          }
          const span = { column, text: "@" + item };
          tags.push(span);
          column += (0, countSymbols_1.default)(items[i]) + 1;
        }
        return tags;
      }
      matchTitleLine(token, tokenType, keywords) {
        for (const keyword of keywords) {
          if (token.line.startsWithTitleKeyword(keyword)) {
            const title = token.line.getRestTrimmed(keyword.length + ":".length);
            this.setTokenMatched(token, tokenType, title, keyword);
            return true;
          }
        }
        return false;
      }
      setTokenMatched(token, matchedType, text, keyword, indent, keywordType, items) {
        token.matchedType = matchedType;
        token.matchedText = text;
        token.matchedKeyword = keyword;
        token.matchedKeywordType = keywordType;
        token.matchedIndent = typeof indent === "number" ? indent : token.line == null ? 0 : token.line.indent;
        token.matchedItems = items || [];
        token.location.column = token.matchedIndent + 1;
        token.matchedGherkinDialect = this.dialectName;
      }
      unescapeDocString(text) {
        if (this.activeDocStringSeparator === '"""') {
          return text.replace('\\"\\"\\"', '"""');
        }
        if (this.activeDocStringSeparator === "```") {
          return text.replace("\\`\\`\\`", "```");
        }
        return text;
      }
    };
    exports2.default = GherkinClassicTokenMatcher;
  }
});

// node_modules/@cucumber/gherkin/dist/src/pickles/compile.js
var require_compile = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/pickles/compile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages = __importStar(require_src3());
    var pickleStepTypeFromKeyword = {
      [messages.StepKeywordType.UNKNOWN]: messages.PickleStepType.UNKNOWN,
      [messages.StepKeywordType.CONTEXT]: messages.PickleStepType.CONTEXT,
      [messages.StepKeywordType.ACTION]: messages.PickleStepType.ACTION,
      [messages.StepKeywordType.OUTCOME]: messages.PickleStepType.OUTCOME,
      [messages.StepKeywordType.CONJUNCTION]: null
    };
    function compile(gherkinDocument, uri, newId) {
      const pickles = [];
      if (gherkinDocument.feature == null) {
        return pickles;
      }
      const feature = gherkinDocument.feature;
      const language = feature.language;
      const featureTags = feature.tags;
      let featureBackgroundSteps = [];
      feature.children.forEach((stepsContainer) => {
        if (stepsContainer.background) {
          featureBackgroundSteps = [].concat(stepsContainer.background.steps);
        } else if (stepsContainer.rule) {
          compileRule(featureTags, featureBackgroundSteps, stepsContainer.rule, language, pickles, uri, newId);
        } else if (stepsContainer.scenario.examples.length === 0) {
          compileScenario(featureTags, featureBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        } else {
          compileScenarioOutline(featureTags, featureBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
      });
      return pickles;
    }
    exports2.default = compile;
    function compileRule(featureTags, featureBackgroundSteps, rule, language, pickles, uri, newId) {
      let ruleBackgroundSteps = [].concat(featureBackgroundSteps);
      const tags = [].concat(featureTags).concat(rule.tags);
      rule.children.forEach((stepsContainer) => {
        if (stepsContainer.background) {
          ruleBackgroundSteps = ruleBackgroundSteps.concat(stepsContainer.background.steps);
        } else if (stepsContainer.scenario.examples.length === 0) {
          compileScenario(tags, ruleBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        } else {
          compileScenarioOutline(featureTags, ruleBackgroundSteps, stepsContainer.scenario, language, pickles, uri, newId);
        }
      });
    }
    function compileScenario(inheritedTags, backgroundSteps, scenario, language, pickles, uri, newId) {
      let lastKeywordType = messages.StepKeywordType.UNKNOWN;
      const steps = [];
      if (scenario.steps.length !== 0) {
        backgroundSteps.forEach((step) => {
          lastKeywordType = step.keywordType === messages.StepKeywordType.CONJUNCTION ? lastKeywordType : step.keywordType;
          steps.push(pickleStep(step, [], null, newId, lastKeywordType));
        });
      }
      const tags = [].concat(inheritedTags).concat(scenario.tags);
      scenario.steps.forEach((step) => {
        lastKeywordType = step.keywordType === messages.StepKeywordType.CONJUNCTION ? lastKeywordType : step.keywordType;
        steps.push(pickleStep(step, [], null, newId, lastKeywordType));
      });
      const pickle = {
        id: newId(),
        uri,
        astNodeIds: [scenario.id],
        tags: pickleTags(tags),
        name: scenario.name,
        language,
        steps
      };
      pickles.push(pickle);
    }
    function compileScenarioOutline(inheritedTags, backgroundSteps, scenario, language, pickles, uri, newId) {
      scenario.examples.filter((e) => e.tableHeader).forEach((examples) => {
        const variableCells = examples.tableHeader.cells;
        examples.tableBody.forEach((valuesRow) => {
          let lastKeywordType = messages.StepKeywordType.UNKNOWN;
          const steps = [];
          if (scenario.steps.length !== 0) {
            backgroundSteps.forEach((step) => {
              lastKeywordType = step.keywordType === messages.StepKeywordType.CONJUNCTION ? lastKeywordType : step.keywordType;
              steps.push(pickleStep(step, [], null, newId, lastKeywordType));
            });
          }
          scenario.steps.forEach((scenarioOutlineStep) => {
            lastKeywordType = scenarioOutlineStep.keywordType === messages.StepKeywordType.CONJUNCTION ? lastKeywordType : scenarioOutlineStep.keywordType;
            const step = pickleStep(scenarioOutlineStep, variableCells, valuesRow, newId, lastKeywordType);
            steps.push(step);
          });
          const id = newId();
          const tags = pickleTags([].concat(inheritedTags).concat(scenario.tags).concat(examples.tags));
          pickles.push({
            id,
            uri,
            astNodeIds: [scenario.id, valuesRow.id],
            name: interpolate(scenario.name, variableCells, valuesRow.cells),
            language,
            steps,
            tags
          });
        });
      });
    }
    function createPickleArguments(step, variableCells, valueCells) {
      if (step.dataTable) {
        const argument = step.dataTable;
        const table = {
          rows: argument.rows.map((row) => {
            return {
              cells: row.cells.map((cell) => {
                return {
                  value: interpolate(cell.value, variableCells, valueCells)
                };
              })
            };
          })
        };
        return { dataTable: table };
      } else if (step.docString) {
        const argument = step.docString;
        const docString = {
          content: interpolate(argument.content, variableCells, valueCells)
        };
        if (argument.mediaType) {
          docString.mediaType = interpolate(argument.mediaType, variableCells, valueCells);
        }
        return { docString };
      }
    }
    function interpolate(name, variableCells, valueCells) {
      variableCells.forEach((variableCell, n) => {
        const valueCell = valueCells[n];
        const valuePattern = "<" + variableCell.value + ">";
        const escapedPattern = valuePattern.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
        const regexp = new RegExp(escapedPattern, "g");
        const replacement = valueCell.value.replace(new RegExp("\\$", "g"), "$$$$");
        name = name.replace(regexp, replacement);
      });
      return name;
    }
    function pickleStep(step, variableCells, valuesRow, newId, keywordType) {
      const astNodeIds = [step.id];
      if (valuesRow) {
        astNodeIds.push(valuesRow.id);
      }
      const valueCells = valuesRow ? valuesRow.cells : [];
      return {
        id: newId(),
        text: interpolate(step.text, variableCells, valueCells),
        type: pickleStepTypeFromKeyword[keywordType],
        argument: createPickleArguments(step, variableCells, valueCells),
        astNodeIds
      };
    }
    function pickleTags(tags) {
      return tags.map(pickleTag);
    }
    function pickleTag(tag) {
      return {
        name: tag.name,
        astNodeId: tag.id
      };
    }
  }
});

// node_modules/@cucumber/gherkin/dist/src/AstNode.js
var require_AstNode = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/AstNode.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AstNode = class {
      constructor(ruleType) {
        this.ruleType = ruleType;
        this.subItems = /* @__PURE__ */ new Map();
      }
      add(type, obj) {
        let items = this.subItems.get(type);
        if (items === void 0) {
          items = [];
          this.subItems.set(type, items);
        }
        items.push(obj);
      }
      getSingle(ruleType) {
        return (this.subItems.get(ruleType) || [])[0];
      }
      getItems(ruleType) {
        return this.subItems.get(ruleType) || [];
      }
      getToken(tokenType) {
        return (this.subItems.get(tokenType) || [])[0];
      }
      getTokens(tokenType) {
        return this.subItems.get(tokenType) || [];
      }
    };
    exports2.default = AstNode;
  }
});

// node_modules/@cucumber/gherkin/dist/src/AstBuilder.js
var require_AstBuilder = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/AstBuilder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var AstNode_1 = __importDefault(require_AstNode());
    var Parser_1 = require_Parser();
    var Errors_1 = require_Errors();
    var AstBuilder = class {
      constructor(newId) {
        this.newId = newId;
        if (!newId) {
          throw new Error("No newId");
        }
        this.reset();
      }
      reset() {
        this.stack = [new AstNode_1.default(Parser_1.RuleType.None)];
        this.comments = [];
      }
      startRule(ruleType) {
        this.stack.push(new AstNode_1.default(ruleType));
      }
      endRule() {
        const node = this.stack.pop();
        const transformedNode = this.transformNode(node);
        this.currentNode().add(node.ruleType, transformedNode);
      }
      build(token) {
        if (token.matchedType === Parser_1.TokenType.Comment) {
          this.comments.push({
            location: this.getLocation(token),
            text: token.matchedText
          });
        } else {
          this.currentNode().add(token.matchedType, token);
        }
      }
      getResult() {
        return this.currentNode().getSingle(Parser_1.RuleType.GherkinDocument);
      }
      currentNode() {
        return this.stack[this.stack.length - 1];
      }
      getLocation(token, column) {
        return !column ? token.location : { line: token.location.line, column };
      }
      getTags(node) {
        const tags = [];
        const tagsNode = node.getSingle(Parser_1.RuleType.Tags);
        if (!tagsNode) {
          return tags;
        }
        const tokens = tagsNode.getTokens(Parser_1.TokenType.TagLine);
        for (const token of tokens) {
          for (const tagItem of token.matchedItems) {
            tags.push({
              location: this.getLocation(token, tagItem.column),
              name: tagItem.text,
              id: this.newId()
            });
          }
        }
        return tags;
      }
      getCells(tableRowToken) {
        return tableRowToken.matchedItems.map((cellItem) => ({
          location: this.getLocation(tableRowToken, cellItem.column),
          value: cellItem.text
        }));
      }
      getDescription(node) {
        return node.getSingle(Parser_1.RuleType.Description) || "";
      }
      getSteps(node) {
        return node.getItems(Parser_1.RuleType.Step);
      }
      getTableRows(node) {
        const rows = node.getTokens(Parser_1.TokenType.TableRow).map((token) => ({
          id: this.newId(),
          location: this.getLocation(token),
          cells: this.getCells(token)
        }));
        this.ensureCellCount(rows);
        return rows.length === 0 ? [] : rows;
      }
      ensureCellCount(rows) {
        if (rows.length === 0) {
          return;
        }
        const cellCount = rows[0].cells.length;
        rows.forEach((row) => {
          if (row.cells.length !== cellCount) {
            throw Errors_1.AstBuilderException.create("inconsistent cell count within the table", row.location);
          }
        });
      }
      transformNode(node) {
        switch (node.ruleType) {
          case Parser_1.RuleType.Step: {
            const stepLine = node.getToken(Parser_1.TokenType.StepLine);
            const dataTable = node.getSingle(Parser_1.RuleType.DataTable);
            const docString = node.getSingle(Parser_1.RuleType.DocString);
            const location = this.getLocation(stepLine);
            const step = {
              id: this.newId(),
              location,
              keyword: stepLine.matchedKeyword,
              keywordType: stepLine.matchedKeywordType,
              text: stepLine.matchedText,
              dataTable,
              docString
            };
            return step;
          }
          case Parser_1.RuleType.DocString: {
            const separatorToken = node.getTokens(Parser_1.TokenType.DocStringSeparator)[0];
            const mediaType = separatorToken.matchedText.length > 0 ? separatorToken.matchedText : void 0;
            const lineTokens = node.getTokens(Parser_1.TokenType.Other);
            const content = lineTokens.map((t) => t.matchedText).join("\n");
            const result = {
              location: this.getLocation(separatorToken),
              content,
              delimiter: separatorToken.matchedKeyword
            };
            if (mediaType) {
              result.mediaType = mediaType;
            }
            return result;
          }
          case Parser_1.RuleType.DataTable: {
            const rows = this.getTableRows(node);
            const dataTable = {
              location: rows[0].location,
              rows
            };
            return dataTable;
          }
          case Parser_1.RuleType.Background: {
            const backgroundLine = node.getToken(Parser_1.TokenType.BackgroundLine);
            const description = this.getDescription(node);
            const steps = this.getSteps(node);
            const background = {
              id: this.newId(),
              location: this.getLocation(backgroundLine),
              keyword: backgroundLine.matchedKeyword,
              name: backgroundLine.matchedText,
              description,
              steps
            };
            return background;
          }
          case Parser_1.RuleType.ScenarioDefinition: {
            const tags = this.getTags(node);
            const scenarioNode = node.getSingle(Parser_1.RuleType.Scenario);
            const scenarioLine = scenarioNode.getToken(Parser_1.TokenType.ScenarioLine);
            const description = this.getDescription(scenarioNode);
            const steps = this.getSteps(scenarioNode);
            const examples = scenarioNode.getItems(Parser_1.RuleType.ExamplesDefinition);
            const scenario = {
              id: this.newId(),
              tags,
              location: this.getLocation(scenarioLine),
              keyword: scenarioLine.matchedKeyword,
              name: scenarioLine.matchedText,
              description,
              steps,
              examples
            };
            return scenario;
          }
          case Parser_1.RuleType.ExamplesDefinition: {
            const tags = this.getTags(node);
            const examplesNode = node.getSingle(Parser_1.RuleType.Examples);
            const examplesLine = examplesNode.getToken(Parser_1.TokenType.ExamplesLine);
            const description = this.getDescription(examplesNode);
            const examplesTable = examplesNode.getSingle(Parser_1.RuleType.ExamplesTable);
            const examples = {
              id: this.newId(),
              tags,
              location: this.getLocation(examplesLine),
              keyword: examplesLine.matchedKeyword,
              name: examplesLine.matchedText,
              description,
              tableHeader: examplesTable ? examplesTable[0] : void 0,
              tableBody: examplesTable ? examplesTable.slice(1) : []
            };
            return examples;
          }
          case Parser_1.RuleType.ExamplesTable: {
            return this.getTableRows(node);
          }
          case Parser_1.RuleType.Description: {
            let lineTokens = node.getTokens(Parser_1.TokenType.Other);
            let end = lineTokens.length;
            while (end > 0 && lineTokens[end - 1].line.trimmedLineText === "") {
              end--;
            }
            lineTokens = lineTokens.slice(0, end);
            return lineTokens.map((token) => token.matchedText).join("\n");
          }
          case Parser_1.RuleType.Feature: {
            const header = node.getSingle(Parser_1.RuleType.FeatureHeader);
            if (!header) {
              return null;
            }
            const tags = this.getTags(header);
            const featureLine = header.getToken(Parser_1.TokenType.FeatureLine);
            if (!featureLine) {
              return null;
            }
            const children = [];
            const background = node.getSingle(Parser_1.RuleType.Background);
            if (background) {
              children.push({
                background
              });
            }
            for (const scenario of node.getItems(Parser_1.RuleType.ScenarioDefinition)) {
              children.push({
                scenario
              });
            }
            for (const rule of node.getItems(Parser_1.RuleType.Rule)) {
              children.push({
                rule
              });
            }
            const description = this.getDescription(header);
            const language = featureLine.matchedGherkinDialect;
            const feature = {
              tags,
              location: this.getLocation(featureLine),
              language,
              keyword: featureLine.matchedKeyword,
              name: featureLine.matchedText,
              description,
              children
            };
            return feature;
          }
          case Parser_1.RuleType.Rule: {
            const header = node.getSingle(Parser_1.RuleType.RuleHeader);
            if (!header) {
              return null;
            }
            const ruleLine = header.getToken(Parser_1.TokenType.RuleLine);
            if (!ruleLine) {
              return null;
            }
            const tags = this.getTags(header);
            const children = [];
            const background = node.getSingle(Parser_1.RuleType.Background);
            if (background) {
              children.push({
                background
              });
            }
            for (const scenario of node.getItems(Parser_1.RuleType.ScenarioDefinition)) {
              children.push({
                scenario
              });
            }
            const description = this.getDescription(header);
            const rule = {
              id: this.newId(),
              location: this.getLocation(ruleLine),
              keyword: ruleLine.matchedKeyword,
              name: ruleLine.matchedText,
              description,
              children,
              tags
            };
            return rule;
          }
          case Parser_1.RuleType.GherkinDocument: {
            const feature = node.getSingle(Parser_1.RuleType.Feature);
            const gherkinDocument = {
              feature,
              comments: this.comments
            };
            return gherkinDocument;
          }
          default:
            return node;
        }
      }
    };
    exports2.default = AstBuilder;
  }
});

// node_modules/@cucumber/gherkin/dist/src/makeSourceEnvelope.js
var require_makeSourceEnvelope = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/makeSourceEnvelope.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var messages = __importStar(require_src3());
    function makeSourceEnvelope(data, uri) {
      let mediaType;
      if (uri.endsWith(".feature")) {
        mediaType = messages.SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_PLAIN;
      } else if (uri.endsWith(".md")) {
        mediaType = messages.SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_MARKDOWN;
      }
      if (!mediaType)
        throw new Error(`The uri (${uri}) must end with .feature or .md`);
      return {
        source: {
          data,
          uri,
          mediaType
        }
      };
    }
    exports2.default = makeSourceEnvelope;
  }
});

// node_modules/@cucumber/gherkin/dist/src/GherkinInMarkdownTokenMatcher.js
var require_GherkinInMarkdownTokenMatcher = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/GherkinInMarkdownTokenMatcher.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Parser_1 = require_Parser();
    var gherkin_languages_json_1 = __importDefault(require_gherkin_languages());
    var messages = __importStar(require_src3());
    var Errors_1 = require_Errors();
    var DIALECT_DICT = gherkin_languages_json_1.default;
    var DEFAULT_DOC_STRING_SEPARATOR = /^(```[`]*)(.*)/;
    function addKeywordTypeMappings(h, keywords, keywordType) {
      for (const k of keywords) {
        if (!(k in h)) {
          h[k] = [];
        }
        h[k].push(keywordType);
      }
    }
    var GherkinInMarkdownTokenMatcher = class {
      constructor(defaultDialectName = "en") {
        this.defaultDialectName = defaultDialectName;
        this.dialect = DIALECT_DICT[defaultDialectName];
        this.nonStarStepKeywords = [].concat(this.dialect.given).concat(this.dialect.when).concat(this.dialect.then).concat(this.dialect.and).concat(this.dialect.but).filter((value, index, self2) => value !== "* " && self2.indexOf(value) === index);
        this.initializeKeywordTypes();
        this.stepRegexp = new RegExp(`${KeywordPrefix.BULLET}(${this.nonStarStepKeywords.map(escapeRegExp).join("|")})`);
        const headerKeywords = [].concat(this.dialect.feature).concat(this.dialect.background).concat(this.dialect.rule).concat(this.dialect.scenarioOutline).concat(this.dialect.scenario).concat(this.dialect.examples).filter((value, index, self2) => self2.indexOf(value) === index);
        this.headerRegexp = new RegExp(`${KeywordPrefix.HEADER}(${headerKeywords.map(escapeRegExp).join("|")})`);
        this.reset();
      }
      changeDialect(newDialectName, location) {
        const newDialect = DIALECT_DICT[newDialectName];
        if (!newDialect) {
          throw Errors_1.NoSuchLanguageException.create(newDialectName, location);
        }
        this.dialectName = newDialectName;
        this.dialect = newDialect;
        this.initializeKeywordTypes();
      }
      initializeKeywordTypes() {
        this.keywordTypesMap = {};
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.given, messages.StepKeywordType.CONTEXT);
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.when, messages.StepKeywordType.ACTION);
        addKeywordTypeMappings(this.keywordTypesMap, this.dialect.then, messages.StepKeywordType.OUTCOME);
        addKeywordTypeMappings(this.keywordTypesMap, [].concat(this.dialect.and).concat(this.dialect.but), messages.StepKeywordType.CONJUNCTION);
      }
      match_Language(token) {
        if (!token)
          throw new Error("no token");
        return false;
      }
      match_Empty(token) {
        let result = false;
        if (token.line.isEmpty) {
          result = true;
        }
        if (!this.match_TagLine(token) && !this.match_FeatureLine(token) && !this.match_ScenarioLine(token) && !this.match_BackgroundLine(token) && !this.match_ExamplesLine(token) && !this.match_RuleLine(token) && !this.match_TableRow(token) && !this.match_Comment(token) && !this.match_Language(token) && !this.match_DocStringSeparator(token) && !this.match_EOF(token) && !this.match_StepLine(token)) {
          result = true;
        }
        if (result) {
          token.matchedType = Parser_1.TokenType.Empty;
        }
        return this.setTokenMatched(token, null, result);
      }
      match_Other(token) {
        const text = token.line.getLineText(this.indentToRemove);
        token.matchedType = Parser_1.TokenType.Other;
        token.matchedText = text;
        token.matchedIndent = 0;
        return this.setTokenMatched(token, null, true);
      }
      match_Comment(token) {
        let result = false;
        if (token.line.startsWith("|")) {
          const tableCells = token.line.getTableCells();
          if (this.isGfmTableSeparator(tableCells))
            result = true;
        }
        return this.setTokenMatched(token, null, result);
      }
      match_DocStringSeparator(token) {
        const match = token.line.trimmedLineText.match(this.activeDocStringSeparator);
        const [, newSeparator, mediaType] = match || [];
        let result = false;
        if (newSeparator) {
          if (this.activeDocStringSeparator === DEFAULT_DOC_STRING_SEPARATOR) {
            this.activeDocStringSeparator = new RegExp(`^(${newSeparator})$`);
            this.indentToRemove = token.line.indent;
          } else {
            this.activeDocStringSeparator = DEFAULT_DOC_STRING_SEPARATOR;
          }
          token.matchedKeyword = newSeparator;
          token.matchedType = Parser_1.TokenType.DocStringSeparator;
          token.matchedText = mediaType || "";
          result = true;
        }
        return this.setTokenMatched(token, null, result);
      }
      match_EOF(token) {
        let result = false;
        if (token.isEof) {
          token.matchedType = Parser_1.TokenType.EOF;
          result = true;
        }
        return this.setTokenMatched(token, null, result);
      }
      match_FeatureLine(token) {
        if (this.matchedFeatureLine) {
          return this.setTokenMatched(token, null, false);
        }
        let result = this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.feature, ":", token, Parser_1.TokenType.FeatureLine);
        if (!result) {
          token.matchedType = Parser_1.TokenType.FeatureLine;
          token.matchedText = token.line.trimmedLineText;
          result = this.setTokenMatched(token, null, true);
        }
        this.matchedFeatureLine = result;
        return result;
      }
      match_BackgroundLine(token) {
        return this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.background, ":", token, Parser_1.TokenType.BackgroundLine);
      }
      match_RuleLine(token) {
        return this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.rule, ":", token, Parser_1.TokenType.RuleLine);
      }
      match_ScenarioLine(token) {
        return this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.scenario, ":", token, Parser_1.TokenType.ScenarioLine) || this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.scenarioOutline, ":", token, Parser_1.TokenType.ScenarioLine);
      }
      match_ExamplesLine(token) {
        return this.matchTitleLine(KeywordPrefix.HEADER, this.dialect.examples, ":", token, Parser_1.TokenType.ExamplesLine);
      }
      match_StepLine(token) {
        return this.matchTitleLine(KeywordPrefix.BULLET, this.nonStarStepKeywords, "", token, Parser_1.TokenType.StepLine);
      }
      matchTitleLine(prefix, keywords, keywordSuffix, token, matchedType) {
        const regexp = new RegExp(`${prefix}(${keywords.map(escapeRegExp).join("|")})${keywordSuffix}(.*)`);
        const match = token.line.match(regexp);
        let indent = token.line.indent;
        let result = false;
        if (match) {
          token.matchedType = matchedType;
          token.matchedKeyword = match[2];
          if (match[2] in this.keywordTypesMap) {
            if (this.keywordTypesMap[match[2]].length > 1) {
              token.matchedKeywordType = messages.StepKeywordType.UNKNOWN;
            } else {
              token.matchedKeywordType = this.keywordTypesMap[match[2]][0];
            }
          }
          token.matchedText = match[3].trim();
          indent += match[1].length;
          result = true;
        }
        return this.setTokenMatched(token, indent, result);
      }
      setTokenMatched(token, indent, matched) {
        token.matchedGherkinDialect = this.dialectName;
        token.matchedIndent = indent !== null ? indent : token.line == null ? 0 : token.line.indent;
        token.location.column = token.matchedIndent + 1;
        return matched;
      }
      match_TableRow(token) {
        if (token.line.lineText.match(/^\s\s\s?\s?\s?\|/)) {
          const tableCells = token.line.getTableCells();
          if (this.isGfmTableSeparator(tableCells))
            return false;
          token.matchedKeyword = "|";
          token.matchedType = Parser_1.TokenType.TableRow;
          token.matchedItems = tableCells;
          return true;
        }
        return false;
      }
      isGfmTableSeparator(tableCells) {
        const separatorValues = tableCells.map((item) => item.text).filter((value) => value.match(/^:?-+:?$/));
        return separatorValues.length > 0;
      }
      match_TagLine(token) {
        const tags = [];
        let m;
        const re = /`(@[^`]+)`/g;
        do {
          m = re.exec(token.line.trimmedLineText);
          if (m) {
            tags.push({
              column: token.line.indent + m.index + 2,
              text: m[1]
            });
          }
        } while (m);
        if (tags.length === 0)
          return false;
        token.matchedType = Parser_1.TokenType.TagLine;
        token.matchedItems = tags;
        return true;
      }
      reset() {
        if (this.dialectName !== this.defaultDialectName) {
          this.changeDialect(this.defaultDialectName);
        }
        this.activeDocStringSeparator = DEFAULT_DOC_STRING_SEPARATOR;
      }
    };
    exports2.default = GherkinInMarkdownTokenMatcher;
    var KeywordPrefix;
    (function(KeywordPrefix2) {
      KeywordPrefix2["BULLET"] = "^(\\s*[*+-]\\s*)";
      KeywordPrefix2["HEADER"] = "^(#{1,6}\\s)";
    })(KeywordPrefix || (KeywordPrefix = {}));
    function escapeRegExp(text) {
      return text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
    }
  }
});

// node_modules/@cucumber/gherkin/dist/src/generateMessages.js
var require_generateMessages = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/generateMessages.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Parser_1 = __importDefault(require_Parser());
    var GherkinClassicTokenMatcher_1 = __importDefault(require_GherkinClassicTokenMatcher());
    var messages = __importStar(require_src3());
    var compile_1 = __importDefault(require_compile());
    var AstBuilder_1 = __importDefault(require_AstBuilder());
    var makeSourceEnvelope_1 = __importDefault(require_makeSourceEnvelope());
    var GherkinInMarkdownTokenMatcher_1 = __importDefault(require_GherkinInMarkdownTokenMatcher());
    function generateMessages(data, uri, mediaType, options) {
      let tokenMatcher;
      switch (mediaType) {
        case messages.SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_PLAIN:
          tokenMatcher = new GherkinClassicTokenMatcher_1.default(options.defaultDialect);
          break;
        case messages.SourceMediaType.TEXT_X_CUCUMBER_GHERKIN_MARKDOWN:
          tokenMatcher = new GherkinInMarkdownTokenMatcher_1.default(options.defaultDialect);
          break;
        default:
          throw new Error(`Unsupported media type: ${mediaType}`);
      }
      const result = [];
      try {
        if (options.includeSource) {
          result.push((0, makeSourceEnvelope_1.default)(data, uri));
        }
        if (!options.includeGherkinDocument && !options.includePickles) {
          return result;
        }
        const parser = new Parser_1.default(new AstBuilder_1.default(options.newId), tokenMatcher);
        parser.stopAtFirstError = false;
        const gherkinDocument = parser.parse(data);
        if (options.includeGherkinDocument) {
          result.push({
            gherkinDocument: Object.assign(Object.assign({}, gherkinDocument), { uri })
          });
        }
        if (options.includePickles) {
          const pickles = (0, compile_1.default)(gherkinDocument, uri, options.newId);
          for (const pickle of pickles) {
            result.push({
              pickle
            });
          }
        }
      } catch (err) {
        const errors = err.errors || [err];
        for (const error of errors) {
          if (!error.location) {
            throw error;
          }
          result.push({
            parseError: {
              source: {
                uri,
                location: {
                  line: error.location.line,
                  column: error.location.column
                }
              },
              message: error.message
            }
          });
        }
      }
      return result;
    }
    exports2.default = generateMessages;
  }
});

// node_modules/@cucumber/gherkin/dist/src/index.js
var require_src4 = __commonJS({
  "node_modules/@cucumber/gherkin/dist/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compile = exports2.GherkinInMarkdownTokenMatcher = exports2.GherkinClassicTokenMatcher = exports2.Errors = exports2.TokenScanner = exports2.AstBuilder = exports2.Parser = exports2.dialects = exports2.makeSourceEnvelope = exports2.generateMessages = void 0;
    var generateMessages_1 = __importDefault(require_generateMessages());
    exports2.generateMessages = generateMessages_1.default;
    var makeSourceEnvelope_1 = __importDefault(require_makeSourceEnvelope());
    exports2.makeSourceEnvelope = makeSourceEnvelope_1.default;
    var Parser_1 = __importDefault(require_Parser());
    exports2.Parser = Parser_1.default;
    var AstBuilder_1 = __importDefault(require_AstBuilder());
    exports2.AstBuilder = AstBuilder_1.default;
    var TokenScanner_1 = __importDefault(require_TokenScanner());
    exports2.TokenScanner = TokenScanner_1.default;
    var Errors = __importStar(require_Errors());
    exports2.Errors = Errors;
    var compile_1 = __importDefault(require_compile());
    exports2.compile = compile_1.default;
    var gherkin_languages_json_1 = __importDefault(require_gherkin_languages());
    var GherkinClassicTokenMatcher_1 = __importDefault(require_GherkinClassicTokenMatcher());
    exports2.GherkinClassicTokenMatcher = GherkinClassicTokenMatcher_1.default;
    var GherkinInMarkdownTokenMatcher_1 = __importDefault(require_GherkinInMarkdownTokenMatcher());
    exports2.GherkinInMarkdownTokenMatcher = GherkinInMarkdownTokenMatcher_1.default;
    var dialects = gherkin_languages_json_1.default;
    exports2.dialects = dialects;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/gherkin/parseGherkinDocument.js
var require_parseGherkinDocument = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/gherkin/parseGherkinDocument.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseGherkinDocument = void 0;
    var gherkin_1 = require_src4();
    var messages_1 = require_src3();
    var uuidFn = messages_1.IdGenerator.uuid();
    function parseGherkinDocument(gherkinSource) {
      var builder = new gherkin_1.AstBuilder(uuidFn);
      var matcher = new gherkin_1.GherkinClassicTokenMatcher();
      var parser = new gherkin_1.Parser(builder, matcher);
      try {
        return {
          gherkinDocument: parser.parse(gherkinSource)
        };
      } catch (error) {
        var gherkinDocument = void 0;
        for (var i = 0; i < 10; i++) {
          gherkinDocument = builder.getResult();
          if (gherkinDocument) {
            return {
              gherkinDocument,
              error
            };
          }
          try {
            builder.endRule();
          } catch (ignore) {
          }
        }
        return {
          error
        };
      }
    }
    exports2.parseGherkinDocument = parseGherkinDocument;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/gherkin/index.js
var require_gherkin = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/gherkin/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_extractStepTexts(), exports2);
    __exportStar(require_parseGherkinDocument(), exports2);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index/bruteForceIndex.js
var require_bruteForceIndex = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index/bruteForceIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bruteForceIndex = void 0;
    function bruteForceIndex(suggestions) {
      return function(text) {
        if (!text)
          return [];
        var predicate = function(segment) {
          return segment.toLowerCase().includes(text.toLowerCase());
        };
        return suggestions.filter(function(permutationExpression) {
          return matches(permutationExpression, predicate);
        });
      };
    }
    exports2.bruteForceIndex = bruteForceIndex;
    function matches(suggestion, predicate) {
      return !!suggestion.segments.find(function(segment) {
        return typeof segment === "string" ? predicate(segment) : !!segment.find(predicate);
      });
    }
  }
});

// node_modules/fuse.js/dist/fuse.common.js
var require_fuse_common = __commonJS({
  "node_modules/fuse.js/dist/fuse.common.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread2(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    function _typeof(obj) {
      "@babel/helpers - typeof";
      return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(obj2) {
        return typeof obj2;
      } : function(obj2) {
        return obj2 && typeof Symbol == "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      }, _typeof(obj);
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      Object.defineProperty(subClass, "prototype", {
        value: Object.create(superClass && superClass.prototype, {
          constructor: {
            value: subClass,
            writable: true,
            configurable: true
          }
        }),
        writable: false
      });
      if (superClass)
        _setPrototypeOf(subClass, superClass);
    }
    function _getPrototypeOf(o) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
        return o2.__proto__ || Object.getPrototypeOf(o2);
      };
      return _getPrototypeOf(o);
    }
    function _setPrototypeOf(o, p) {
      _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
        o2.__proto__ = p2;
        return o2;
      };
      return _setPrototypeOf(o, p);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
        }));
        return true;
      } catch (e) {
        return false;
      }
    }
    function _assertThisInitialized(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _possibleConstructorReturn(self2, call) {
      if (call && (typeof call === "object" || typeof call === "function")) {
        return call;
      } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
      }
      return _assertThisInitialized(self2);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn(this, result);
      };
    }
    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
    }
    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr))
        return _arrayLikeToArray(arr);
    }
    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
        return Array.from(iter);
    }
    function _unsupportedIterableToArray(o, minLen) {
      if (!o)
        return;
      if (typeof o === "string")
        return _arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor)
        n = o.constructor.name;
      if (n === "Map" || n === "Set")
        return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
        return _arrayLikeToArray(o, minLen);
    }
    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length)
        len = arr.length;
      for (var i = 0, arr2 = new Array(len); i < len; i++)
        arr2[i] = arr[i];
      return arr2;
    }
    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }
    function isArray(value) {
      return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
    }
    var INFINITY = 1 / 0;
    function baseToString(value) {
      if (typeof value == "string") {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY ? "-0" : result;
    }
    function toString(value) {
      return value == null ? "" : baseToString(value);
    }
    function isString(value) {
      return typeof value === "string";
    }
    function isNumber(value) {
      return typeof value === "number";
    }
    function isBoolean(value) {
      return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
    }
    function isObject(value) {
      return _typeof(value) === "object";
    }
    function isObjectLike(value) {
      return isObject(value) && value !== null;
    }
    function isDefined(value) {
      return value !== void 0 && value !== null;
    }
    function isBlank(value) {
      return !value.trim().length;
    }
    function getTag(value) {
      return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
    }
    var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
    var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = function LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY2(key) {
      return "Invalid value for key ".concat(key);
    };
    var PATTERN_LENGTH_TOO_LARGE = function PATTERN_LENGTH_TOO_LARGE2(max) {
      return "Pattern length exceeds max of ".concat(max, ".");
    };
    var MISSING_KEY_PROPERTY = function MISSING_KEY_PROPERTY2(name) {
      return "Missing ".concat(name, " property in key");
    };
    var INVALID_KEY_WEIGHT_VALUE = function INVALID_KEY_WEIGHT_VALUE2(key) {
      return "Property 'weight' in key '".concat(key, "' must be a positive integer");
    };
    var hasOwn = Object.prototype.hasOwnProperty;
    var KeyStore = /* @__PURE__ */ function() {
      function KeyStore2(keys) {
        var _this = this;
        _classCallCheck(this, KeyStore2);
        this._keys = [];
        this._keyMap = {};
        var totalWeight = 0;
        keys.forEach(function(key) {
          var obj = createKey(key);
          totalWeight += obj.weight;
          _this._keys.push(obj);
          _this._keyMap[obj.id] = obj;
          totalWeight += obj.weight;
        });
        this._keys.forEach(function(key) {
          key.weight /= totalWeight;
        });
      }
      _createClass(KeyStore2, [{
        key: "get",
        value: function get2(keyId) {
          return this._keyMap[keyId];
        }
      }, {
        key: "keys",
        value: function keys() {
          return this._keys;
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return JSON.stringify(this._keys);
        }
      }]);
      return KeyStore2;
    }();
    function createKey(key) {
      var path = null;
      var id = null;
      var src = null;
      var weight = 1;
      var getFn = null;
      if (isString(key) || isArray(key)) {
        src = key;
        path = createKeyPath(key);
        id = createKeyId(key);
      } else {
        if (!hasOwn.call(key, "name")) {
          throw new Error(MISSING_KEY_PROPERTY("name"));
        }
        var name = key.name;
        src = name;
        if (hasOwn.call(key, "weight")) {
          weight = key.weight;
          if (weight <= 0) {
            throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
          }
        }
        path = createKeyPath(name);
        id = createKeyId(name);
        getFn = key.getFn;
      }
      return {
        path,
        id,
        weight,
        src,
        getFn
      };
    }
    function createKeyPath(key) {
      return isArray(key) ? key : key.split(".");
    }
    function createKeyId(key) {
      return isArray(key) ? key.join(".") : key;
    }
    function get(obj, path) {
      var list = [];
      var arr = false;
      var deepGet = function deepGet2(obj2, path2, index) {
        if (!isDefined(obj2)) {
          return;
        }
        if (!path2[index]) {
          list.push(obj2);
        } else {
          var key = path2[index];
          var value = obj2[key];
          if (!isDefined(value)) {
            return;
          }
          if (index === path2.length - 1 && (isString(value) || isNumber(value) || isBoolean(value))) {
            list.push(toString(value));
          } else if (isArray(value)) {
            arr = true;
            for (var i = 0, len = value.length; i < len; i += 1) {
              deepGet2(value[i], path2, index + 1);
            }
          } else if (path2.length) {
            deepGet2(value, path2, index + 1);
          }
        }
      };
      deepGet(obj, isString(path) ? path.split(".") : path, 0);
      return arr ? list : list[0];
    }
    var MatchOptions = {
      includeMatches: false,
      findAllMatches: false,
      minMatchCharLength: 1
    };
    var BasicOptions = {
      isCaseSensitive: false,
      includeScore: false,
      keys: [],
      shouldSort: true,
      sortFn: function sortFn(a, b) {
        return a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1;
      }
    };
    var FuzzyOptions = {
      location: 0,
      threshold: 0.6,
      distance: 100
    };
    var AdvancedOptions = {
      useExtendedSearch: false,
      getFn: get,
      ignoreLocation: false,
      ignoreFieldNorm: false,
      fieldNormWeight: 1
    };
    var Config = _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({}, BasicOptions), MatchOptions), FuzzyOptions), AdvancedOptions);
    var SPACE = /[^ ]+/g;
    function norm() {
      var weight = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
      var mantissa = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;
      var cache = /* @__PURE__ */ new Map();
      var m = Math.pow(10, mantissa);
      return {
        get: function get2(value) {
          var numTokens = value.match(SPACE).length;
          if (cache.has(numTokens)) {
            return cache.get(numTokens);
          }
          var norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
          var n = parseFloat(Math.round(norm2 * m) / m);
          cache.set(numTokens, n);
          return n;
        },
        clear: function clear() {
          cache.clear();
        }
      };
    }
    var FuseIndex = /* @__PURE__ */ function() {
      function FuseIndex2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$getFn = _ref.getFn, getFn = _ref$getFn === void 0 ? Config.getFn : _ref$getFn, _ref$fieldNormWeight = _ref.fieldNormWeight, fieldNormWeight = _ref$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref$fieldNormWeight;
        _classCallCheck(this, FuseIndex2);
        this.norm = norm(fieldNormWeight, 3);
        this.getFn = getFn;
        this.isCreated = false;
        this.setIndexRecords();
      }
      _createClass(FuseIndex2, [{
        key: "setSources",
        value: function setSources() {
          var docs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.docs = docs;
        }
      }, {
        key: "setIndexRecords",
        value: function setIndexRecords() {
          var records = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.records = records;
        }
      }, {
        key: "setKeys",
        value: function setKeys() {
          var _this = this;
          var keys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
          this.keys = keys;
          this._keysMap = {};
          keys.forEach(function(key, idx) {
            _this._keysMap[key.id] = idx;
          });
        }
      }, {
        key: "create",
        value: function create() {
          var _this2 = this;
          if (this.isCreated || !this.docs.length) {
            return;
          }
          this.isCreated = true;
          if (isString(this.docs[0])) {
            this.docs.forEach(function(doc, docIndex) {
              _this2._addString(doc, docIndex);
            });
          } else {
            this.docs.forEach(function(doc, docIndex) {
              _this2._addObject(doc, docIndex);
            });
          }
          this.norm.clear();
        }
      }, {
        key: "add",
        value: function add(doc) {
          var idx = this.size();
          if (isString(doc)) {
            this._addString(doc, idx);
          } else {
            this._addObject(doc, idx);
          }
        }
      }, {
        key: "removeAt",
        value: function removeAt(idx) {
          this.records.splice(idx, 1);
          for (var i = idx, len = this.size(); i < len; i += 1) {
            this.records[i].i -= 1;
          }
        }
      }, {
        key: "getValueForItemAtKeyId",
        value: function getValueForItemAtKeyId(item, keyId) {
          return item[this._keysMap[keyId]];
        }
      }, {
        key: "size",
        value: function size() {
          return this.records.length;
        }
      }, {
        key: "_addString",
        value: function _addString(doc, docIndex) {
          if (!isDefined(doc) || isBlank(doc)) {
            return;
          }
          var record = {
            v: doc,
            i: docIndex,
            n: this.norm.get(doc)
          };
          this.records.push(record);
        }
      }, {
        key: "_addObject",
        value: function _addObject(doc, docIndex) {
          var _this3 = this;
          var record = {
            i: docIndex,
            $: {}
          };
          this.keys.forEach(function(key, keyIndex) {
            var value = key.getFn ? key.getFn(doc) : _this3.getFn(doc, key.path);
            if (!isDefined(value)) {
              return;
            }
            if (isArray(value)) {
              (function() {
                var subRecords = [];
                var stack = [{
                  nestedArrIndex: -1,
                  value
                }];
                while (stack.length) {
                  var _stack$pop = stack.pop(), nestedArrIndex = _stack$pop.nestedArrIndex, _value = _stack$pop.value;
                  if (!isDefined(_value)) {
                    continue;
                  }
                  if (isString(_value) && !isBlank(_value)) {
                    var subRecord2 = {
                      v: _value,
                      i: nestedArrIndex,
                      n: _this3.norm.get(_value)
                    };
                    subRecords.push(subRecord2);
                  } else if (isArray(_value)) {
                    _value.forEach(function(item, k) {
                      stack.push({
                        nestedArrIndex: k,
                        value: item
                      });
                    });
                  } else
                    ;
                }
                record.$[keyIndex] = subRecords;
              })();
            } else if (isString(value) && !isBlank(value)) {
              var subRecord = {
                v: value,
                n: _this3.norm.get(value)
              };
              record.$[keyIndex] = subRecord;
            }
          });
          this.records.push(record);
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          return {
            keys: this.keys,
            records: this.records
          };
        }
      }]);
      return FuseIndex2;
    }();
    function createIndex(keys, docs) {
      var _ref2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref2$getFn = _ref2.getFn, getFn = _ref2$getFn === void 0 ? Config.getFn : _ref2$getFn, _ref2$fieldNormWeight = _ref2.fieldNormWeight, fieldNormWeight = _ref2$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref2$fieldNormWeight;
      var myIndex = new FuseIndex({
        getFn,
        fieldNormWeight
      });
      myIndex.setKeys(keys.map(createKey));
      myIndex.setSources(docs);
      myIndex.create();
      return myIndex;
    }
    function parseIndex(data) {
      var _ref3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref3$getFn = _ref3.getFn, getFn = _ref3$getFn === void 0 ? Config.getFn : _ref3$getFn, _ref3$fieldNormWeight = _ref3.fieldNormWeight, fieldNormWeight = _ref3$fieldNormWeight === void 0 ? Config.fieldNormWeight : _ref3$fieldNormWeight;
      var keys = data.keys, records = data.records;
      var myIndex = new FuseIndex({
        getFn,
        fieldNormWeight
      });
      myIndex.setKeys(keys);
      myIndex.setIndexRecords(records);
      return myIndex;
    }
    function computeScore$1(pattern) {
      var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$errors = _ref.errors, errors = _ref$errors === void 0 ? 0 : _ref$errors, _ref$currentLocation = _ref.currentLocation, currentLocation = _ref$currentLocation === void 0 ? 0 : _ref$currentLocation, _ref$expectedLocation = _ref.expectedLocation, expectedLocation = _ref$expectedLocation === void 0 ? 0 : _ref$expectedLocation, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      var accuracy = errors / pattern.length;
      if (ignoreLocation) {
        return accuracy;
      }
      var proximity = Math.abs(expectedLocation - currentLocation);
      if (!distance) {
        return proximity ? 1 : accuracy;
      }
      return accuracy + proximity / distance;
    }
    function convertMaskToIndices() {
      var matchmask = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var minMatchCharLength = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Config.minMatchCharLength;
      var indices = [];
      var start = -1;
      var end = -1;
      var i = 0;
      for (var len = matchmask.length; i < len; i += 1) {
        var match = matchmask[i];
        if (match && start === -1) {
          start = i;
        } else if (!match && start !== -1) {
          end = i - 1;
          if (end - start + 1 >= minMatchCharLength) {
            indices.push([start, end]);
          }
          start = -1;
        }
      }
      if (matchmask[i - 1] && i - start >= minMatchCharLength) {
        indices.push([start, i - 1]);
      }
      return indices;
    }
    var MAX_BITS = 32;
    function search(text, pattern, patternAlphabet) {
      var _ref = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
      if (pattern.length > MAX_BITS) {
        throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
      }
      var patternLen = pattern.length;
      var textLen = text.length;
      var expectedLocation = Math.max(0, Math.min(location, textLen));
      var currentThreshold = threshold;
      var bestLocation = expectedLocation;
      var computeMatches = minMatchCharLength > 1 || includeMatches;
      var matchMask = computeMatches ? Array(textLen) : [];
      var index;
      while ((index = text.indexOf(pattern, bestLocation)) > -1) {
        var score = computeScore$1(pattern, {
          currentLocation: index,
          expectedLocation,
          distance,
          ignoreLocation
        });
        currentThreshold = Math.min(score, currentThreshold);
        bestLocation = index + patternLen;
        if (computeMatches) {
          var i = 0;
          while (i < patternLen) {
            matchMask[index + i] = 1;
            i += 1;
          }
        }
      }
      bestLocation = -1;
      var lastBitArr = [];
      var finalScore = 1;
      var binMax = patternLen + textLen;
      var mask = 1 << patternLen - 1;
      for (var _i = 0; _i < patternLen; _i += 1) {
        var binMin = 0;
        var binMid = binMax;
        while (binMin < binMid) {
          var _score2 = computeScore$1(pattern, {
            errors: _i,
            currentLocation: expectedLocation + binMid,
            expectedLocation,
            distance,
            ignoreLocation
          });
          if (_score2 <= currentThreshold) {
            binMin = binMid;
          } else {
            binMax = binMid;
          }
          binMid = Math.floor((binMax - binMin) / 2 + binMin);
        }
        binMax = binMid;
        var start = Math.max(1, expectedLocation - binMid + 1);
        var finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
        var bitArr = Array(finish + 2);
        bitArr[finish + 1] = (1 << _i) - 1;
        for (var j = finish; j >= start; j -= 1) {
          var currentLocation = j - 1;
          var charMatch = patternAlphabet[text.charAt(currentLocation)];
          if (computeMatches) {
            matchMask[currentLocation] = +!!charMatch;
          }
          bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
          if (_i) {
            bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
          }
          if (bitArr[j] & mask) {
            finalScore = computeScore$1(pattern, {
              errors: _i,
              currentLocation,
              expectedLocation,
              distance,
              ignoreLocation
            });
            if (finalScore <= currentThreshold) {
              currentThreshold = finalScore;
              bestLocation = currentLocation;
              if (bestLocation <= expectedLocation) {
                break;
              }
              start = Math.max(1, 2 * expectedLocation - bestLocation);
            }
          }
        }
        var _score = computeScore$1(pattern, {
          errors: _i + 1,
          currentLocation: expectedLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (_score > currentThreshold) {
          break;
        }
        lastBitArr = bitArr;
      }
      var result = {
        isMatch: bestLocation >= 0,
        score: Math.max(1e-3, finalScore)
      };
      if (computeMatches) {
        var indices = convertMaskToIndices(matchMask, minMatchCharLength);
        if (!indices.length) {
          result.isMatch = false;
        } else if (includeMatches) {
          result.indices = indices;
        }
      }
      return result;
    }
    function createPatternAlphabet(pattern) {
      var mask = {};
      for (var i = 0, len = pattern.length; i < len; i += 1) {
        var _char = pattern.charAt(i);
        mask[_char] = (mask[_char] || 0) | 1 << len - i - 1;
      }
      return mask;
    }
    var BitapSearch = /* @__PURE__ */ function() {
      function BitapSearch2(pattern) {
        var _this = this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
        _classCallCheck(this, BitapSearch2);
        this.options = {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.chunks = [];
        if (!this.pattern.length) {
          return;
        }
        var addChunk = function addChunk2(pattern2, startIndex2) {
          _this.chunks.push({
            pattern: pattern2,
            alphabet: createPatternAlphabet(pattern2),
            startIndex: startIndex2
          });
        };
        var len = this.pattern.length;
        if (len > MAX_BITS) {
          var i = 0;
          var remainder = len % MAX_BITS;
          var end = len - remainder;
          while (i < end) {
            addChunk(this.pattern.substr(i, MAX_BITS), i);
            i += MAX_BITS;
          }
          if (remainder) {
            var startIndex = len - MAX_BITS;
            addChunk(this.pattern.substr(startIndex), startIndex);
          }
        } else {
          addChunk(this.pattern, 0);
        }
      }
      _createClass(BitapSearch2, [{
        key: "searchIn",
        value: function searchIn(text) {
          var _this$options = this.options, isCaseSensitive = _this$options.isCaseSensitive, includeMatches = _this$options.includeMatches;
          if (!isCaseSensitive) {
            text = text.toLowerCase();
          }
          if (this.pattern === text) {
            var _result = {
              isMatch: true,
              score: 0
            };
            if (includeMatches) {
              _result.indices = [[0, text.length - 1]];
            }
            return _result;
          }
          var _this$options2 = this.options, location = _this$options2.location, distance = _this$options2.distance, threshold = _this$options2.threshold, findAllMatches = _this$options2.findAllMatches, minMatchCharLength = _this$options2.minMatchCharLength, ignoreLocation = _this$options2.ignoreLocation;
          var allIndices = [];
          var totalScore = 0;
          var hasMatches = false;
          this.chunks.forEach(function(_ref2) {
            var pattern = _ref2.pattern, alphabet = _ref2.alphabet, startIndex = _ref2.startIndex;
            var _search = search(text, pattern, alphabet, {
              location: location + startIndex,
              distance,
              threshold,
              findAllMatches,
              minMatchCharLength,
              includeMatches,
              ignoreLocation
            }), isMatch = _search.isMatch, score = _search.score, indices = _search.indices;
            if (isMatch) {
              hasMatches = true;
            }
            totalScore += score;
            if (isMatch && indices) {
              allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
            }
          });
          var result = {
            isMatch: hasMatches,
            score: hasMatches ? totalScore / this.chunks.length : 1
          };
          if (hasMatches && includeMatches) {
            result.indices = allIndices;
          }
          return result;
        }
      }]);
      return BitapSearch2;
    }();
    var BaseMatch = /* @__PURE__ */ function() {
      function BaseMatch2(pattern) {
        _classCallCheck(this, BaseMatch2);
        this.pattern = pattern;
      }
      _createClass(BaseMatch2, [{
        key: "search",
        value: function search2() {
        }
      }], [{
        key: "isMultiMatch",
        value: function isMultiMatch(pattern) {
          return getMatch(pattern, this.multiRegex);
        }
      }, {
        key: "isSingleMatch",
        value: function isSingleMatch(pattern) {
          return getMatch(pattern, this.singleRegex);
        }
      }]);
      return BaseMatch2;
    }();
    function getMatch(pattern, exp) {
      var matches = pattern.match(exp);
      return matches ? matches[1] : null;
    }
    var ExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(ExactMatch2, _BaseMatch);
      var _super = _createSuper(ExactMatch2);
      function ExactMatch2(pattern) {
        _classCallCheck(this, ExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(ExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text === this.pattern;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, this.pattern.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^="(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^=(.*)$/;
        }
      }]);
      return ExactMatch2;
    }(BaseMatch);
    var InverseExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InverseExactMatch2, _BaseMatch);
      var _super = _createSuper(InverseExactMatch2);
      function InverseExactMatch2(pattern) {
        _classCallCheck(this, InverseExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InverseExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var index = text.indexOf(this.pattern);
          var isMatch = index === -1;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "inverse-exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^!"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^!(.*)$/;
        }
      }]);
      return InverseExactMatch2;
    }(BaseMatch);
    var PrefixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(PrefixExactMatch2, _BaseMatch);
      var _super = _createSuper(PrefixExactMatch2);
      function PrefixExactMatch2(pattern) {
        _classCallCheck(this, PrefixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(PrefixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text.startsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, this.pattern.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "prefix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^\^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^\^(.*)$/;
        }
      }]);
      return PrefixExactMatch2;
    }(BaseMatch);
    var InversePrefixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InversePrefixExactMatch2, _BaseMatch);
      var _super = _createSuper(InversePrefixExactMatch2);
      function InversePrefixExactMatch2(pattern) {
        _classCallCheck(this, InversePrefixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InversePrefixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = !text.startsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "inverse-prefix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^!\^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^!\^(.*)$/;
        }
      }]);
      return InversePrefixExactMatch2;
    }(BaseMatch);
    var SuffixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(SuffixExactMatch2, _BaseMatch);
      var _super = _createSuper(SuffixExactMatch2);
      function SuffixExactMatch2(pattern) {
        _classCallCheck(this, SuffixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(SuffixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = text.endsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [text.length - this.pattern.length, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "suffix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^"(.*)"\$$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^(.*)\$$/;
        }
      }]);
      return SuffixExactMatch2;
    }(BaseMatch);
    var InverseSuffixExactMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(InverseSuffixExactMatch2, _BaseMatch);
      var _super = _createSuper(InverseSuffixExactMatch2);
      function InverseSuffixExactMatch2(pattern) {
        _classCallCheck(this, InverseSuffixExactMatch2);
        return _super.call(this, pattern);
      }
      _createClass(InverseSuffixExactMatch2, [{
        key: "search",
        value: function search2(text) {
          var isMatch = !text.endsWith(this.pattern);
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices: [0, text.length - 1]
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "inverse-suffix-exact";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^!"(.*)"\$$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^!(.*)\$$/;
        }
      }]);
      return InverseSuffixExactMatch2;
    }(BaseMatch);
    var FuzzyMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(FuzzyMatch2, _BaseMatch);
      var _super = _createSuper(FuzzyMatch2);
      function FuzzyMatch2(pattern) {
        var _this;
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation;
        _classCallCheck(this, FuzzyMatch2);
        _this = _super.call(this, pattern);
        _this._bitapSearch = new BitapSearch(pattern, {
          location,
          threshold,
          distance,
          includeMatches,
          findAllMatches,
          minMatchCharLength,
          isCaseSensitive,
          ignoreLocation
        });
        return _this;
      }
      _createClass(FuzzyMatch2, [{
        key: "search",
        value: function search2(text) {
          return this._bitapSearch.searchIn(text);
        }
      }], [{
        key: "type",
        get: function get2() {
          return "fuzzy";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^(.*)$/;
        }
      }]);
      return FuzzyMatch2;
    }(BaseMatch);
    var IncludeMatch = /* @__PURE__ */ function(_BaseMatch) {
      _inherits(IncludeMatch2, _BaseMatch);
      var _super = _createSuper(IncludeMatch2);
      function IncludeMatch2(pattern) {
        _classCallCheck(this, IncludeMatch2);
        return _super.call(this, pattern);
      }
      _createClass(IncludeMatch2, [{
        key: "search",
        value: function search2(text) {
          var location = 0;
          var index;
          var indices = [];
          var patternLen = this.pattern.length;
          while ((index = text.indexOf(this.pattern, location)) > -1) {
            location = index + patternLen;
            indices.push([index, location - 1]);
          }
          var isMatch = !!indices.length;
          return {
            isMatch,
            score: isMatch ? 0 : 1,
            indices
          };
        }
      }], [{
        key: "type",
        get: function get2() {
          return "include";
        }
      }, {
        key: "multiRegex",
        get: function get2() {
          return /^'"(.*)"$/;
        }
      }, {
        key: "singleRegex",
        get: function get2() {
          return /^'(.*)$/;
        }
      }]);
      return IncludeMatch2;
    }(BaseMatch);
    var searchers = [ExactMatch, IncludeMatch, PrefixExactMatch, InversePrefixExactMatch, InverseSuffixExactMatch, SuffixExactMatch, InverseExactMatch, FuzzyMatch];
    var searchersLen = searchers.length;
    var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
    var OR_TOKEN = "|";
    function parseQuery(pattern) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      return pattern.split(OR_TOKEN).map(function(item) {
        var query = item.trim().split(SPACE_RE).filter(function(item2) {
          return item2 && !!item2.trim();
        });
        var results = [];
        for (var i = 0, len = query.length; i < len; i += 1) {
          var queryItem = query[i];
          var found = false;
          var idx = -1;
          while (!found && ++idx < searchersLen) {
            var searcher = searchers[idx];
            var token = searcher.isMultiMatch(queryItem);
            if (token) {
              results.push(new searcher(token, options));
              found = true;
            }
          }
          if (found) {
            continue;
          }
          idx = -1;
          while (++idx < searchersLen) {
            var _searcher = searchers[idx];
            var _token = _searcher.isSingleMatch(queryItem);
            if (_token) {
              results.push(new _searcher(_token, options));
              break;
            }
          }
        }
        return results;
      });
    }
    var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
    var ExtendedSearch = /* @__PURE__ */ function() {
      function ExtendedSearch2(pattern) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$isCaseSensitive = _ref.isCaseSensitive, isCaseSensitive = _ref$isCaseSensitive === void 0 ? Config.isCaseSensitive : _ref$isCaseSensitive, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$minMatchCharLeng = _ref.minMatchCharLength, minMatchCharLength = _ref$minMatchCharLeng === void 0 ? Config.minMatchCharLength : _ref$minMatchCharLeng, _ref$ignoreLocation = _ref.ignoreLocation, ignoreLocation = _ref$ignoreLocation === void 0 ? Config.ignoreLocation : _ref$ignoreLocation, _ref$findAllMatches = _ref.findAllMatches, findAllMatches = _ref$findAllMatches === void 0 ? Config.findAllMatches : _ref$findAllMatches, _ref$location = _ref.location, location = _ref$location === void 0 ? Config.location : _ref$location, _ref$threshold = _ref.threshold, threshold = _ref$threshold === void 0 ? Config.threshold : _ref$threshold, _ref$distance = _ref.distance, distance = _ref$distance === void 0 ? Config.distance : _ref$distance;
        _classCallCheck(this, ExtendedSearch2);
        this.query = null;
        this.options = {
          isCaseSensitive,
          includeMatches,
          minMatchCharLength,
          findAllMatches,
          ignoreLocation,
          location,
          threshold,
          distance
        };
        this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
        this.query = parseQuery(this.pattern, this.options);
      }
      _createClass(ExtendedSearch2, [{
        key: "searchIn",
        value: function searchIn(text) {
          var query = this.query;
          if (!query) {
            return {
              isMatch: false,
              score: 1
            };
          }
          var _this$options = this.options, includeMatches = _this$options.includeMatches, isCaseSensitive = _this$options.isCaseSensitive;
          text = isCaseSensitive ? text : text.toLowerCase();
          var numMatches = 0;
          var allIndices = [];
          var totalScore = 0;
          for (var i = 0, qLen = query.length; i < qLen; i += 1) {
            var searchers2 = query[i];
            allIndices.length = 0;
            numMatches = 0;
            for (var j = 0, pLen = searchers2.length; j < pLen; j += 1) {
              var searcher = searchers2[j];
              var _searcher$search = searcher.search(text), isMatch = _searcher$search.isMatch, indices = _searcher$search.indices, score = _searcher$search.score;
              if (isMatch) {
                numMatches += 1;
                totalScore += score;
                if (includeMatches) {
                  var type = searcher.constructor.type;
                  if (MultiMatchSet.has(type)) {
                    allIndices = [].concat(_toConsumableArray(allIndices), _toConsumableArray(indices));
                  } else {
                    allIndices.push(indices);
                  }
                }
              } else {
                totalScore = 0;
                numMatches = 0;
                allIndices.length = 0;
                break;
              }
            }
            if (numMatches) {
              var result = {
                isMatch: true,
                score: totalScore / numMatches
              };
              if (includeMatches) {
                result.indices = allIndices;
              }
              return result;
            }
          }
          return {
            isMatch: false,
            score: 1
          };
        }
      }], [{
        key: "condition",
        value: function condition(_, options) {
          return options.useExtendedSearch;
        }
      }]);
      return ExtendedSearch2;
    }();
    var registeredSearchers = [];
    function register() {
      registeredSearchers.push.apply(registeredSearchers, arguments);
    }
    function createSearcher(pattern, options) {
      for (var i = 0, len = registeredSearchers.length; i < len; i += 1) {
        var searcherClass = registeredSearchers[i];
        if (searcherClass.condition(pattern, options)) {
          return new searcherClass(pattern, options);
        }
      }
      return new BitapSearch(pattern, options);
    }
    var LogicalOperator = {
      AND: "$and",
      OR: "$or"
    };
    var KeyType = {
      PATH: "$path",
      PATTERN: "$val"
    };
    var isExpression = function isExpression2(query) {
      return !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
    };
    var isPath = function isPath2(query) {
      return !!query[KeyType.PATH];
    };
    var isLeaf = function isLeaf2(query) {
      return !isArray(query) && isObject(query) && !isExpression(query);
    };
    var convertToExplicit = function convertToExplicit2(query) {
      return _defineProperty({}, LogicalOperator.AND, Object.keys(query).map(function(key) {
        return _defineProperty({}, key, query[key]);
      }));
    };
    function parse(query, options) {
      var _ref3 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref3$auto = _ref3.auto, auto = _ref3$auto === void 0 ? true : _ref3$auto;
      var next = function next2(query2) {
        var keys = Object.keys(query2);
        var isQueryPath = isPath(query2);
        if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
          return next2(convertToExplicit(query2));
        }
        if (isLeaf(query2)) {
          var key = isQueryPath ? query2[KeyType.PATH] : keys[0];
          var pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
          if (!isString(pattern)) {
            throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
          }
          var obj = {
            keyId: createKeyId(key),
            pattern
          };
          if (auto) {
            obj.searcher = createSearcher(pattern, options);
          }
          return obj;
        }
        var node = {
          children: [],
          operator: keys[0]
        };
        keys.forEach(function(key2) {
          var value = query2[key2];
          if (isArray(value)) {
            value.forEach(function(item) {
              node.children.push(next2(item));
            });
          }
        });
        return node;
      };
      if (!isExpression(query)) {
        query = convertToExplicit(query);
      }
      return next(query);
    }
    function computeScore(results, _ref) {
      var _ref$ignoreFieldNorm = _ref.ignoreFieldNorm, ignoreFieldNorm = _ref$ignoreFieldNorm === void 0 ? Config.ignoreFieldNorm : _ref$ignoreFieldNorm;
      results.forEach(function(result) {
        var totalScore = 1;
        result.matches.forEach(function(_ref2) {
          var key = _ref2.key, norm2 = _ref2.norm, score = _ref2.score;
          var weight = key ? key.weight : null;
          totalScore *= Math.pow(score === 0 && weight ? Number.EPSILON : score, (weight || 1) * (ignoreFieldNorm ? 1 : norm2));
        });
        result.score = totalScore;
      });
    }
    function transformMatches(result, data) {
      var matches = result.matches;
      data.matches = [];
      if (!isDefined(matches)) {
        return;
      }
      matches.forEach(function(match) {
        if (!isDefined(match.indices) || !match.indices.length) {
          return;
        }
        var indices = match.indices, value = match.value;
        var obj = {
          indices,
          value
        };
        if (match.key) {
          obj.key = match.key.src;
        }
        if (match.idx > -1) {
          obj.refIndex = match.idx;
        }
        data.matches.push(obj);
      });
    }
    function transformScore(result, data) {
      data.score = result.score;
    }
    function format(results, docs) {
      var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, _ref$includeMatches = _ref.includeMatches, includeMatches = _ref$includeMatches === void 0 ? Config.includeMatches : _ref$includeMatches, _ref$includeScore = _ref.includeScore, includeScore = _ref$includeScore === void 0 ? Config.includeScore : _ref$includeScore;
      var transformers = [];
      if (includeMatches)
        transformers.push(transformMatches);
      if (includeScore)
        transformers.push(transformScore);
      return results.map(function(result) {
        var idx = result.idx;
        var data = {
          item: docs[idx],
          refIndex: idx
        };
        if (transformers.length) {
          transformers.forEach(function(transformer) {
            transformer(result, data);
          });
        }
        return data;
      });
    }
    var Fuse$1 = /* @__PURE__ */ function() {
      function Fuse2(docs) {
        var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
        var index = arguments.length > 2 ? arguments[2] : void 0;
        _classCallCheck(this, Fuse2);
        this.options = _objectSpread2(_objectSpread2({}, Config), options);
        if (this.options.useExtendedSearch && false) {
          throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
        }
        this._keyStore = new KeyStore(this.options.keys);
        this.setCollection(docs, index);
      }
      _createClass(Fuse2, [{
        key: "setCollection",
        value: function setCollection(docs, index) {
          this._docs = docs;
          if (index && !(index instanceof FuseIndex)) {
            throw new Error(INCORRECT_INDEX_TYPE);
          }
          this._myIndex = index || createIndex(this.options.keys, this._docs, {
            getFn: this.options.getFn,
            fieldNormWeight: this.options.fieldNormWeight
          });
        }
      }, {
        key: "add",
        value: function add(doc) {
          if (!isDefined(doc)) {
            return;
          }
          this._docs.push(doc);
          this._myIndex.add(doc);
        }
      }, {
        key: "remove",
        value: function remove() {
          var predicate = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : function() {
            return false;
          };
          var results = [];
          for (var i = 0, len = this._docs.length; i < len; i += 1) {
            var doc = this._docs[i];
            if (predicate(doc, i)) {
              this.removeAt(i);
              i -= 1;
              len -= 1;
              results.push(doc);
            }
          }
          return results;
        }
      }, {
        key: "removeAt",
        value: function removeAt(idx) {
          this._docs.splice(idx, 1);
          this._myIndex.removeAt(idx);
        }
      }, {
        key: "getIndex",
        value: function getIndex() {
          return this._myIndex;
        }
      }, {
        key: "search",
        value: function search2(query) {
          var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$limit = _ref.limit, limit = _ref$limit === void 0 ? -1 : _ref$limit;
          var _this$options = this.options, includeMatches = _this$options.includeMatches, includeScore = _this$options.includeScore, shouldSort = _this$options.shouldSort, sortFn = _this$options.sortFn, ignoreFieldNorm = _this$options.ignoreFieldNorm;
          var results = isString(query) ? isString(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
          computeScore(results, {
            ignoreFieldNorm
          });
          if (shouldSort) {
            results.sort(sortFn);
          }
          if (isNumber(limit) && limit > -1) {
            results = results.slice(0, limit);
          }
          return format(results, this._docs, {
            includeMatches,
            includeScore
          });
        }
      }, {
        key: "_searchStringList",
        value: function _searchStringList(query) {
          var searcher = createSearcher(query, this.options);
          var records = this._myIndex.records;
          var results = [];
          records.forEach(function(_ref2) {
            var text = _ref2.v, idx = _ref2.i, norm2 = _ref2.n;
            if (!isDefined(text)) {
              return;
            }
            var _searcher$searchIn = searcher.searchIn(text), isMatch = _searcher$searchIn.isMatch, score = _searcher$searchIn.score, indices = _searcher$searchIn.indices;
            if (isMatch) {
              results.push({
                item: text,
                idx,
                matches: [{
                  score,
                  value: text,
                  norm: norm2,
                  indices
                }]
              });
            }
          });
          return results;
        }
      }, {
        key: "_searchLogical",
        value: function _searchLogical(query) {
          var _this = this;
          var expression = parse(query, this.options);
          var evaluate = function evaluate2(node, item, idx) {
            if (!node.children) {
              var keyId = node.keyId, searcher = node.searcher;
              var matches = _this._findMatches({
                key: _this._keyStore.get(keyId),
                value: _this._myIndex.getValueForItemAtKeyId(item, keyId),
                searcher
              });
              if (matches && matches.length) {
                return [{
                  idx,
                  item,
                  matches
                }];
              }
              return [];
            }
            var res = [];
            for (var i = 0, len = node.children.length; i < len; i += 1) {
              var child = node.children[i];
              var result = evaluate2(child, item, idx);
              if (result.length) {
                res.push.apply(res, _toConsumableArray(result));
              } else if (node.operator === LogicalOperator.AND) {
                return [];
              }
            }
            return res;
          };
          var records = this._myIndex.records;
          var resultMap = {};
          var results = [];
          records.forEach(function(_ref3) {
            var item = _ref3.$, idx = _ref3.i;
            if (isDefined(item)) {
              var expResults = evaluate(expression, item, idx);
              if (expResults.length) {
                if (!resultMap[idx]) {
                  resultMap[idx] = {
                    idx,
                    item,
                    matches: []
                  };
                  results.push(resultMap[idx]);
                }
                expResults.forEach(function(_ref4) {
                  var _resultMap$idx$matche;
                  var matches = _ref4.matches;
                  (_resultMap$idx$matche = resultMap[idx].matches).push.apply(_resultMap$idx$matche, _toConsumableArray(matches));
                });
              }
            }
          });
          return results;
        }
      }, {
        key: "_searchObjectList",
        value: function _searchObjectList(query) {
          var _this2 = this;
          var searcher = createSearcher(query, this.options);
          var _this$_myIndex = this._myIndex, keys = _this$_myIndex.keys, records = _this$_myIndex.records;
          var results = [];
          records.forEach(function(_ref5) {
            var item = _ref5.$, idx = _ref5.i;
            if (!isDefined(item)) {
              return;
            }
            var matches = [];
            keys.forEach(function(key, keyIndex) {
              matches.push.apply(matches, _toConsumableArray(_this2._findMatches({
                key,
                value: item[keyIndex],
                searcher
              })));
            });
            if (matches.length) {
              results.push({
                idx,
                item,
                matches
              });
            }
          });
          return results;
        }
      }, {
        key: "_findMatches",
        value: function _findMatches(_ref6) {
          var key = _ref6.key, value = _ref6.value, searcher = _ref6.searcher;
          if (!isDefined(value)) {
            return [];
          }
          var matches = [];
          if (isArray(value)) {
            value.forEach(function(_ref7) {
              var text2 = _ref7.v, idx = _ref7.i, norm3 = _ref7.n;
              if (!isDefined(text2)) {
                return;
              }
              var _searcher$searchIn2 = searcher.searchIn(text2), isMatch2 = _searcher$searchIn2.isMatch, score2 = _searcher$searchIn2.score, indices2 = _searcher$searchIn2.indices;
              if (isMatch2) {
                matches.push({
                  score: score2,
                  key,
                  value: text2,
                  idx,
                  norm: norm3,
                  indices: indices2
                });
              }
            });
          } else {
            var text = value.v, norm2 = value.n;
            var _searcher$searchIn3 = searcher.searchIn(text), isMatch = _searcher$searchIn3.isMatch, score = _searcher$searchIn3.score, indices = _searcher$searchIn3.indices;
            if (isMatch) {
              matches.push({
                score,
                key,
                value: text,
                norm: norm2,
                indices
              });
            }
          }
          return matches;
        }
      }]);
      return Fuse2;
    }();
    Fuse$1.version = "6.6.2";
    Fuse$1.createIndex = createIndex;
    Fuse$1.parseIndex = parseIndex;
    Fuse$1.config = Config;
    {
      Fuse$1.parseQuery = parse;
    }
    {
      register(ExtendedSearch);
    }
    var Fuse = Fuse$1;
    module2.exports = Fuse;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index/fuseIndex.js
var require_fuseIndex = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index/fuseIndex.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fuseIndex = void 0;
    var fuse_js_1 = __importDefault(require_fuse_common());
    function fuseIndex(suggestions) {
      var docs = suggestions.map(function(suggestion) {
        return {
          text: suggestion.segments.map(function(segment) {
            return typeof segment === "string" ? segment : segment.join(" ");
          }).join("")
        };
      });
      var fuse = new fuse_js_1.default(docs, {
        keys: ["text"],
        minMatchCharLength: 2,
        threshold: 0.1,
        ignoreLocation: true,
        fieldNormWeight: 1,
        shouldSort: true
      });
      return function(text) {
        if (!text)
          return [];
        var results = fuse.search(text, { limit: 10 });
        return results.map(function(result) {
          return suggestions[result.refIndex];
        });
      };
    }
    exports2.fuseIndex = fuseIndex;
  }
});

// node_modules/js-search/dist/umd/js-search.js
var require_js_search = __commonJS({
  "node_modules/js-search/dist/umd/js-search.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = global2 || self, factory(global2.JsSearch = {}));
    })(exports2, function(exports3) {
      "use strict";
      var AllSubstringsIndexStrategy = /* @__PURE__ */ function() {
        function AllSubstringsIndexStrategy2() {
        }
        var _proto = AllSubstringsIndexStrategy2.prototype;
        _proto.expandToken = function expandToken(token) {
          var expandedTokens = [];
          var string;
          for (var i = 0, length = token.length; i < length; ++i) {
            string = "";
            for (var j = i; j < length; ++j) {
              string += token.charAt(j);
              expandedTokens.push(string);
            }
          }
          return expandedTokens;
        };
        return AllSubstringsIndexStrategy2;
      }();
      var ExactWordIndexStrategy = /* @__PURE__ */ function() {
        function ExactWordIndexStrategy2() {
        }
        var _proto = ExactWordIndexStrategy2.prototype;
        _proto.expandToken = function expandToken(token) {
          return token ? [token] : [];
        };
        return ExactWordIndexStrategy2;
      }();
      var PrefixIndexStrategy = /* @__PURE__ */ function() {
        function PrefixIndexStrategy2() {
        }
        var _proto = PrefixIndexStrategy2.prototype;
        _proto.expandToken = function expandToken(token) {
          var expandedTokens = [];
          var string = "";
          for (var i = 0, length = token.length; i < length; ++i) {
            string += token.charAt(i);
            expandedTokens.push(string);
          }
          return expandedTokens;
        };
        return PrefixIndexStrategy2;
      }();
      var CaseSensitiveSanitizer = /* @__PURE__ */ function() {
        function CaseSensitiveSanitizer2() {
        }
        var _proto = CaseSensitiveSanitizer2.prototype;
        _proto.sanitize = function sanitize(text) {
          return text ? text.trim() : "";
        };
        return CaseSensitiveSanitizer2;
      }();
      var LowerCaseSanitizer = /* @__PURE__ */ function() {
        function LowerCaseSanitizer2() {
        }
        var _proto = LowerCaseSanitizer2.prototype;
        _proto.sanitize = function sanitize(text) {
          return text ? text.toLocaleLowerCase().trim() : "";
        };
        return LowerCaseSanitizer2;
      }();
      function getNestedFieldValue(object, path) {
        path = path || [];
        object = object || {};
        var value = object;
        for (var i = 0; i < path.length; i++) {
          value = value[path[i]];
          if (value == null) {
            return null;
          }
        }
        return value;
      }
      var TfIdfSearchIndex = /* @__PURE__ */ function() {
        function TfIdfSearchIndex2(uidFieldName) {
          this._uidFieldName = uidFieldName;
          this._tokenToIdfCache = {};
          this._tokenMap = {};
        }
        var _proto = TfIdfSearchIndex2.prototype;
        _proto.indexDocument = function indexDocument(token, uid, doc) {
          this._tokenToIdfCache = {};
          var tokenMap = this._tokenMap;
          var tokenDatum;
          if (typeof tokenMap[token] !== "object") {
            tokenMap[token] = tokenDatum = {
              $numDocumentOccurrences: 0,
              $totalNumOccurrences: 1,
              $uidMap: {}
            };
          } else {
            tokenDatum = tokenMap[token];
            tokenDatum.$totalNumOccurrences++;
          }
          var uidMap = tokenDatum.$uidMap;
          if (typeof uidMap[uid] !== "object") {
            tokenDatum.$numDocumentOccurrences++;
            uidMap[uid] = {
              $document: doc,
              $numTokenOccurrences: 1
            };
          } else {
            uidMap[uid].$numTokenOccurrences++;
          }
        };
        _proto.search = function search(tokens, corpus) {
          var uidToDocumentMap = {};
          for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {
            var token = tokens[i];
            var tokenMetadata = this._tokenMap[token];
            if (!tokenMetadata) {
              return [];
            }
            if (i === 0) {
              var keys = Object.keys(tokenMetadata.$uidMap);
              for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
                var uid = keys[j];
                uidToDocumentMap[uid] = tokenMetadata.$uidMap[uid].$document;
              }
            } else {
              var keys = Object.keys(uidToDocumentMap);
              for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
                var uid = keys[j];
                if (typeof tokenMetadata.$uidMap[uid] !== "object") {
                  delete uidToDocumentMap[uid];
                }
              }
            }
          }
          var documents = [];
          for (var uid in uidToDocumentMap) {
            documents.push(uidToDocumentMap[uid]);
          }
          var calculateTfIdf = this._createCalculateTfIdf();
          return documents.sort(function(documentA, documentB) {
            return calculateTfIdf(tokens, documentB, corpus) - calculateTfIdf(tokens, documentA, corpus);
          });
        };
        _proto._createCalculateIdf = function _createCalculateIdf() {
          var tokenMap = this._tokenMap;
          var tokenToIdfCache = this._tokenToIdfCache;
          return function calculateIdf(token, documents) {
            if (!tokenToIdfCache[token]) {
              var numDocumentsWithToken = typeof tokenMap[token] !== "undefined" ? tokenMap[token].$numDocumentOccurrences : 0;
              tokenToIdfCache[token] = 1 + Math.log(documents.length / (1 + numDocumentsWithToken));
            }
            return tokenToIdfCache[token];
          };
        };
        _proto._createCalculateTfIdf = function _createCalculateTfIdf() {
          var tokenMap = this._tokenMap;
          var uidFieldName = this._uidFieldName;
          var calculateIdf = this._createCalculateIdf();
          return function calculateTfIdf(tokens, document, documents) {
            var score = 0;
            for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
              var token = tokens[i];
              var inverseDocumentFrequency = calculateIdf(token, documents);
              if (inverseDocumentFrequency === Infinity) {
                inverseDocumentFrequency = 0;
              }
              var uid;
              if (uidFieldName instanceof Array) {
                uid = document && getNestedFieldValue(document, uidFieldName);
              } else {
                uid = document && document[uidFieldName];
              }
              var termFrequency = typeof tokenMap[token] !== "undefined" && typeof tokenMap[token].$uidMap[uid] !== "undefined" ? tokenMap[token].$uidMap[uid].$numTokenOccurrences : 0;
              score += termFrequency * inverseDocumentFrequency;
            }
            return score;
          };
        };
        return TfIdfSearchIndex2;
      }();
      var UnorderedSearchIndex = /* @__PURE__ */ function() {
        function UnorderedSearchIndex2() {
          this._tokenToUidToDocumentMap = {};
        }
        var _proto = UnorderedSearchIndex2.prototype;
        _proto.indexDocument = function indexDocument(token, uid, doc) {
          if (typeof this._tokenToUidToDocumentMap[token] !== "object") {
            this._tokenToUidToDocumentMap[token] = {};
          }
          this._tokenToUidToDocumentMap[token][uid] = doc;
        };
        _proto.search = function search(tokens, corpus) {
          var intersectingDocumentMap = {};
          var tokenToUidToDocumentMap = this._tokenToUidToDocumentMap;
          for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {
            var token = tokens[i];
            var documentMap = tokenToUidToDocumentMap[token];
            if (!documentMap) {
              return [];
            }
            if (i === 0) {
              var keys = Object.keys(documentMap);
              for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
                var uid = keys[j];
                intersectingDocumentMap[uid] = documentMap[uid];
              }
            } else {
              var keys = Object.keys(intersectingDocumentMap);
              for (var j = 0, numKeys = keys.length; j < numKeys; j++) {
                var uid = keys[j];
                if (typeof documentMap[uid] !== "object") {
                  delete intersectingDocumentMap[uid];
                }
              }
            }
          }
          var keys = Object.keys(intersectingDocumentMap);
          var documents = [];
          for (var i = 0, numKeys = keys.length; i < numKeys; i++) {
            var uid = keys[i];
            documents.push(intersectingDocumentMap[uid]);
          }
          return documents;
        };
        return UnorderedSearchIndex2;
      }();
      var REGEX = /[^a-zа-яё0-9\-']+/i;
      var SimpleTokenizer = /* @__PURE__ */ function() {
        function SimpleTokenizer2() {
        }
        var _proto = SimpleTokenizer2.prototype;
        _proto.tokenize = function tokenize(text) {
          return text.split(REGEX).filter(function(text2) {
            return text2;
          });
        };
        return SimpleTokenizer2;
      }();
      var StemmingTokenizer = /* @__PURE__ */ function() {
        function StemmingTokenizer2(stemmingFunction, decoratedTokenizer) {
          this._stemmingFunction = stemmingFunction;
          this._tokenizer = decoratedTokenizer;
        }
        var _proto = StemmingTokenizer2.prototype;
        _proto.tokenize = function tokenize(text) {
          return this._tokenizer.tokenize(text).map(this._stemmingFunction);
        };
        return StemmingTokenizer2;
      }();
      var StopWordsMap = {
        a: true,
        able: true,
        about: true,
        across: true,
        after: true,
        all: true,
        almost: true,
        also: true,
        am: true,
        among: true,
        an: true,
        and: true,
        any: true,
        are: true,
        as: true,
        at: true,
        be: true,
        because: true,
        been: true,
        but: true,
        by: true,
        can: true,
        cannot: true,
        could: true,
        dear: true,
        did: true,
        "do": true,
        does: true,
        either: true,
        "else": true,
        ever: true,
        every: true,
        "for": true,
        from: true,
        "get": true,
        got: true,
        had: true,
        has: true,
        have: true,
        he: true,
        her: true,
        hers: true,
        him: true,
        his: true,
        how: true,
        however: true,
        i: true,
        "if": true,
        "in": true,
        into: true,
        is: true,
        it: true,
        its: true,
        just: true,
        least: true,
        "let": true,
        like: true,
        likely: true,
        may: true,
        me: true,
        might: true,
        most: true,
        must: true,
        my: true,
        neither: true,
        no: true,
        nor: true,
        not: true,
        of: true,
        off: true,
        often: true,
        on: true,
        only: true,
        or: true,
        other: true,
        our: true,
        own: true,
        rather: true,
        said: true,
        say: true,
        says: true,
        she: true,
        should: true,
        since: true,
        so: true,
        some: true,
        than: true,
        that: true,
        the: true,
        their: true,
        them: true,
        then: true,
        there: true,
        these: true,
        they: true,
        "this": true,
        tis: true,
        to: true,
        too: true,
        twas: true,
        us: true,
        wants: true,
        was: true,
        we: true,
        were: true,
        what: true,
        when: true,
        where: true,
        which: true,
        "while": true,
        who: true,
        whom: true,
        why: true,
        will: true,
        "with": true,
        would: true,
        yet: true,
        you: true,
        your: true
      };
      StopWordsMap.constructor = false;
      StopWordsMap.hasOwnProperty = false;
      StopWordsMap.isPrototypeOf = false;
      StopWordsMap.propertyIsEnumerable = false;
      StopWordsMap.toLocaleString = false;
      StopWordsMap.toString = false;
      StopWordsMap.valueOf = false;
      var StopWordsTokenizer = /* @__PURE__ */ function() {
        function StopWordsTokenizer2(decoratedTokenizer) {
          this._tokenizer = decoratedTokenizer;
        }
        var _proto = StopWordsTokenizer2.prototype;
        _proto.tokenize = function tokenize(text) {
          return this._tokenizer.tokenize(text).filter(function(token) {
            return !StopWordsMap[token];
          });
        };
        return StopWordsTokenizer2;
      }();
      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps)
          _defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      var Search = /* @__PURE__ */ function() {
        function Search2(uidFieldName) {
          if (!uidFieldName) {
            throw Error("js-search requires a uid field name constructor parameter");
          }
          this._uidFieldName = uidFieldName;
          this._indexStrategy = new PrefixIndexStrategy();
          this._searchIndex = new TfIdfSearchIndex(uidFieldName);
          this._sanitizer = new LowerCaseSanitizer();
          this._tokenizer = new SimpleTokenizer();
          this._documents = [];
          this._searchableFields = [];
        }
        var _proto = Search2.prototype;
        _proto.addDocument = function addDocument(document) {
          this.addDocuments([document]);
        };
        _proto.addDocuments = function addDocuments(documents) {
          this._documents = this._documents.concat(documents);
          this.indexDocuments_(documents, this._searchableFields);
        };
        _proto.addIndex = function addIndex(field) {
          this._searchableFields.push(field);
          this.indexDocuments_(this._documents, [field]);
        };
        _proto.search = function search(query) {
          var tokens = this._tokenizer.tokenize(this._sanitizer.sanitize(query));
          return this._searchIndex.search(tokens, this._documents);
        };
        _proto.indexDocuments_ = function indexDocuments_(documents, _searchableFields) {
          this._initialized = true;
          var indexStrategy = this._indexStrategy;
          var sanitizer = this._sanitizer;
          var searchIndex = this._searchIndex;
          var tokenizer = this._tokenizer;
          var uidFieldName = this._uidFieldName;
          for (var di = 0, numDocuments = documents.length; di < numDocuments; di++) {
            var doc = documents[di];
            var uid;
            if (uidFieldName instanceof Array) {
              uid = getNestedFieldValue(doc, uidFieldName);
            } else {
              uid = doc[uidFieldName];
            }
            for (var sfi = 0, numSearchableFields = _searchableFields.length; sfi < numSearchableFields; sfi++) {
              var fieldValue;
              var searchableField = _searchableFields[sfi];
              if (searchableField instanceof Array) {
                fieldValue = getNestedFieldValue(doc, searchableField);
              } else {
                fieldValue = doc[searchableField];
              }
              if (fieldValue != null && typeof fieldValue !== "string" && fieldValue.toString) {
                fieldValue = fieldValue.toString();
              }
              if (typeof fieldValue === "string") {
                var fieldTokens = tokenizer.tokenize(sanitizer.sanitize(fieldValue));
                for (var fti = 0, numFieldValues = fieldTokens.length; fti < numFieldValues; fti++) {
                  var fieldToken = fieldTokens[fti];
                  var expandedTokens = indexStrategy.expandToken(fieldToken);
                  for (var eti = 0, nummExpandedTokens = expandedTokens.length; eti < nummExpandedTokens; eti++) {
                    var expandedToken = expandedTokens[eti];
                    searchIndex.indexDocument(expandedToken, uid, doc);
                  }
                }
              }
            }
          }
        };
        _createClass(Search2, [{
          key: "indexStrategy",
          set: function set(value) {
            if (this._initialized) {
              throw Error("IIndexStrategy cannot be set after initialization");
            }
            this._indexStrategy = value;
          },
          get: function get() {
            return this._indexStrategy;
          }
        }, {
          key: "sanitizer",
          set: function set(value) {
            if (this._initialized) {
              throw Error("ISanitizer cannot be set after initialization");
            }
            this._sanitizer = value;
          },
          get: function get() {
            return this._sanitizer;
          }
        }, {
          key: "searchIndex",
          set: function set(value) {
            if (this._initialized) {
              throw Error("ISearchIndex cannot be set after initialization");
            }
            this._searchIndex = value;
          },
          get: function get() {
            return this._searchIndex;
          }
        }, {
          key: "tokenizer",
          set: function set(value) {
            if (this._initialized) {
              throw Error("ITokenizer cannot be set after initialization");
            }
            this._tokenizer = value;
          },
          get: function get() {
            return this._tokenizer;
          }
        }]);
        return Search2;
      }();
      var TokenHighlighter = /* @__PURE__ */ function() {
        function TokenHighlighter2(opt_indexStrategy, opt_sanitizer, opt_wrapperTagName) {
          this._indexStrategy = opt_indexStrategy || new PrefixIndexStrategy();
          this._sanitizer = opt_sanitizer || new LowerCaseSanitizer();
          this._wrapperTagName = opt_wrapperTagName || "mark";
        }
        var _proto = TokenHighlighter2.prototype;
        _proto.highlight = function highlight(text, tokens) {
          var tagsLength = this._wrapText("").length;
          var tokenDictionary = /* @__PURE__ */ Object.create(null);
          for (var i = 0, numTokens = tokens.length; i < numTokens; i++) {
            var token = this._sanitizer.sanitize(tokens[i]);
            var expandedTokens = this._indexStrategy.expandToken(token);
            for (var j = 0, numExpandedTokens = expandedTokens.length; j < numExpandedTokens; j++) {
              var expandedToken = expandedTokens[j];
              if (!tokenDictionary[expandedToken]) {
                tokenDictionary[expandedToken] = [token];
              } else {
                tokenDictionary[expandedToken].push(token);
              }
            }
          }
          var actualCurrentWord = "";
          var sanitizedCurrentWord = "";
          var currentWordStartIndex = 0;
          for (var i = 0, textLength = text.length; i < textLength; i++) {
            var character = text.charAt(i);
            if (character === " ") {
              actualCurrentWord = "";
              sanitizedCurrentWord = "";
              currentWordStartIndex = i + 1;
            } else {
              actualCurrentWord += character;
              sanitizedCurrentWord += this._sanitizer.sanitize(character);
            }
            if (tokenDictionary[sanitizedCurrentWord] && tokenDictionary[sanitizedCurrentWord].indexOf(sanitizedCurrentWord) >= 0) {
              actualCurrentWord = this._wrapText(actualCurrentWord);
              text = text.substring(0, currentWordStartIndex) + actualCurrentWord + text.substring(i + 1);
              i += tagsLength;
              textLength += tagsLength;
            }
          }
          return text;
        };
        _proto._wrapText = function _wrapText(text) {
          var tagName = this._wrapperTagName;
          return "<" + tagName + ">" + text + "</" + tagName + ">";
        };
        return TokenHighlighter2;
      }();
      exports3.AllSubstringsIndexStrategy = AllSubstringsIndexStrategy;
      exports3.CaseSensitiveSanitizer = CaseSensitiveSanitizer;
      exports3.ExactWordIndexStrategy = ExactWordIndexStrategy;
      exports3.LowerCaseSanitizer = LowerCaseSanitizer;
      exports3.PrefixIndexStrategy = PrefixIndexStrategy;
      exports3.Search = Search;
      exports3.SimpleTokenizer = SimpleTokenizer;
      exports3.StemmingTokenizer = StemmingTokenizer;
      exports3.StopWordsMap = StopWordsMap;
      exports3.StopWordsTokenizer = StopWordsTokenizer;
      exports3.TfIdfSearchIndex = TfIdfSearchIndex;
      exports3.TokenHighlighter = TokenHighlighter;
      exports3.UnorderedSearchIndex = UnorderedSearchIndex;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index/jsSearchIndex.js
var require_jsSearchIndex = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index/jsSearchIndex.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.jsSearchIndex = void 0;
    var js_search_1 = require_js_search();
    function jsSearchIndex(suggestions) {
      var docs = suggestions.map(function(suggestion, id) {
        return {
          id,
          text: suggestion.segments.map(function(segment) {
            return typeof segment === "string" ? segment : segment.join(" ");
          }).join("")
        };
      });
      var search = new js_search_1.Search("id");
      search.addIndex("text");
      search.addDocuments(docs);
      return function(text) {
        if (!text)
          return [];
        var results = search.search(text);
        return results.map(function(result) {
          return suggestions[result.id];
        });
      };
    }
    exports2.jsSearchIndex = jsSearchIndex;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index/types.js
var require_types2 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index/index.js
var require_index = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_bruteForceIndex(), exports2);
    __exportStar(require_fuseIndex(), exports2);
    __exportStar(require_jsSearchIndex(), exports2);
    __exportStar(require_types2(), exports2);
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionError.js
var require_CucumberExpressionError = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionError.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CucumberExpressionError = function(_super) {
      __extends(CucumberExpressionError2, _super);
      function CucumberExpressionError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      return CucumberExpressionError2;
    }(Error);
    exports2.default = CucumberExpressionError;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Argument.js
var require_Argument = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Argument.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CucumberExpressionError_js_1 = __importDefault(require_CucumberExpressionError());
    var Argument = function() {
      function Argument2(group, parameterType) {
        this.group = group;
        this.parameterType = parameterType;
        this.group = group;
        this.parameterType = parameterType;
      }
      Argument2.build = function(group, parameterTypes) {
        var argGroups = group.children;
        if (argGroups.length !== parameterTypes.length) {
          throw new CucumberExpressionError_js_1.default("Group has ".concat(argGroups.length, " capture groups (").concat(argGroups.map(function(g) {
            return g.value;
          }), "), but there were ").concat(parameterTypes.length, " parameter types (").concat(parameterTypes.map(function(p) {
            return p.name;
          }), ")"));
        }
        return parameterTypes.map(function(parameterType, i) {
          return new Argument2(argGroups[i], parameterType);
        });
      };
      Argument2.prototype.getValue = function(thisObj) {
        var groupValues = this.group ? this.group.values : null;
        return this.parameterType.transform(thisObj, groupValues);
      };
      Argument2.prototype.getParameterType = function() {
        return this.parameterType;
      };
      return Argument2;
    }();
    exports2.default = Argument;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Ast.js
var require_Ast = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenType = exports2.Token = exports2.NodeType = exports2.Node = exports2.purposeOf = exports2.symbolOf = void 0;
    var escapeCharacter = "\\";
    var alternationCharacter = "/";
    var beginParameterCharacter = "{";
    var endParameterCharacter = "}";
    var beginOptionalCharacter = "(";
    var endOptionalCharacter = ")";
    function symbolOf(token) {
      switch (token) {
        case TokenType.beginOptional:
          return beginOptionalCharacter;
        case TokenType.endOptional:
          return endOptionalCharacter;
        case TokenType.beginParameter:
          return beginParameterCharacter;
        case TokenType.endParameter:
          return endParameterCharacter;
        case TokenType.alternation:
          return alternationCharacter;
      }
      return "";
    }
    exports2.symbolOf = symbolOf;
    function purposeOf(token) {
      switch (token) {
        case TokenType.beginOptional:
        case TokenType.endOptional:
          return "optional text";
        case TokenType.beginParameter:
        case TokenType.endParameter:
          return "a parameter";
        case TokenType.alternation:
          return "alternation";
      }
      return "";
    }
    exports2.purposeOf = purposeOf;
    var Node = function() {
      function Node2(type, nodes, token, start, end) {
        this.type = type;
        this.nodes = nodes;
        this.token = token;
        this.start = start;
        this.end = end;
        if (nodes === void 0 && token === void 0) {
          throw new Error("Either nodes or token must be defined");
        }
      }
      Node2.prototype.text = function() {
        if (this.nodes && this.nodes.length > 0) {
          return this.nodes.map(function(value) {
            return value.text();
          }).join("");
        }
        return this.token || "";
      };
      return Node2;
    }();
    exports2.Node = Node;
    var NodeType;
    (function(NodeType2) {
      NodeType2["text"] = "TEXT_NODE";
      NodeType2["optional"] = "OPTIONAL_NODE";
      NodeType2["alternation"] = "ALTERNATION_NODE";
      NodeType2["alternative"] = "ALTERNATIVE_NODE";
      NodeType2["parameter"] = "PARAMETER_NODE";
      NodeType2["expression"] = "EXPRESSION_NODE";
    })(NodeType = exports2.NodeType || (exports2.NodeType = {}));
    var Token = function() {
      function Token2(type, text, start, end) {
        this.type = type;
        this.text = text;
        this.start = start;
        this.end = end;
      }
      Token2.isEscapeCharacter = function(codePoint) {
        return codePoint == escapeCharacter;
      };
      Token2.canEscape = function(codePoint) {
        if (codePoint == " ") {
          return true;
        }
        switch (codePoint) {
          case escapeCharacter:
            return true;
          case alternationCharacter:
            return true;
          case beginParameterCharacter:
            return true;
          case endParameterCharacter:
            return true;
          case beginOptionalCharacter:
            return true;
          case endOptionalCharacter:
            return true;
        }
        return false;
      };
      Token2.typeOf = function(codePoint) {
        if (codePoint == " ") {
          return TokenType.whiteSpace;
        }
        switch (codePoint) {
          case alternationCharacter:
            return TokenType.alternation;
          case beginParameterCharacter:
            return TokenType.beginParameter;
          case endParameterCharacter:
            return TokenType.endParameter;
          case beginOptionalCharacter:
            return TokenType.beginOptional;
          case endOptionalCharacter:
            return TokenType.endOptional;
        }
        return TokenType.text;
      };
      return Token2;
    }();
    exports2.Token = Token;
    var TokenType;
    (function(TokenType2) {
      TokenType2["startOfLine"] = "START_OF_LINE";
      TokenType2["endOfLine"] = "END_OF_LINE";
      TokenType2["whiteSpace"] = "WHITE_SPACE";
      TokenType2["beginOptional"] = "BEGIN_OPTIONAL";
      TokenType2["endOptional"] = "END_OPTIONAL";
      TokenType2["beginParameter"] = "BEGIN_PARAMETER";
      TokenType2["endParameter"] = "END_PARAMETER";
      TokenType2["alternation"] = "ALTERNATION";
      TokenType2["text"] = "TEXT";
    })(TokenType = exports2.TokenType || (exports2.TokenType = {}));
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Errors.js
var require_Errors2 = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Errors.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createUndefinedParameterType = exports2.UndefinedParameterTypeError = exports2.AmbiguousParameterTypeError = exports2.createInvalidParameterTypeNameInNode = exports2.createCantEscaped = exports2.createAlternationNotAllowedInOptional = exports2.createMissingEndToken = exports2.createTheEndOfLIneCanNotBeEscaped = exports2.createOptionalIsNotAllowedInOptional = exports2.createParameterIsNotAllowedInOptional = exports2.createOptionalMayNotBeEmpty = exports2.createAlternativeMayNotBeEmpty = exports2.createAlternativeMayNotExclusivelyContainOptionals = void 0;
    var Ast_js_1 = require_Ast();
    var CucumberExpressionError_js_1 = __importDefault(require_CucumberExpressionError());
    function createAlternativeMayNotExclusivelyContainOptionals(node, expression) {
      return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), "An alternative may not exclusively contain optionals", "If you did not mean to use an optional you can use '\\(' to escape the the '('"));
    }
    exports2.createAlternativeMayNotExclusivelyContainOptionals = createAlternativeMayNotExclusivelyContainOptionals;
    function createAlternativeMayNotBeEmpty(node, expression) {
      return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), "Alternative may not be empty", "If you did not mean to use an alternative you can use '\\/' to escape the the '/'"));
    }
    exports2.createAlternativeMayNotBeEmpty = createAlternativeMayNotBeEmpty;
    function createOptionalMayNotBeEmpty(node, expression) {
      return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), "An optional must contain some text", "If you did not mean to use an optional you can use '\\(' to escape the the '('"));
    }
    exports2.createOptionalMayNotBeEmpty = createOptionalMayNotBeEmpty;
    function createParameterIsNotAllowedInOptional(node, expression) {
      return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), "An optional may not contain a parameter type", "If you did not mean to use an parameter type you can use '\\{' to escape the the '{'"));
    }
    exports2.createParameterIsNotAllowedInOptional = createParameterIsNotAllowedInOptional;
    function createOptionalIsNotAllowedInOptional(node, expression) {
      return new CucumberExpressionError_js_1.default(message(node.start, expression, pointAtLocated(node), "An optional may not contain an other optional", "If you did not mean to use an optional type you can use '\\(' to escape the the '('. For more complicated expressions consider using a regular expression instead."));
    }
    exports2.createOptionalIsNotAllowedInOptional = createOptionalIsNotAllowedInOptional;
    function createTheEndOfLIneCanNotBeEscaped(expression) {
      var index = Array.from(expression).length - 1;
      return new CucumberExpressionError_js_1.default(message(index, expression, pointAt(index), "The end of line can not be escaped", "You can use '\\\\' to escape the the '\\'"));
    }
    exports2.createTheEndOfLIneCanNotBeEscaped = createTheEndOfLIneCanNotBeEscaped;
    function createMissingEndToken(expression, beginToken, endToken, current) {
      var beginSymbol = (0, Ast_js_1.symbolOf)(beginToken);
      var endSymbol = (0, Ast_js_1.symbolOf)(endToken);
      var purpose = (0, Ast_js_1.purposeOf)(beginToken);
      return new CucumberExpressionError_js_1.default(message(current.start, expression, pointAtLocated(current), "The '".concat(beginSymbol, "' does not have a matching '").concat(endSymbol, "'"), "If you did not intend to use ".concat(purpose, " you can use '\\").concat(beginSymbol, "' to escape the ").concat(purpose)));
    }
    exports2.createMissingEndToken = createMissingEndToken;
    function createAlternationNotAllowedInOptional(expression, current) {
      return new CucumberExpressionError_js_1.default(message(current.start, expression, pointAtLocated(current), "An alternation can not be used inside an optional", "You can use '\\/' to escape the the '/'"));
    }
    exports2.createAlternationNotAllowedInOptional = createAlternationNotAllowedInOptional;
    function createCantEscaped(expression, index) {
      return new CucumberExpressionError_js_1.default(message(index, expression, pointAt(index), "Only the characters '{', '}', '(', ')', '\\', '/' and whitespace can be escaped", "If you did mean to use an '\\' you can use '\\\\' to escape it"));
    }
    exports2.createCantEscaped = createCantEscaped;
    function createInvalidParameterTypeNameInNode(token, expression) {
      return new CucumberExpressionError_js_1.default(message(token.start, expression, pointAtLocated(token), "Parameter names may not contain '{', '}', '(', ')', '\\' or '/'", "Did you mean to use a regular expression?"));
    }
    exports2.createInvalidParameterTypeNameInNode = createInvalidParameterTypeNameInNode;
    function message(index, expression, pointer, problem, solution) {
      return "This Cucumber Expression has a problem at column ".concat(index + 1, ":\n\n").concat(expression, "\n").concat(pointer, "\n").concat(problem, ".\n").concat(solution);
    }
    function pointAt(index) {
      var pointer = [];
      for (var i = 0; i < index; i++) {
        pointer.push(" ");
      }
      pointer.push("^");
      return pointer.join("");
    }
    function pointAtLocated(node) {
      var pointer = [pointAt(node.start)];
      if (node.start + 1 < node.end) {
        for (var i = node.start + 1; i < node.end - 1; i++) {
          pointer.push("-");
        }
        pointer.push("^");
      }
      return pointer.join("");
    }
    var AmbiguousParameterTypeError = function(_super) {
      __extends(AmbiguousParameterTypeError2, _super);
      function AmbiguousParameterTypeError2() {
        return _super !== null && _super.apply(this, arguments) || this;
      }
      AmbiguousParameterTypeError2.forRegExp = function(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions) {
        return new this("Your Regular Expression ".concat(expressionRegexp, "\nmatches multiple parameter types with regexp ").concat(parameterTypeRegexp, ":\n   ").concat(this._parameterTypeNames(parameterTypes), "\n\nI couldn't decide which one to use. You have two options:\n\n1) Use a Cucumber Expression instead of a Regular Expression. Try one of these:\n   ").concat(this._expressions(generatedExpressions), "\n\n2) Make one of the parameter types preferential and continue to use a Regular Expression.\n"));
      };
      AmbiguousParameterTypeError2._parameterTypeNames = function(parameterTypes) {
        return parameterTypes.map(function(p) {
          return "{".concat(p.name, "}");
        }).join("\n   ");
      };
      AmbiguousParameterTypeError2._expressions = function(generatedExpressions) {
        return generatedExpressions.map(function(e) {
          return e.source;
        }).join("\n   ");
      };
      return AmbiguousParameterTypeError2;
    }(CucumberExpressionError_js_1.default);
    exports2.AmbiguousParameterTypeError = AmbiguousParameterTypeError;
    var UndefinedParameterTypeError = function(_super) {
      __extends(UndefinedParameterTypeError2, _super);
      function UndefinedParameterTypeError2(undefinedParameterTypeName, message2) {
        var _this = _super.call(this, message2) || this;
        _this.undefinedParameterTypeName = undefinedParameterTypeName;
        return _this;
      }
      return UndefinedParameterTypeError2;
    }(CucumberExpressionError_js_1.default);
    exports2.UndefinedParameterTypeError = UndefinedParameterTypeError;
    function createUndefinedParameterType(node, expression, undefinedParameterTypeName) {
      return new UndefinedParameterTypeError(undefinedParameterTypeName, message(node.start, expression, pointAtLocated(node), "Undefined parameter type '".concat(undefinedParameterTypeName, "'"), "Please register a ParameterType for '".concat(undefinedParameterTypeName, "'")));
    }
    exports2.createUndefinedParameterType = createUndefinedParameterType;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionTokenizer.js
var require_CucumberExpressionTokenizer = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionTokenizer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Ast_js_1 = require_Ast();
    var Errors_js_1 = require_Errors2();
    var CucumberExpressionTokenizer = function() {
      function CucumberExpressionTokenizer2() {
      }
      CucumberExpressionTokenizer2.prototype.tokenize = function(expression) {
        var codePoints = Array.from(expression);
        var tokens = [];
        var buffer = [];
        var previousTokenType = Ast_js_1.TokenType.startOfLine;
        var treatAsText = false;
        var escaped = 0;
        var bufferStartIndex = 0;
        function convertBufferToToken(tokenType) {
          var escapeTokens = 0;
          if (tokenType == Ast_js_1.TokenType.text) {
            escapeTokens = escaped;
            escaped = 0;
          }
          var consumedIndex = bufferStartIndex + buffer.length + escapeTokens;
          var t = new Ast_js_1.Token(tokenType, buffer.join(""), bufferStartIndex, consumedIndex);
          buffer = [];
          bufferStartIndex = consumedIndex;
          return t;
        }
        function tokenTypeOf(codePoint, treatAsText2) {
          if (!treatAsText2) {
            return Ast_js_1.Token.typeOf(codePoint);
          }
          if (Ast_js_1.Token.canEscape(codePoint)) {
            return Ast_js_1.TokenType.text;
          }
          throw (0, Errors_js_1.createCantEscaped)(expression, bufferStartIndex + buffer.length + escaped);
        }
        function shouldCreateNewToken(previousTokenType2, currentTokenType) {
          if (currentTokenType != previousTokenType2) {
            return true;
          }
          return currentTokenType != Ast_js_1.TokenType.whiteSpace && currentTokenType != Ast_js_1.TokenType.text;
        }
        if (codePoints.length == 0) {
          tokens.push(new Ast_js_1.Token(Ast_js_1.TokenType.startOfLine, "", 0, 0));
        }
        codePoints.forEach(function(codePoint) {
          if (!treatAsText && Ast_js_1.Token.isEscapeCharacter(codePoint)) {
            escaped++;
            treatAsText = true;
            return;
          }
          var currentTokenType = tokenTypeOf(codePoint, treatAsText);
          treatAsText = false;
          if (shouldCreateNewToken(previousTokenType, currentTokenType)) {
            var token2 = convertBufferToToken(previousTokenType);
            previousTokenType = currentTokenType;
            buffer.push(codePoint);
            tokens.push(token2);
          } else {
            previousTokenType = currentTokenType;
            buffer.push(codePoint);
          }
        });
        if (buffer.length > 0) {
          var token = convertBufferToToken(previousTokenType);
          tokens.push(token);
        }
        if (treatAsText) {
          throw (0, Errors_js_1.createTheEndOfLIneCanNotBeEscaped)(expression);
        }
        tokens.push(new Ast_js_1.Token(Ast_js_1.TokenType.endOfLine, "", codePoints.length, codePoints.length));
        return tokens;
      };
      return CucumberExpressionTokenizer2;
    }();
    exports2.default = CucumberExpressionTokenizer;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionParser.js
var require_CucumberExpressionParser = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionParser.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Ast_js_1 = require_Ast();
    var CucumberExpressionTokenizer_js_1 = __importDefault(require_CucumberExpressionTokenizer());
    var Errors_js_1 = require_Errors2();
    function parseText(expression, tokens, current) {
      var token = tokens[current];
      switch (token.type) {
        case Ast_js_1.TokenType.whiteSpace:
        case Ast_js_1.TokenType.text:
        case Ast_js_1.TokenType.endParameter:
        case Ast_js_1.TokenType.endOptional:
          return {
            consumed: 1,
            ast: [new Ast_js_1.Node(Ast_js_1.NodeType.text, void 0, token.text, token.start, token.end)]
          };
        case Ast_js_1.TokenType.alternation:
          throw (0, Errors_js_1.createAlternationNotAllowedInOptional)(expression, token);
        case Ast_js_1.TokenType.startOfLine:
        case Ast_js_1.TokenType.endOfLine:
        case Ast_js_1.TokenType.beginOptional:
        case Ast_js_1.TokenType.beginParameter:
        default:
          return { consumed: 0, ast: [] };
      }
    }
    function parseName(expression, tokens, current) {
      var token = tokens[current];
      switch (token.type) {
        case Ast_js_1.TokenType.whiteSpace:
        case Ast_js_1.TokenType.text:
          return {
            consumed: 1,
            ast: [new Ast_js_1.Node(Ast_js_1.NodeType.text, void 0, token.text, token.start, token.end)]
          };
        case Ast_js_1.TokenType.beginOptional:
        case Ast_js_1.TokenType.endOptional:
        case Ast_js_1.TokenType.beginParameter:
        case Ast_js_1.TokenType.endParameter:
        case Ast_js_1.TokenType.alternation:
          throw (0, Errors_js_1.createInvalidParameterTypeNameInNode)(token, expression);
        case Ast_js_1.TokenType.startOfLine:
        case Ast_js_1.TokenType.endOfLine:
        default:
          return { consumed: 0, ast: [] };
      }
    }
    var parseParameter = parseBetween(Ast_js_1.NodeType.parameter, Ast_js_1.TokenType.beginParameter, Ast_js_1.TokenType.endParameter, [parseName]);
    var optionalSubParsers = [];
    var parseOptional = parseBetween(Ast_js_1.NodeType.optional, Ast_js_1.TokenType.beginOptional, Ast_js_1.TokenType.endOptional, optionalSubParsers);
    optionalSubParsers.push(parseOptional, parseParameter, parseText);
    function parseAlternativeSeparator(expression, tokens, current) {
      if (!lookingAt(tokens, current, Ast_js_1.TokenType.alternation)) {
        return { consumed: 0, ast: [] };
      }
      var token = tokens[current];
      return {
        consumed: 1,
        ast: [new Ast_js_1.Node(Ast_js_1.NodeType.alternative, void 0, token.text, token.start, token.end)]
      };
    }
    var alternativeParsers = [
      parseAlternativeSeparator,
      parseOptional,
      parseParameter,
      parseText
    ];
    var parseAlternation = function(expression, tokens, current) {
      var previous = current - 1;
      if (!lookingAtAny(tokens, previous, [
        Ast_js_1.TokenType.startOfLine,
        Ast_js_1.TokenType.whiteSpace,
        Ast_js_1.TokenType.endParameter
      ])) {
        return { consumed: 0, ast: [] };
      }
      var result = parseTokensUntil(expression, alternativeParsers, tokens, current, [
        Ast_js_1.TokenType.whiteSpace,
        Ast_js_1.TokenType.endOfLine,
        Ast_js_1.TokenType.beginParameter
      ]);
      var subCurrent = current + result.consumed;
      if (!result.ast.some(function(astNode) {
        return astNode.type == Ast_js_1.NodeType.alternative;
      })) {
        return { consumed: 0, ast: [] };
      }
      var start = tokens[current].start;
      var end = tokens[subCurrent].start;
      return {
        consumed: result.consumed,
        ast: [
          new Ast_js_1.Node(Ast_js_1.NodeType.alternation, splitAlternatives(start, end, result.ast), void 0, start, end)
        ]
      };
    };
    var parseCucumberExpression = parseBetween(Ast_js_1.NodeType.expression, Ast_js_1.TokenType.startOfLine, Ast_js_1.TokenType.endOfLine, [parseAlternation, parseOptional, parseParameter, parseText]);
    var CucumberExpressionParser = function() {
      function CucumberExpressionParser2() {
      }
      CucumberExpressionParser2.prototype.parse = function(expression) {
        var tokenizer = new CucumberExpressionTokenizer_js_1.default();
        var tokens = tokenizer.tokenize(expression);
        var result = parseCucumberExpression(expression, tokens, 0);
        return result.ast[0];
      };
      return CucumberExpressionParser2;
    }();
    exports2.default = CucumberExpressionParser;
    function parseBetween(type, beginToken, endToken, parsers) {
      return function(expression, tokens, current) {
        if (!lookingAt(tokens, current, beginToken)) {
          return { consumed: 0, ast: [] };
        }
        var subCurrent = current + 1;
        var result = parseTokensUntil(expression, parsers, tokens, subCurrent, [
          endToken,
          Ast_js_1.TokenType.endOfLine
        ]);
        subCurrent += result.consumed;
        if (!lookingAt(tokens, subCurrent, endToken)) {
          throw (0, Errors_js_1.createMissingEndToken)(expression, beginToken, endToken, tokens[current]);
        }
        var start = tokens[current].start;
        var end = tokens[subCurrent].end;
        var consumed = subCurrent + 1 - current;
        var ast = [new Ast_js_1.Node(type, result.ast, void 0, start, end)];
        return { consumed, ast };
      };
    }
    function parseToken(expression, parsers, tokens, startAt) {
      for (var i = 0; i < parsers.length; i++) {
        var parse = parsers[i];
        var result = parse(expression, tokens, startAt);
        if (result.consumed != 0) {
          return result;
        }
      }
      throw new Error("No eligible parsers for " + tokens);
    }
    function parseTokensUntil(expression, parsers, tokens, startAt, endTokens) {
      var current = startAt;
      var size = tokens.length;
      var ast = [];
      while (current < size) {
        if (lookingAtAny(tokens, current, endTokens)) {
          break;
        }
        var result = parseToken(expression, parsers, tokens, current);
        if (result.consumed == 0) {
          throw new Error("No eligible parsers for " + tokens);
        }
        current += result.consumed;
        ast.push.apply(ast, __spreadArray([], __read(result.ast), false));
      }
      return { consumed: current - startAt, ast };
    }
    function lookingAtAny(tokens, at, tokenTypes) {
      return tokenTypes.some(function(tokenType) {
        return lookingAt(tokens, at, tokenType);
      });
    }
    function lookingAt(tokens, at, token) {
      if (at < 0) {
        return token == Ast_js_1.TokenType.startOfLine;
      }
      if (at >= tokens.length) {
        return token == Ast_js_1.TokenType.endOfLine;
      }
      return tokens[at].type == token;
    }
    function splitAlternatives(start, end, alternation) {
      var separators = [];
      var alternatives = [];
      var alternative = [];
      alternation.forEach(function(n) {
        if (Ast_js_1.NodeType.alternative == n.type) {
          separators.push(n);
          alternatives.push(alternative);
          alternative = [];
        } else {
          alternative.push(n);
        }
      });
      alternatives.push(alternative);
      return createAlternativeNodes(start, end, separators, alternatives);
    }
    function createAlternativeNodes(start, end, separators, alternatives) {
      var nodes = [];
      for (var i = 0; i < alternatives.length; i++) {
        var n = alternatives[i];
        if (i == 0) {
          var rightSeparator = separators[i];
          nodes.push(new Ast_js_1.Node(Ast_js_1.NodeType.alternative, n, void 0, start, rightSeparator.start));
        } else if (i == alternatives.length - 1) {
          var leftSeparator = separators[i - 1];
          nodes.push(new Ast_js_1.Node(Ast_js_1.NodeType.alternative, n, void 0, leftSeparator.end, end));
        } else {
          var leftSeparator = separators[i - 1];
          var rightSeparator = separators[i];
          nodes.push(new Ast_js_1.Node(Ast_js_1.NodeType.alternative, n, void 0, leftSeparator.end, rightSeparator.start));
        }
      }
      return nodes;
    }
  }
});

// node_modules/regexp-match-indices/config.js
var require_config = __commonJS({
  "node_modules/regexp-match-indices/config.js"(exports2, module2) {
    "use strict";
    var config = {
      mode: "lazy"
    };
    module2.exports = config;
  }
});

// node_modules/regexp-match-indices/native.js
var require_native = __commonJS({
  "node_modules/regexp-match-indices/native.js"(exports2, module2) {
    "use strict";
    var nativeExec = RegExp.prototype.exec;
    module2.exports = nativeExec;
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js
var require_compat_dotall_s_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-dotall-s-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      _hasUFlag: false,
      shouldRun: function shouldRun(ast) {
        var shouldRun2 = ast.flags.includes("s");
        if (!shouldRun2) {
          return false;
        }
        ast.flags = ast.flags.replace("s", "");
        this._hasUFlag = ast.flags.includes("u");
        return true;
      },
      Char: function Char(path) {
        var node = path.node;
        if (node.kind !== "meta" || node.value !== ".") {
          return;
        }
        var toValue = "\\uFFFF";
        var toSymbol = "\uFFFF";
        if (this._hasUFlag) {
          toValue = "\\u{10FFFF}";
          toSymbol = "\u{10FFFF}";
        }
        path.replace({
          type: "CharacterClass",
          expressions: [{
            type: "ClassRange",
            from: {
              type: "Char",
              value: "\\0",
              kind: "decimal",
              symbol: "\0"
            },
            to: {
              type: "Char",
              value: toValue,
              kind: "unicode",
              symbol: toSymbol
            }
          }]
        });
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js
var require_compat_named_capturing_groups_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-named-capturing-groups-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      _groupNames: {},
      init: function init() {
        this._groupNames = {};
      },
      getExtra: function getExtra() {
        return this._groupNames;
      },
      Group: function Group(path) {
        var node = path.node;
        if (!node.name) {
          return;
        }
        this._groupNames[node.name] = node.number;
        delete node.name;
        delete node.nameRaw;
      },
      Backreference: function Backreference(path) {
        var node = path.node;
        if (node.kind !== "name") {
          return;
        }
        node.kind = "number";
        node.reference = node.number;
        delete node.referenceRaw;
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js
var require_compat_x_flag_transform = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/compat-x-flag-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      RegExp: function RegExp2(_ref) {
        var node = _ref.node;
        if (node.flags.includes("x")) {
          node.flags = node.flags.replace("x", "");
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js
var require_transforms = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/transforms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      dotAll: require_compat_dotall_s_transform(),
      namedCapturingGroups: require_compat_named_capturing_groups_transform(),
      xFlag: require_compat_x_flag_transform()
    };
  }
});

// node_modules/regexp-tree/dist/generator/index.js
var require_generator = __commonJS({
  "node_modules/regexp-tree/dist/generator/index.js"(exports2, module2) {
    "use strict";
    function gen(node) {
      return node ? generator[node.type](node) : "";
    }
    var generator = {
      RegExp: function RegExp2(node) {
        return "/" + gen(node.body) + "/" + node.flags;
      },
      Alternative: function Alternative(node) {
        return (node.expressions || []).map(gen).join("");
      },
      Disjunction: function Disjunction(node) {
        return gen(node.left) + "|" + gen(node.right);
      },
      Group: function Group(node) {
        var expression = gen(node.expression);
        if (node.capturing) {
          if (node.name) {
            return "(?<" + (node.nameRaw || node.name) + ">" + expression + ")";
          }
          return "(" + expression + ")";
        }
        return "(?:" + expression + ")";
      },
      Backreference: function Backreference(node) {
        switch (node.kind) {
          case "number":
            return "\\" + node.reference;
          case "name":
            return "\\k<" + (node.referenceRaw || node.reference) + ">";
          default:
            throw new TypeError("Unknown Backreference kind: " + node.kind);
        }
      },
      Assertion: function Assertion(node) {
        switch (node.kind) {
          case "^":
          case "$":
          case "\\b":
          case "\\B":
            return node.kind;
          case "Lookahead": {
            var assertion = gen(node.assertion);
            if (node.negative) {
              return "(?!" + assertion + ")";
            }
            return "(?=" + assertion + ")";
          }
          case "Lookbehind": {
            var _assertion = gen(node.assertion);
            if (node.negative) {
              return "(?<!" + _assertion + ")";
            }
            return "(?<=" + _assertion + ")";
          }
          default:
            throw new TypeError("Unknown Assertion kind: " + node.kind);
        }
      },
      CharacterClass: function CharacterClass(node) {
        var expressions = node.expressions.map(gen).join("");
        if (node.negative) {
          return "[^" + expressions + "]";
        }
        return "[" + expressions + "]";
      },
      ClassRange: function ClassRange(node) {
        return gen(node.from) + "-" + gen(node.to);
      },
      Repetition: function Repetition(node) {
        return "" + gen(node.expression) + gen(node.quantifier);
      },
      Quantifier: function Quantifier(node) {
        var quantifier = void 0;
        var greedy = node.greedy ? "" : "?";
        switch (node.kind) {
          case "+":
          case "?":
          case "*":
            quantifier = node.kind;
            break;
          case "Range":
            if (node.from === node.to) {
              quantifier = "{" + node.from + "}";
            } else if (!node.to) {
              quantifier = "{" + node.from + ",}";
            } else {
              quantifier = "{" + node.from + "," + node.to + "}";
            }
            break;
          default:
            throw new TypeError("Unknown Quantifier kind: " + node.kind);
        }
        return "" + quantifier + greedy;
      },
      Char: function Char(node) {
        var value = node.value;
        switch (node.kind) {
          case "simple": {
            if (node.escaped) {
              return "\\" + value;
            }
            return value;
          }
          case "hex":
          case "unicode":
          case "oct":
          case "decimal":
          case "control":
          case "meta":
            return value;
          default:
            throw new TypeError("Unknown Char kind: " + node.kind);
        }
      },
      UnicodeProperty: function UnicodeProperty(node) {
        var escapeChar = node.negative ? "P" : "p";
        var namePart = void 0;
        if (!node.shorthand && !node.binary) {
          namePart = node.name + "=";
        } else {
          namePart = "";
        }
        return "\\" + escapeChar + "{" + namePart + node.value + "}";
      }
    };
    module2.exports = {
      generate: gen
    };
  }
});

// node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js
var require_parser_unicode_properties = __commonJS({
  "node_modules/regexp-tree/dist/parser/unicode/parser-unicode-properties.js"(exports2, module2) {
    "use strict";
    var NON_BINARY_PROP_NAMES_TO_ALIASES = {
      General_Category: "gc",
      Script: "sc",
      Script_Extensions: "scx"
    };
    var NON_BINARY_ALIASES_TO_PROP_NAMES = inverseMap(NON_BINARY_PROP_NAMES_TO_ALIASES);
    var BINARY_PROP_NAMES_TO_ALIASES = {
      ASCII: "ASCII",
      ASCII_Hex_Digit: "AHex",
      Alphabetic: "Alpha",
      Any: "Any",
      Assigned: "Assigned",
      Bidi_Control: "Bidi_C",
      Bidi_Mirrored: "Bidi_M",
      Case_Ignorable: "CI",
      Cased: "Cased",
      Changes_When_Casefolded: "CWCF",
      Changes_When_Casemapped: "CWCM",
      Changes_When_Lowercased: "CWL",
      Changes_When_NFKC_Casefolded: "CWKCF",
      Changes_When_Titlecased: "CWT",
      Changes_When_Uppercased: "CWU",
      Dash: "Dash",
      Default_Ignorable_Code_Point: "DI",
      Deprecated: "Dep",
      Diacritic: "Dia",
      Emoji: "Emoji",
      Emoji_Component: "Emoji_Component",
      Emoji_Modifier: "Emoji_Modifier",
      Emoji_Modifier_Base: "Emoji_Modifier_Base",
      Emoji_Presentation: "Emoji_Presentation",
      Extended_Pictographic: "Extended_Pictographic",
      Extender: "Ext",
      Grapheme_Base: "Gr_Base",
      Grapheme_Extend: "Gr_Ext",
      Hex_Digit: "Hex",
      IDS_Binary_Operator: "IDSB",
      IDS_Trinary_Operator: "IDST",
      ID_Continue: "IDC",
      ID_Start: "IDS",
      Ideographic: "Ideo",
      Join_Control: "Join_C",
      Logical_Order_Exception: "LOE",
      Lowercase: "Lower",
      Math: "Math",
      Noncharacter_Code_Point: "NChar",
      Pattern_Syntax: "Pat_Syn",
      Pattern_White_Space: "Pat_WS",
      Quotation_Mark: "QMark",
      Radical: "Radical",
      Regional_Indicator: "RI",
      Sentence_Terminal: "STerm",
      Soft_Dotted: "SD",
      Terminal_Punctuation: "Term",
      Unified_Ideograph: "UIdeo",
      Uppercase: "Upper",
      Variation_Selector: "VS",
      White_Space: "space",
      XID_Continue: "XIDC",
      XID_Start: "XIDS"
    };
    var BINARY_ALIASES_TO_PROP_NAMES = inverseMap(BINARY_PROP_NAMES_TO_ALIASES);
    var GENERAL_CATEGORY_VALUE_TO_ALIASES = {
      Cased_Letter: "LC",
      Close_Punctuation: "Pe",
      Connector_Punctuation: "Pc",
      Control: ["Cc", "cntrl"],
      Currency_Symbol: "Sc",
      Dash_Punctuation: "Pd",
      Decimal_Number: ["Nd", "digit"],
      Enclosing_Mark: "Me",
      Final_Punctuation: "Pf",
      Format: "Cf",
      Initial_Punctuation: "Pi",
      Letter: "L",
      Letter_Number: "Nl",
      Line_Separator: "Zl",
      Lowercase_Letter: "Ll",
      Mark: ["M", "Combining_Mark"],
      Math_Symbol: "Sm",
      Modifier_Letter: "Lm",
      Modifier_Symbol: "Sk",
      Nonspacing_Mark: "Mn",
      Number: "N",
      Open_Punctuation: "Ps",
      Other: "C",
      Other_Letter: "Lo",
      Other_Number: "No",
      Other_Punctuation: "Po",
      Other_Symbol: "So",
      Paragraph_Separator: "Zp",
      Private_Use: "Co",
      Punctuation: ["P", "punct"],
      Separator: "Z",
      Space_Separator: "Zs",
      Spacing_Mark: "Mc",
      Surrogate: "Cs",
      Symbol: "S",
      Titlecase_Letter: "Lt",
      Unassigned: "Cn",
      Uppercase_Letter: "Lu"
    };
    var GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES = inverseMap(GENERAL_CATEGORY_VALUE_TO_ALIASES);
    var SCRIPT_VALUE_TO_ALIASES = {
      Adlam: "Adlm",
      Ahom: "Ahom",
      Anatolian_Hieroglyphs: "Hluw",
      Arabic: "Arab",
      Armenian: "Armn",
      Avestan: "Avst",
      Balinese: "Bali",
      Bamum: "Bamu",
      Bassa_Vah: "Bass",
      Batak: "Batk",
      Bengali: "Beng",
      Bhaiksuki: "Bhks",
      Bopomofo: "Bopo",
      Brahmi: "Brah",
      Braille: "Brai",
      Buginese: "Bugi",
      Buhid: "Buhd",
      Canadian_Aboriginal: "Cans",
      Carian: "Cari",
      Caucasian_Albanian: "Aghb",
      Chakma: "Cakm",
      Cham: "Cham",
      Cherokee: "Cher",
      Common: "Zyyy",
      Coptic: ["Copt", "Qaac"],
      Cuneiform: "Xsux",
      Cypriot: "Cprt",
      Cyrillic: "Cyrl",
      Deseret: "Dsrt",
      Devanagari: "Deva",
      Dogra: "Dogr",
      Duployan: "Dupl",
      Egyptian_Hieroglyphs: "Egyp",
      Elbasan: "Elba",
      Ethiopic: "Ethi",
      Georgian: "Geor",
      Glagolitic: "Glag",
      Gothic: "Goth",
      Grantha: "Gran",
      Greek: "Grek",
      Gujarati: "Gujr",
      Gunjala_Gondi: "Gong",
      Gurmukhi: "Guru",
      Han: "Hani",
      Hangul: "Hang",
      Hanifi_Rohingya: "Rohg",
      Hanunoo: "Hano",
      Hatran: "Hatr",
      Hebrew: "Hebr",
      Hiragana: "Hira",
      Imperial_Aramaic: "Armi",
      Inherited: ["Zinh", "Qaai"],
      Inscriptional_Pahlavi: "Phli",
      Inscriptional_Parthian: "Prti",
      Javanese: "Java",
      Kaithi: "Kthi",
      Kannada: "Knda",
      Katakana: "Kana",
      Kayah_Li: "Kali",
      Kharoshthi: "Khar",
      Khmer: "Khmr",
      Khojki: "Khoj",
      Khudawadi: "Sind",
      Lao: "Laoo",
      Latin: "Latn",
      Lepcha: "Lepc",
      Limbu: "Limb",
      Linear_A: "Lina",
      Linear_B: "Linb",
      Lisu: "Lisu",
      Lycian: "Lyci",
      Lydian: "Lydi",
      Mahajani: "Mahj",
      Makasar: "Maka",
      Malayalam: "Mlym",
      Mandaic: "Mand",
      Manichaean: "Mani",
      Marchen: "Marc",
      Medefaidrin: "Medf",
      Masaram_Gondi: "Gonm",
      Meetei_Mayek: "Mtei",
      Mende_Kikakui: "Mend",
      Meroitic_Cursive: "Merc",
      Meroitic_Hieroglyphs: "Mero",
      Miao: "Plrd",
      Modi: "Modi",
      Mongolian: "Mong",
      Mro: "Mroo",
      Multani: "Mult",
      Myanmar: "Mymr",
      Nabataean: "Nbat",
      New_Tai_Lue: "Talu",
      Newa: "Newa",
      Nko: "Nkoo",
      Nushu: "Nshu",
      Ogham: "Ogam",
      Ol_Chiki: "Olck",
      Old_Hungarian: "Hung",
      Old_Italic: "Ital",
      Old_North_Arabian: "Narb",
      Old_Permic: "Perm",
      Old_Persian: "Xpeo",
      Old_Sogdian: "Sogo",
      Old_South_Arabian: "Sarb",
      Old_Turkic: "Orkh",
      Oriya: "Orya",
      Osage: "Osge",
      Osmanya: "Osma",
      Pahawh_Hmong: "Hmng",
      Palmyrene: "Palm",
      Pau_Cin_Hau: "Pauc",
      Phags_Pa: "Phag",
      Phoenician: "Phnx",
      Psalter_Pahlavi: "Phlp",
      Rejang: "Rjng",
      Runic: "Runr",
      Samaritan: "Samr",
      Saurashtra: "Saur",
      Sharada: "Shrd",
      Shavian: "Shaw",
      Siddham: "Sidd",
      SignWriting: "Sgnw",
      Sinhala: "Sinh",
      Sogdian: "Sogd",
      Sora_Sompeng: "Sora",
      Soyombo: "Soyo",
      Sundanese: "Sund",
      Syloti_Nagri: "Sylo",
      Syriac: "Syrc",
      Tagalog: "Tglg",
      Tagbanwa: "Tagb",
      Tai_Le: "Tale",
      Tai_Tham: "Lana",
      Tai_Viet: "Tavt",
      Takri: "Takr",
      Tamil: "Taml",
      Tangut: "Tang",
      Telugu: "Telu",
      Thaana: "Thaa",
      Thai: "Thai",
      Tibetan: "Tibt",
      Tifinagh: "Tfng",
      Tirhuta: "Tirh",
      Ugaritic: "Ugar",
      Vai: "Vaii",
      Warang_Citi: "Wara",
      Yi: "Yiii",
      Zanabazar_Square: "Zanb"
    };
    var SCRIPT_VALUE_ALIASES_TO_VALUE = inverseMap(SCRIPT_VALUE_TO_ALIASES);
    function inverseMap(data) {
      var inverse = {};
      for (var name in data) {
        if (!data.hasOwnProperty(name)) {
          continue;
        }
        var value = data[name];
        if (Array.isArray(value)) {
          for (var i = 0; i < value.length; i++) {
            inverse[value[i]] = name;
          }
        } else {
          inverse[value] = name;
        }
      }
      return inverse;
    }
    function isValidName(name) {
      return NON_BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function isValidValue(name, value) {
      if (isGeneralCategoryName(name)) {
        return isGeneralCategoryValue(value);
      }
      if (isScriptCategoryName(name)) {
        return isScriptCategoryValue(value);
      }
      return false;
    }
    function isAlias(name) {
      return NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function isGeneralCategoryName(name) {
      return name === "General_Category" || name == "gc";
    }
    function isScriptCategoryName(name) {
      return name === "Script" || name === "Script_Extensions" || name === "sc" || name === "scx";
    }
    function isGeneralCategoryValue(value) {
      return GENERAL_CATEGORY_VALUE_TO_ALIASES.hasOwnProperty(value) || GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value);
    }
    function isScriptCategoryValue(value) {
      return SCRIPT_VALUE_TO_ALIASES.hasOwnProperty(value) || SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value);
    }
    function isBinaryPropertyName(name) {
      return BINARY_PROP_NAMES_TO_ALIASES.hasOwnProperty(name) || BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name);
    }
    function getCanonicalName(name) {
      if (NON_BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
        return NON_BINARY_ALIASES_TO_PROP_NAMES[name];
      }
      if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(name)) {
        return BINARY_ALIASES_TO_PROP_NAMES[name];
      }
      return null;
    }
    function getCanonicalValue(value) {
      if (GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES.hasOwnProperty(value)) {
        return GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES[value];
      }
      if (SCRIPT_VALUE_ALIASES_TO_VALUE.hasOwnProperty(value)) {
        return SCRIPT_VALUE_ALIASES_TO_VALUE[value];
      }
      if (BINARY_ALIASES_TO_PROP_NAMES.hasOwnProperty(value)) {
        return BINARY_ALIASES_TO_PROP_NAMES[value];
      }
      return null;
    }
    module2.exports = {
      isAlias,
      isValidName,
      isValidValue,
      isGeneralCategoryValue,
      isScriptCategoryValue,
      isBinaryPropertyName,
      getCanonicalName,
      getCanonicalValue,
      NON_BINARY_PROP_NAMES_TO_ALIASES,
      NON_BINARY_ALIASES_TO_PROP_NAMES,
      BINARY_PROP_NAMES_TO_ALIASES,
      BINARY_ALIASES_TO_PROP_NAMES,
      GENERAL_CATEGORY_VALUE_TO_ALIASES,
      GENERAL_CATEGORY_VALUE_ALIASES_TO_VALUES,
      SCRIPT_VALUE_TO_ALIASES,
      SCRIPT_VALUE_ALIASES_TO_VALUE
    };
  }
});

// node_modules/regexp-tree/dist/parser/generated/regexp-tree.js
var require_regexp_tree = __commonJS({
  "node_modules/regexp-tree/dist/parser/generated/regexp-tree.js"(exports2, module2) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var yytext = void 0;
    var yyleng = void 0;
    var yy = {};
    var __ = void 0;
    var __loc = void 0;
    function yyloc(start, end) {
      if (!yy.options.captureLocations) {
        return null;
      }
      if (!start || !end) {
        return start || end;
      }
      return {
        startOffset: start.startOffset,
        endOffset: end.endOffset,
        startLine: start.startLine,
        endLine: end.endLine,
        startColumn: start.startColumn,
        endColumn: end.endColumn
      };
    }
    var EOF = "$";
    var productions = [[-1, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [0, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      __ = Node({
        type: "RegExp",
        body: _2,
        flags: checkFlags(_4)
      }, loc(_1loc, _4loc || _3loc));
    }], [1, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [1, 0, function() {
      __loc = null;
      __ = "";
    }], [2, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [2, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1 + _2;
    }], [3, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [4, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [4, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      var _loc = null;
      if (_2loc) {
        _loc = loc(_1loc || _2loc, _3loc || _2loc);
      }
      ;
      __ = Node({
        type: "Disjunction",
        left: _1,
        right: _3
      }, _loc);
    }], [5, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      if (_1.length === 0) {
        __ = null;
        return;
      }
      if (_1.length === 1) {
        __ = Node(_1[0], __loc);
      } else {
        __ = Node({
          type: "Alternative",
          expressions: _1
        }, __loc);
      }
    }], [6, 0, function() {
      __loc = null;
      __ = [];
    }], [6, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1.concat(_2);
    }], [7, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node(Object.assign({ type: "Assertion" }, _1), __loc);
    }], [7, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = _1;
      if (_2) {
        __ = Node({
          type: "Repetition",
          expression: _1,
          quantifier: _2
        }, __loc);
      }
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "^" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "$" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "\\b" };
    }], [8, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = { kind: "\\B" };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookahead",
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookahead",
        negative: true,
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookbehind",
        assertion: _2
      };
    }], [8, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = {
        kind: "Lookbehind",
        negative: true,
        assertion: _2
      };
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [9, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "simple", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1.slice(1), "simple", __loc);
      __.escaped = true;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "unicode", __loc);
      __.isSurrogatePair = true;
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "unicode", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = UnicodeProperty(_1, __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "control", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "hex", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "oct", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = GroupRefOrDecChar(_1, __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }], [10, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = NamedGroupRefOrChars(_1, _1loc);
    }], [11, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [11, 0], [12, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [12, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      _1.greedy = false;
      __ = _1;
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node({
        type: "Quantifier",
        kind: _1,
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      var range = getRange(_1);
      __ = Node({
        type: "Quantifier",
        kind: "Range",
        from: range[0],
        to: range[0],
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Node({
        type: "Quantifier",
        kind: "Range",
        from: getRange(_1)[0],
        greedy: true
      }, __loc);
    }], [13, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      var range = getRange(_1);
      __ = Node({
        type: "Quantifier",
        kind: "Range",
        from: range[0],
        to: range[1],
        greedy: true
      }, __loc);
    }], [14, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [14, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      var nameRaw = String(_1);
      var name = decodeUnicodeGroupName(nameRaw);
      if (!yy.options.allowGroupNameDuplicates && namedGroups.hasOwnProperty(name)) {
        throw new SyntaxError('Duplicate of the named group "' + name + '".');
      }
      namedGroups[name] = _1.groupNumber;
      __ = Node({
        type: "Group",
        capturing: true,
        name,
        nameRaw,
        number: _1.groupNumber,
        expression: _2
      }, __loc);
    }], [15, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node({
        type: "Group",
        capturing: true,
        number: _1.groupNumber,
        expression: _2
      }, __loc);
    }], [16, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node({
        type: "Group",
        capturing: false,
        expression: _2
      }, __loc);
    }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node({
        type: "CharacterClass",
        negative: true,
        expressions: _2
      }, __loc);
    }], [17, 3, function(_1, _2, _3, _1loc, _2loc, _3loc) {
      __loc = yyloc(_1loc, _3loc);
      __ = Node({
        type: "CharacterClass",
        expressions: _2
      }, __loc);
    }], [18, 0, function() {
      __loc = null;
      __ = [];
    }], [18, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [19, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = [_1];
    }], [19, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = [_1].concat(_2);
    }], [19, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      checkClassRange(_1, _3);
      __ = [Node({
        type: "ClassRange",
        from: _1,
        to: _3
      }, loc(_1loc, _3loc))];
      if (_4) {
        __ = __.concat(_4);
      }
    }], [20, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [20, 2, function(_1, _2, _1loc, _2loc) {
      __loc = yyloc(_1loc, _2loc);
      __ = [_1].concat(_2);
    }], [20, 4, function(_1, _2, _3, _4, _1loc, _2loc, _3loc, _4loc) {
      __loc = yyloc(_1loc, _4loc);
      checkClassRange(_1, _3);
      __ = [Node({
        type: "ClassRange",
        from: _1,
        to: _3
      }, loc(_1loc, _3loc))];
      if (_4) {
        __ = __.concat(_4);
      }
    }], [21, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "simple", __loc);
    }], [21, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [22, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = _1;
    }], [22, 1, function(_1, _1loc) {
      __loc = yyloc(_1loc, _1loc);
      __ = Char(_1, "meta", __loc);
    }]];
    var tokens = { "SLASH": "23", "CHAR": "24", "BAR": "25", "BOS": "26", "EOS": "27", "ESC_b": "28", "ESC_B": "29", "POS_LA_ASSERT": "30", "R_PAREN": "31", "NEG_LA_ASSERT": "32", "POS_LB_ASSERT": "33", "NEG_LB_ASSERT": "34", "ESC_CHAR": "35", "U_CODE_SURROGATE": "36", "U_CODE": "37", "U_PROP_VALUE_EXP": "38", "CTRL_CH": "39", "HEX_CODE": "40", "OCT_CODE": "41", "DEC_CODE": "42", "META_CHAR": "43", "ANY": "44", "NAMED_GROUP_REF": "45", "Q_MARK": "46", "STAR": "47", "PLUS": "48", "RANGE_EXACT": "49", "RANGE_OPEN": "50", "RANGE_CLOSED": "51", "NAMED_CAPTURE_GROUP": "52", "L_PAREN": "53", "NON_CAPTURE_GROUP": "54", "NEG_CLASS": "55", "R_BRACKET": "56", "L_BRACKET": "57", "DASH": "58", "$": "59" };
    var table = [{ "0": 1, "23": "s2" }, { "59": "acc" }, { "3": 3, "4": 4, "5": 5, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "s7" }, { "23": "r6", "25": "s12" }, { "23": "r7", "25": "r7", "31": "r7" }, { "7": 14, "8": 15, "9": 16, "10": 25, "14": 27, "15": 42, "16": 43, "17": 26, "23": "r9", "24": "s28", "25": "r9", "26": "s17", "27": "s18", "28": "s19", "29": "s20", "30": "s21", "31": "r9", "32": "s22", "33": "s23", "34": "s24", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "52": "s44", "53": "s45", "54": "s46", "55": "s40", "57": "s41" }, { "1": 8, "2": 9, "24": "s10", "59": "r3" }, { "59": "r1" }, { "24": "s11", "59": "r2" }, { "24": "r4", "59": "r4" }, { "24": "r5", "59": "r5" }, { "5": 13, "6": 6, "23": "r10", "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r8", "25": "r8", "31": "r8" }, { "23": "r11", "24": "r11", "25": "r11", "26": "r11", "27": "r11", "28": "r11", "29": "r11", "30": "r11", "31": "r11", "32": "r11", "33": "r11", "34": "r11", "35": "r11", "36": "r11", "37": "r11", "38": "r11", "39": "r11", "40": "r11", "41": "r11", "42": "r11", "43": "r11", "44": "r11", "45": "r11", "52": "r11", "53": "r11", "54": "r11", "55": "r11", "57": "r11" }, { "23": "r12", "24": "r12", "25": "r12", "26": "r12", "27": "r12", "28": "r12", "29": "r12", "30": "r12", "31": "r12", "32": "r12", "33": "r12", "34": "r12", "35": "r12", "36": "r12", "37": "r12", "38": "r12", "39": "r12", "40": "r12", "41": "r12", "42": "r12", "43": "r12", "44": "r12", "45": "r12", "52": "r12", "53": "r12", "54": "r12", "55": "r12", "57": "r12" }, { "11": 47, "12": 48, "13": 49, "23": "r38", "24": "r38", "25": "r38", "26": "r38", "27": "r38", "28": "r38", "29": "r38", "30": "r38", "31": "r38", "32": "r38", "33": "r38", "34": "r38", "35": "r38", "36": "r38", "37": "r38", "38": "r38", "39": "r38", "40": "r38", "41": "r38", "42": "r38", "43": "r38", "44": "r38", "45": "r38", "46": "s52", "47": "s50", "48": "s51", "49": "s53", "50": "s54", "51": "s55", "52": "r38", "53": "r38", "54": "r38", "55": "r38", "57": "r38" }, { "23": "r14", "24": "r14", "25": "r14", "26": "r14", "27": "r14", "28": "r14", "29": "r14", "30": "r14", "31": "r14", "32": "r14", "33": "r14", "34": "r14", "35": "r14", "36": "r14", "37": "r14", "38": "r14", "39": "r14", "40": "r14", "41": "r14", "42": "r14", "43": "r14", "44": "r14", "45": "r14", "52": "r14", "53": "r14", "54": "r14", "55": "r14", "57": "r14" }, { "23": "r15", "24": "r15", "25": "r15", "26": "r15", "27": "r15", "28": "r15", "29": "r15", "30": "r15", "31": "r15", "32": "r15", "33": "r15", "34": "r15", "35": "r15", "36": "r15", "37": "r15", "38": "r15", "39": "r15", "40": "r15", "41": "r15", "42": "r15", "43": "r15", "44": "r15", "45": "r15", "52": "r15", "53": "r15", "54": "r15", "55": "r15", "57": "r15" }, { "23": "r16", "24": "r16", "25": "r16", "26": "r16", "27": "r16", "28": "r16", "29": "r16", "30": "r16", "31": "r16", "32": "r16", "33": "r16", "34": "r16", "35": "r16", "36": "r16", "37": "r16", "38": "r16", "39": "r16", "40": "r16", "41": "r16", "42": "r16", "43": "r16", "44": "r16", "45": "r16", "52": "r16", "53": "r16", "54": "r16", "55": "r16", "57": "r16" }, { "23": "r17", "24": "r17", "25": "r17", "26": "r17", "27": "r17", "28": "r17", "29": "r17", "30": "r17", "31": "r17", "32": "r17", "33": "r17", "34": "r17", "35": "r17", "36": "r17", "37": "r17", "38": "r17", "39": "r17", "40": "r17", "41": "r17", "42": "r17", "43": "r17", "44": "r17", "45": "r17", "52": "r17", "53": "r17", "54": "r17", "55": "r17", "57": "r17" }, { "4": 57, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 59, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 61, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 63, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r22", "24": "r22", "25": "r22", "26": "r22", "27": "r22", "28": "r22", "29": "r22", "30": "r22", "31": "r22", "32": "r22", "33": "r22", "34": "r22", "35": "r22", "36": "r22", "37": "r22", "38": "r22", "39": "r22", "40": "r22", "41": "r22", "42": "r22", "43": "r22", "44": "r22", "45": "r22", "46": "r22", "47": "r22", "48": "r22", "49": "r22", "50": "r22", "51": "r22", "52": "r22", "53": "r22", "54": "r22", "55": "r22", "57": "r22" }, { "23": "r23", "24": "r23", "25": "r23", "26": "r23", "27": "r23", "28": "r23", "29": "r23", "30": "r23", "31": "r23", "32": "r23", "33": "r23", "34": "r23", "35": "r23", "36": "r23", "37": "r23", "38": "r23", "39": "r23", "40": "r23", "41": "r23", "42": "r23", "43": "r23", "44": "r23", "45": "r23", "46": "r23", "47": "r23", "48": "r23", "49": "r23", "50": "r23", "51": "r23", "52": "r23", "53": "r23", "54": "r23", "55": "r23", "57": "r23" }, { "23": "r24", "24": "r24", "25": "r24", "26": "r24", "27": "r24", "28": "r24", "29": "r24", "30": "r24", "31": "r24", "32": "r24", "33": "r24", "34": "r24", "35": "r24", "36": "r24", "37": "r24", "38": "r24", "39": "r24", "40": "r24", "41": "r24", "42": "r24", "43": "r24", "44": "r24", "45": "r24", "46": "r24", "47": "r24", "48": "r24", "49": "r24", "50": "r24", "51": "r24", "52": "r24", "53": "r24", "54": "r24", "55": "r24", "57": "r24" }, { "23": "r25", "24": "r25", "25": "r25", "26": "r25", "27": "r25", "28": "r25", "29": "r25", "30": "r25", "31": "r25", "32": "r25", "33": "r25", "34": "r25", "35": "r25", "36": "r25", "37": "r25", "38": "r25", "39": "r25", "40": "r25", "41": "r25", "42": "r25", "43": "r25", "44": "r25", "45": "r25", "46": "r25", "47": "r25", "48": "r25", "49": "r25", "50": "r25", "51": "r25", "52": "r25", "53": "r25", "54": "r25", "55": "r25", "56": "r25", "57": "r25", "58": "r25" }, { "23": "r26", "24": "r26", "25": "r26", "26": "r26", "27": "r26", "28": "r26", "29": "r26", "30": "r26", "31": "r26", "32": "r26", "33": "r26", "34": "r26", "35": "r26", "36": "r26", "37": "r26", "38": "r26", "39": "r26", "40": "r26", "41": "r26", "42": "r26", "43": "r26", "44": "r26", "45": "r26", "46": "r26", "47": "r26", "48": "r26", "49": "r26", "50": "r26", "51": "r26", "52": "r26", "53": "r26", "54": "r26", "55": "r26", "56": "r26", "57": "r26", "58": "r26" }, { "23": "r27", "24": "r27", "25": "r27", "26": "r27", "27": "r27", "28": "r27", "29": "r27", "30": "r27", "31": "r27", "32": "r27", "33": "r27", "34": "r27", "35": "r27", "36": "r27", "37": "r27", "38": "r27", "39": "r27", "40": "r27", "41": "r27", "42": "r27", "43": "r27", "44": "r27", "45": "r27", "46": "r27", "47": "r27", "48": "r27", "49": "r27", "50": "r27", "51": "r27", "52": "r27", "53": "r27", "54": "r27", "55": "r27", "56": "r27", "57": "r27", "58": "r27" }, { "23": "r28", "24": "r28", "25": "r28", "26": "r28", "27": "r28", "28": "r28", "29": "r28", "30": "r28", "31": "r28", "32": "r28", "33": "r28", "34": "r28", "35": "r28", "36": "r28", "37": "r28", "38": "r28", "39": "r28", "40": "r28", "41": "r28", "42": "r28", "43": "r28", "44": "r28", "45": "r28", "46": "r28", "47": "r28", "48": "r28", "49": "r28", "50": "r28", "51": "r28", "52": "r28", "53": "r28", "54": "r28", "55": "r28", "56": "r28", "57": "r28", "58": "r28" }, { "23": "r29", "24": "r29", "25": "r29", "26": "r29", "27": "r29", "28": "r29", "29": "r29", "30": "r29", "31": "r29", "32": "r29", "33": "r29", "34": "r29", "35": "r29", "36": "r29", "37": "r29", "38": "r29", "39": "r29", "40": "r29", "41": "r29", "42": "r29", "43": "r29", "44": "r29", "45": "r29", "46": "r29", "47": "r29", "48": "r29", "49": "r29", "50": "r29", "51": "r29", "52": "r29", "53": "r29", "54": "r29", "55": "r29", "56": "r29", "57": "r29", "58": "r29" }, { "23": "r30", "24": "r30", "25": "r30", "26": "r30", "27": "r30", "28": "r30", "29": "r30", "30": "r30", "31": "r30", "32": "r30", "33": "r30", "34": "r30", "35": "r30", "36": "r30", "37": "r30", "38": "r30", "39": "r30", "40": "r30", "41": "r30", "42": "r30", "43": "r30", "44": "r30", "45": "r30", "46": "r30", "47": "r30", "48": "r30", "49": "r30", "50": "r30", "51": "r30", "52": "r30", "53": "r30", "54": "r30", "55": "r30", "56": "r30", "57": "r30", "58": "r30" }, { "23": "r31", "24": "r31", "25": "r31", "26": "r31", "27": "r31", "28": "r31", "29": "r31", "30": "r31", "31": "r31", "32": "r31", "33": "r31", "34": "r31", "35": "r31", "36": "r31", "37": "r31", "38": "r31", "39": "r31", "40": "r31", "41": "r31", "42": "r31", "43": "r31", "44": "r31", "45": "r31", "46": "r31", "47": "r31", "48": "r31", "49": "r31", "50": "r31", "51": "r31", "52": "r31", "53": "r31", "54": "r31", "55": "r31", "56": "r31", "57": "r31", "58": "r31" }, { "23": "r32", "24": "r32", "25": "r32", "26": "r32", "27": "r32", "28": "r32", "29": "r32", "30": "r32", "31": "r32", "32": "r32", "33": "r32", "34": "r32", "35": "r32", "36": "r32", "37": "r32", "38": "r32", "39": "r32", "40": "r32", "41": "r32", "42": "r32", "43": "r32", "44": "r32", "45": "r32", "46": "r32", "47": "r32", "48": "r32", "49": "r32", "50": "r32", "51": "r32", "52": "r32", "53": "r32", "54": "r32", "55": "r32", "56": "r32", "57": "r32", "58": "r32" }, { "23": "r33", "24": "r33", "25": "r33", "26": "r33", "27": "r33", "28": "r33", "29": "r33", "30": "r33", "31": "r33", "32": "r33", "33": "r33", "34": "r33", "35": "r33", "36": "r33", "37": "r33", "38": "r33", "39": "r33", "40": "r33", "41": "r33", "42": "r33", "43": "r33", "44": "r33", "45": "r33", "46": "r33", "47": "r33", "48": "r33", "49": "r33", "50": "r33", "51": "r33", "52": "r33", "53": "r33", "54": "r33", "55": "r33", "56": "r33", "57": "r33", "58": "r33" }, { "23": "r34", "24": "r34", "25": "r34", "26": "r34", "27": "r34", "28": "r34", "29": "r34", "30": "r34", "31": "r34", "32": "r34", "33": "r34", "34": "r34", "35": "r34", "36": "r34", "37": "r34", "38": "r34", "39": "r34", "40": "r34", "41": "r34", "42": "r34", "43": "r34", "44": "r34", "45": "r34", "46": "r34", "47": "r34", "48": "r34", "49": "r34", "50": "r34", "51": "r34", "52": "r34", "53": "r34", "54": "r34", "55": "r34", "56": "r34", "57": "r34", "58": "r34" }, { "23": "r35", "24": "r35", "25": "r35", "26": "r35", "27": "r35", "28": "r35", "29": "r35", "30": "r35", "31": "r35", "32": "r35", "33": "r35", "34": "r35", "35": "r35", "36": "r35", "37": "r35", "38": "r35", "39": "r35", "40": "r35", "41": "r35", "42": "r35", "43": "r35", "44": "r35", "45": "r35", "46": "r35", "47": "r35", "48": "r35", "49": "r35", "50": "r35", "51": "r35", "52": "r35", "53": "r35", "54": "r35", "55": "r35", "56": "r35", "57": "r35", "58": "r35" }, { "23": "r36", "24": "r36", "25": "r36", "26": "r36", "27": "r36", "28": "r36", "29": "r36", "30": "r36", "31": "r36", "32": "r36", "33": "r36", "34": "r36", "35": "r36", "36": "r36", "37": "r36", "38": "r36", "39": "r36", "40": "r36", "41": "r36", "42": "r36", "43": "r36", "44": "r36", "45": "r36", "46": "r36", "47": "r36", "48": "r36", "49": "r36", "50": "r36", "51": "r36", "52": "r36", "53": "r36", "54": "r36", "55": "r36", "56": "r36", "57": "r36", "58": "r36" }, { "10": 70, "18": 65, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "10": 70, "18": 83, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "23": "r47", "24": "r47", "25": "r47", "26": "r47", "27": "r47", "28": "r47", "29": "r47", "30": "r47", "31": "r47", "32": "r47", "33": "r47", "34": "r47", "35": "r47", "36": "r47", "37": "r47", "38": "r47", "39": "r47", "40": "r47", "41": "r47", "42": "r47", "43": "r47", "44": "r47", "45": "r47", "46": "r47", "47": "r47", "48": "r47", "49": "r47", "50": "r47", "51": "r47", "52": "r47", "53": "r47", "54": "r47", "55": "r47", "57": "r47" }, { "23": "r48", "24": "r48", "25": "r48", "26": "r48", "27": "r48", "28": "r48", "29": "r48", "30": "r48", "31": "r48", "32": "r48", "33": "r48", "34": "r48", "35": "r48", "36": "r48", "37": "r48", "38": "r48", "39": "r48", "40": "r48", "41": "r48", "42": "r48", "43": "r48", "44": "r48", "45": "r48", "46": "r48", "47": "r48", "48": "r48", "49": "r48", "50": "r48", "51": "r48", "52": "r48", "53": "r48", "54": "r48", "55": "r48", "57": "r48" }, { "4": 85, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 87, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "4": 89, "5": 5, "6": 6, "24": "r10", "25": "r10", "26": "r10", "27": "r10", "28": "r10", "29": "r10", "30": "r10", "31": "r10", "32": "r10", "33": "r10", "34": "r10", "35": "r10", "36": "r10", "37": "r10", "38": "r10", "39": "r10", "40": "r10", "41": "r10", "42": "r10", "43": "r10", "44": "r10", "45": "r10", "52": "r10", "53": "r10", "54": "r10", "55": "r10", "57": "r10" }, { "23": "r13", "24": "r13", "25": "r13", "26": "r13", "27": "r13", "28": "r13", "29": "r13", "30": "r13", "31": "r13", "32": "r13", "33": "r13", "34": "r13", "35": "r13", "36": "r13", "37": "r13", "38": "r13", "39": "r13", "40": "r13", "41": "r13", "42": "r13", "43": "r13", "44": "r13", "45": "r13", "52": "r13", "53": "r13", "54": "r13", "55": "r13", "57": "r13" }, { "23": "r37", "24": "r37", "25": "r37", "26": "r37", "27": "r37", "28": "r37", "29": "r37", "30": "r37", "31": "r37", "32": "r37", "33": "r37", "34": "r37", "35": "r37", "36": "r37", "37": "r37", "38": "r37", "39": "r37", "40": "r37", "41": "r37", "42": "r37", "43": "r37", "44": "r37", "45": "r37", "52": "r37", "53": "r37", "54": "r37", "55": "r37", "57": "r37" }, { "23": "r39", "24": "r39", "25": "r39", "26": "r39", "27": "r39", "28": "r39", "29": "r39", "30": "r39", "31": "r39", "32": "r39", "33": "r39", "34": "r39", "35": "r39", "36": "r39", "37": "r39", "38": "r39", "39": "r39", "40": "r39", "41": "r39", "42": "r39", "43": "r39", "44": "r39", "45": "r39", "46": "s56", "52": "r39", "53": "r39", "54": "r39", "55": "r39", "57": "r39" }, { "23": "r41", "24": "r41", "25": "r41", "26": "r41", "27": "r41", "28": "r41", "29": "r41", "30": "r41", "31": "r41", "32": "r41", "33": "r41", "34": "r41", "35": "r41", "36": "r41", "37": "r41", "38": "r41", "39": "r41", "40": "r41", "41": "r41", "42": "r41", "43": "r41", "44": "r41", "45": "r41", "46": "r41", "52": "r41", "53": "r41", "54": "r41", "55": "r41", "57": "r41" }, { "23": "r42", "24": "r42", "25": "r42", "26": "r42", "27": "r42", "28": "r42", "29": "r42", "30": "r42", "31": "r42", "32": "r42", "33": "r42", "34": "r42", "35": "r42", "36": "r42", "37": "r42", "38": "r42", "39": "r42", "40": "r42", "41": "r42", "42": "r42", "43": "r42", "44": "r42", "45": "r42", "46": "r42", "52": "r42", "53": "r42", "54": "r42", "55": "r42", "57": "r42" }, { "23": "r43", "24": "r43", "25": "r43", "26": "r43", "27": "r43", "28": "r43", "29": "r43", "30": "r43", "31": "r43", "32": "r43", "33": "r43", "34": "r43", "35": "r43", "36": "r43", "37": "r43", "38": "r43", "39": "r43", "40": "r43", "41": "r43", "42": "r43", "43": "r43", "44": "r43", "45": "r43", "46": "r43", "52": "r43", "53": "r43", "54": "r43", "55": "r43", "57": "r43" }, { "23": "r44", "24": "r44", "25": "r44", "26": "r44", "27": "r44", "28": "r44", "29": "r44", "30": "r44", "31": "r44", "32": "r44", "33": "r44", "34": "r44", "35": "r44", "36": "r44", "37": "r44", "38": "r44", "39": "r44", "40": "r44", "41": "r44", "42": "r44", "43": "r44", "44": "r44", "45": "r44", "46": "r44", "52": "r44", "53": "r44", "54": "r44", "55": "r44", "57": "r44" }, { "23": "r45", "24": "r45", "25": "r45", "26": "r45", "27": "r45", "28": "r45", "29": "r45", "30": "r45", "31": "r45", "32": "r45", "33": "r45", "34": "r45", "35": "r45", "36": "r45", "37": "r45", "38": "r45", "39": "r45", "40": "r45", "41": "r45", "42": "r45", "43": "r45", "44": "r45", "45": "r45", "46": "r45", "52": "r45", "53": "r45", "54": "r45", "55": "r45", "57": "r45" }, { "23": "r46", "24": "r46", "25": "r46", "26": "r46", "27": "r46", "28": "r46", "29": "r46", "30": "r46", "31": "r46", "32": "r46", "33": "r46", "34": "r46", "35": "r46", "36": "r46", "37": "r46", "38": "r46", "39": "r46", "40": "r46", "41": "r46", "42": "r46", "43": "r46", "44": "r46", "45": "r46", "46": "r46", "52": "r46", "53": "r46", "54": "r46", "55": "r46", "57": "r46" }, { "23": "r40", "24": "r40", "25": "r40", "26": "r40", "27": "r40", "28": "r40", "29": "r40", "30": "r40", "31": "r40", "32": "r40", "33": "r40", "34": "r40", "35": "r40", "36": "r40", "37": "r40", "38": "r40", "39": "r40", "40": "r40", "41": "r40", "42": "r40", "43": "r40", "44": "r40", "45": "r40", "52": "r40", "53": "r40", "54": "r40", "55": "r40", "57": "r40" }, { "25": "s12", "31": "s58" }, { "23": "r18", "24": "r18", "25": "r18", "26": "r18", "27": "r18", "28": "r18", "29": "r18", "30": "r18", "31": "r18", "32": "r18", "33": "r18", "34": "r18", "35": "r18", "36": "r18", "37": "r18", "38": "r18", "39": "r18", "40": "r18", "41": "r18", "42": "r18", "43": "r18", "44": "r18", "45": "r18", "52": "r18", "53": "r18", "54": "r18", "55": "r18", "57": "r18" }, { "25": "s12", "31": "s60" }, { "23": "r19", "24": "r19", "25": "r19", "26": "r19", "27": "r19", "28": "r19", "29": "r19", "30": "r19", "31": "r19", "32": "r19", "33": "r19", "34": "r19", "35": "r19", "36": "r19", "37": "r19", "38": "r19", "39": "r19", "40": "r19", "41": "r19", "42": "r19", "43": "r19", "44": "r19", "45": "r19", "52": "r19", "53": "r19", "54": "r19", "55": "r19", "57": "r19" }, { "25": "s12", "31": "s62" }, { "23": "r20", "24": "r20", "25": "r20", "26": "r20", "27": "r20", "28": "r20", "29": "r20", "30": "r20", "31": "r20", "32": "r20", "33": "r20", "34": "r20", "35": "r20", "36": "r20", "37": "r20", "38": "r20", "39": "r20", "40": "r20", "41": "r20", "42": "r20", "43": "r20", "44": "r20", "45": "r20", "52": "r20", "53": "r20", "54": "r20", "55": "r20", "57": "r20" }, { "25": "s12", "31": "s64" }, { "23": "r21", "24": "r21", "25": "r21", "26": "r21", "27": "r21", "28": "r21", "29": "r21", "30": "r21", "31": "r21", "32": "r21", "33": "r21", "34": "r21", "35": "r21", "36": "r21", "37": "r21", "38": "r21", "39": "r21", "40": "r21", "41": "r21", "42": "r21", "43": "r21", "44": "r21", "45": "r21", "52": "r21", "53": "r21", "54": "r21", "55": "r21", "57": "r21" }, { "56": "s72" }, { "56": "r55" }, { "10": 70, "20": 73, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r56", "58": "s74" }, { "24": "r62", "28": "r62", "35": "r62", "36": "r62", "37": "r62", "38": "r62", "39": "r62", "40": "r62", "41": "r62", "42": "r62", "43": "r62", "44": "r62", "45": "r62", "56": "r62", "58": "r62" }, { "24": "r63", "28": "r63", "35": "r63", "36": "r63", "37": "r63", "38": "r63", "39": "r63", "40": "r63", "41": "r63", "42": "r63", "43": "r63", "44": "r63", "45": "r63", "56": "r63", "58": "r63" }, { "24": "r64", "28": "r64", "35": "r64", "36": "r64", "37": "r64", "38": "r64", "39": "r64", "40": "r64", "41": "r64", "42": "r64", "43": "r64", "44": "r64", "45": "r64", "56": "r64", "58": "r64" }, { "24": "r65", "28": "r65", "35": "r65", "36": "r65", "37": "r65", "38": "r65", "39": "r65", "40": "r65", "41": "r65", "42": "r65", "43": "r65", "44": "r65", "45": "r65", "56": "r65", "58": "r65" }, { "23": "r52", "24": "r52", "25": "r52", "26": "r52", "27": "r52", "28": "r52", "29": "r52", "30": "r52", "31": "r52", "32": "r52", "33": "r52", "34": "r52", "35": "r52", "36": "r52", "37": "r52", "38": "r52", "39": "r52", "40": "r52", "41": "r52", "42": "r52", "43": "r52", "44": "r52", "45": "r52", "46": "r52", "47": "r52", "48": "r52", "49": "r52", "50": "r52", "51": "r52", "52": "r52", "53": "r52", "54": "r52", "55": "r52", "57": "r52" }, { "56": "r57" }, { "10": 70, "21": 77, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "56": "r59" }, { "10": 70, "20": 79, "21": 75, "22": 76, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r63", "58": "s80" }, { "10": 70, "18": 78, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r58" }, { "56": "r60" }, { "10": 70, "21": 81, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r62", "58": "s68" }, { "10": 70, "18": 82, "19": 66, "21": 67, "22": 69, "24": "s28", "28": "s71", "35": "s29", "36": "s30", "37": "s31", "38": "s32", "39": "s33", "40": "s34", "41": "s35", "42": "s36", "43": "s37", "44": "s38", "45": "s39", "56": "r54", "58": "s68" }, { "56": "r61" }, { "56": "s84" }, { "23": "r53", "24": "r53", "25": "r53", "26": "r53", "27": "r53", "28": "r53", "29": "r53", "30": "r53", "31": "r53", "32": "r53", "33": "r53", "34": "r53", "35": "r53", "36": "r53", "37": "r53", "38": "r53", "39": "r53", "40": "r53", "41": "r53", "42": "r53", "43": "r53", "44": "r53", "45": "r53", "46": "r53", "47": "r53", "48": "r53", "49": "r53", "50": "r53", "51": "r53", "52": "r53", "53": "r53", "54": "r53", "55": "r53", "57": "r53" }, { "25": "s12", "31": "s86" }, { "23": "r49", "24": "r49", "25": "r49", "26": "r49", "27": "r49", "28": "r49", "29": "r49", "30": "r49", "31": "r49", "32": "r49", "33": "r49", "34": "r49", "35": "r49", "36": "r49", "37": "r49", "38": "r49", "39": "r49", "40": "r49", "41": "r49", "42": "r49", "43": "r49", "44": "r49", "45": "r49", "46": "r49", "47": "r49", "48": "r49", "49": "r49", "50": "r49", "51": "r49", "52": "r49", "53": "r49", "54": "r49", "55": "r49", "57": "r49" }, { "25": "s12", "31": "s88" }, { "23": "r50", "24": "r50", "25": "r50", "26": "r50", "27": "r50", "28": "r50", "29": "r50", "30": "r50", "31": "r50", "32": "r50", "33": "r50", "34": "r50", "35": "r50", "36": "r50", "37": "r50", "38": "r50", "39": "r50", "40": "r50", "41": "r50", "42": "r50", "43": "r50", "44": "r50", "45": "r50", "46": "r50", "47": "r50", "48": "r50", "49": "r50", "50": "r50", "51": "r50", "52": "r50", "53": "r50", "54": "r50", "55": "r50", "57": "r50" }, { "25": "s12", "31": "s90" }, { "23": "r51", "24": "r51", "25": "r51", "26": "r51", "27": "r51", "28": "r51", "29": "r51", "30": "r51", "31": "r51", "32": "r51", "33": "r51", "34": "r51", "35": "r51", "36": "r51", "37": "r51", "38": "r51", "39": "r51", "40": "r51", "41": "r51", "42": "r51", "43": "r51", "44": "r51", "45": "r51", "46": "r51", "47": "r51", "48": "r51", "49": "r51", "50": "r51", "51": "r51", "52": "r51", "53": "r51", "54": "r51", "55": "r51", "57": "r51" }];
    var stack = [];
    var tokenizer = void 0;
    var lexRules = [[/^#[^\n]+/, function() {
    }], [/^\s+/, function() {
    }], [/^-/, function() {
      return "DASH";
    }], [/^\//, function() {
      return "CHAR";
    }], [/^#/, function() {
      return "CHAR";
    }], [/^\|/, function() {
      return "CHAR";
    }], [/^\./, function() {
      return "CHAR";
    }], [/^\{/, function() {
      return "CHAR";
    }], [/^\{\d+\}/, function() {
      return "RANGE_EXACT";
    }], [/^\{\d+,\}/, function() {
      return "RANGE_OPEN";
    }], [/^\{\d+,\d+\}/, function() {
      return "RANGE_CLOSED";
    }], [/^\\k<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
      var groupName = yytext.slice(3, -1);
      validateUnicodeGroupName(groupName, this.getCurrentState());
      return "NAMED_GROUP_REF";
    }], [/^\\b/, function() {
      return "ESC_b";
    }], [/^\\B/, function() {
      return "ESC_B";
    }], [/^\\c[a-zA-Z]/, function() {
      return "CTRL_CH";
    }], [/^\\0\d{1,2}/, function() {
      return "OCT_CODE";
    }], [/^\\0/, function() {
      return "DEC_CODE";
    }], [/^\\\d{1,3}/, function() {
      return "DEC_CODE";
    }], [/^\\u[dD][89abAB][0-9a-fA-F]{2}\\u[dD][c-fC-F][0-9a-fA-F]{2}/, function() {
      return "U_CODE_SURROGATE";
    }], [/^\\u\{[0-9a-fA-F]{1,}\}/, function() {
      return "U_CODE";
    }], [/^\\u[0-9a-fA-F]{4}/, function() {
      return "U_CODE";
    }], [/^\\[pP]\{\w+(?:=\w+)?\}/, function() {
      return "U_PROP_VALUE_EXP";
    }], [/^\\x[0-9a-fA-F]{2}/, function() {
      return "HEX_CODE";
    }], [/^\\[tnrdDsSwWvf]/, function() {
      return "META_CHAR";
    }], [/^\\\//, function() {
      return "ESC_CHAR";
    }], [/^\\[ #]/, function() {
      return "ESC_CHAR";
    }], [/^\\[\^\$\.\*\+\?\(\)\\\[\]\{\}\|\/]/, function() {
      return "ESC_CHAR";
    }], [/^\\[^*?+\[()\\|]/, function() {
      var s = this.getCurrentState();
      if (s === "u_class" && yytext === "\\-") {
        return "ESC_CHAR";
      } else if (s === "u" || s === "xu" || s === "u_class") {
        throw new SyntaxError("invalid Unicode escape " + yytext);
      }
      return "ESC_CHAR";
    }], [/^\(/, function() {
      return "CHAR";
    }], [/^\)/, function() {
      return "CHAR";
    }], [/^\(\?=/, function() {
      return "POS_LA_ASSERT";
    }], [/^\(\?!/, function() {
      return "NEG_LA_ASSERT";
    }], [/^\(\?<=/, function() {
      return "POS_LB_ASSERT";
    }], [/^\(\?<!/, function() {
      return "NEG_LB_ASSERT";
    }], [/^\(\?:/, function() {
      return "NON_CAPTURE_GROUP";
    }], [/^\(\?<(([\u0041-\u005a\u0061-\u007a\u00aa\u00b5\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u05d0-\u05ea\u05ef-\u05f2\u0620-\u064a\u066e-\u066f\u0671-\u06d3\u06d5\u06e5-\u06e6\u06ee-\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4-\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc-\u09dd\u09df-\u09e1\u09f0-\u09f1\u09fc\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0-\u0ae1\u0af9\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3d\u0b5c-\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d\u0c58-\u0c5a\u0c60-\u0c61\u0c80\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0-\u0ce1\u0cf1-\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d54-\u0d56\u0d5f-\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32-\u0e33\u0e40-\u0e46\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0eb0\u0eb2-\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065-\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1878\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191e\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae-\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1ce9-\u1cec\u1cee-\u1cf3\u1cf5-\u1cf6\u1cfa\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309b-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a-\ua62b\ua640-\ua66e\ua67f-\ua69d\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua8fd-\ua8fe\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\ua9e0-\ua9e4\ua9e6-\ua9ef\ua9fa-\ua9fe\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa7e-\uaaaf\uaab1\uaab5-\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\ude80-\ude9c\udea0-\uded0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf75\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00\ude10-\ude13\ude15-\ude17\ude19-\ude35\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee4\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd23\udf00-\udf1c\udf27\udf30-\udf45\udfe0-\udff6]|\ud804[\udc03-\udc37\udc83-\udcaf\udcd0-\udce8\udd03-\udd26\udd44\udd50-\udd72\udd76\udd83-\uddb2\uddc1-\uddc4\uddda\udddc\ude00-\ude11\ude13-\ude2b\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udede\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3d\udf50\udf5d-\udf61]|\ud805[\udc00-\udc34\udc47-\udc4a\udc5f\udc80-\udcaf\udcc4-\udcc5\udcc7\udd80-\uddae\uddd8-\udddb\ude00-\ude2f\ude44\ude80-\udeaa\udeb8\udf00-\udf1a]|\ud806[\udc00-\udc2b\udca0-\udcdf\udcff\udda0-\udda7\uddaa-\uddd0\udde1\udde3\ude00\ude0b-\ude32\ude3a\ude50\ude5c-\ude89\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc2e\udc40\udc72-\udc8f\udd00-\udd06\udd08-\udd09\udd0b-\udd30\udd46\udd60-\udd65\udd67-\udd68\udd6a-\udd89\udd98\udee0-\udef2]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\uded0-\udeed\udf00-\udf2f\udf40-\udf43\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf50\udf93-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb]|\ud838[\udd00-\udd2c\udd37-\udd3d\udd4e\udec0-\udeeb]|\ud83a[\udc00-\udcc4\udd00-\udd43\udd4b]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\}))(([\u0030-\u0039\u0041-\u005a\u005f\u0061-\u007a\u00aa\u00b5\u00b7\u00ba\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0300-\u0374\u0376-\u0377\u037a-\u037d\u037f\u0386-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u0483-\u0487\u048a-\u052f\u0531-\u0556\u0559\u0560-\u0588\u0591-\u05bd\u05bf\u05c1-\u05c2\u05c4-\u05c5\u05c7\u05d0-\u05ea\u05ef-\u05f2\u0610-\u061a\u0620-\u0669\u066e-\u06d3\u06d5-\u06dc\u06df-\u06e8\u06ea-\u06fc\u06ff\u0710-\u074a\u074d-\u07b1\u07c0-\u07f5\u07fa\u07fd\u0800-\u082d\u0840-\u085b\u0860-\u086a\u08a0-\u08b4\u08b6-\u08bd\u08d3-\u08e1\u08e3-\u0963\u0966-\u096f\u0971-\u0983\u0985-\u098c\u098f-\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bc-\u09c4\u09c7-\u09c8\u09cb-\u09ce\u09d7\u09dc-\u09dd\u09df-\u09e3\u09e6-\u09f1\u09fc\u09fe\u0a01-\u0a03\u0a05-\u0a0a\u0a0f-\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32-\u0a33\u0a35-\u0a36\u0a38-\u0a39\u0a3c\u0a3e-\u0a42\u0a47-\u0a48\u0a4b-\u0a4d\u0a51\u0a59-\u0a5c\u0a5e\u0a66-\u0a75\u0a81-\u0a83\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2-\u0ab3\u0ab5-\u0ab9\u0abc-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ad0\u0ae0-\u0ae3\u0ae6-\u0aef\u0af9-\u0aff\u0b01-\u0b03\u0b05-\u0b0c\u0b0f-\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32-\u0b33\u0b35-\u0b39\u0b3c-\u0b44\u0b47-\u0b48\u0b4b-\u0b4d\u0b56-\u0b57\u0b5c-\u0b5d\u0b5f-\u0b63\u0b66-\u0b6f\u0b71\u0b82-\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99-\u0b9a\u0b9c\u0b9e-\u0b9f\u0ba3-\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd0\u0bd7\u0be6-\u0bef\u0c00-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c39\u0c3d-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55-\u0c56\u0c58-\u0c5a\u0c60-\u0c63\u0c66-\u0c6f\u0c80-\u0c83\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbc-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5-\u0cd6\u0cde\u0ce0-\u0ce3\u0ce6-\u0cef\u0cf1-\u0cf2\u0d00-\u0d03\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d44\u0d46-\u0d48\u0d4a-\u0d4e\u0d54-\u0d57\u0d5f-\u0d63\u0d66-\u0d6f\u0d7a-\u0d7f\u0d82-\u0d83\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0de6-\u0def\u0df2-\u0df3\u0e01-\u0e3a\u0e40-\u0e4e\u0e50-\u0e59\u0e81-\u0e82\u0e84\u0e86-\u0e8a\u0e8c-\u0ea3\u0ea5\u0ea7-\u0ebd\u0ec0-\u0ec4\u0ec6\u0ec8-\u0ecd\u0ed0-\u0ed9\u0edc-\u0edf\u0f00\u0f18-\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f3e-\u0f47\u0f49-\u0f6c\u0f71-\u0f84\u0f86-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1049\u1050-\u109d\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u135d-\u135f\u1369-\u1371\u1380-\u138f\u13a0-\u13f5\u13f8-\u13fd\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f8\u1700-\u170c\u170e-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176c\u176e-\u1770\u1772-\u1773\u1780-\u17d3\u17d7\u17dc-\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1820-\u1878\u1880-\u18aa\u18b0-\u18f5\u1900-\u191e\u1920-\u192b\u1930-\u193b\u1946-\u196d\u1970-\u1974\u1980-\u19ab\u19b0-\u19c9\u19d0-\u19da\u1a00-\u1a1b\u1a20-\u1a5e\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1aa7\u1ab0-\u1abd\u1b00-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1b80-\u1bf3\u1c00-\u1c37\u1c40-\u1c49\u1c4d-\u1c7d\u1c80-\u1c88\u1c90-\u1cba\u1cbd-\u1cbf\u1cd0-\u1cd2\u1cd4-\u1cfa\u1d00-\u1df9\u1dfb-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u203f-\u2040\u2054\u2071\u207f\u2090-\u209c\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2102\u2107\u210a-\u2113\u2115\u2118-\u211d\u2124\u2126\u2128\u212a-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d7f-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2de0-\u2dff\u3005-\u3007\u3021-\u302f\u3031-\u3035\u3038-\u303c\u3041-\u3096\u3099-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312f\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fef\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua62b\ua640-\ua66f\ua674-\ua67d\ua67f-\ua6f1\ua717-\ua71f\ua722-\ua788\ua78b-\ua7bf\ua7c2-\ua7c6\ua7f7-\ua827\ua840-\ua873\ua880-\ua8c5\ua8d0-\ua8d9\ua8e0-\ua8f7\ua8fb\ua8fd-\ua92d\ua930-\ua953\ua960-\ua97c\ua980-\ua9c0\ua9cf-\ua9d9\ua9e0-\ua9fe\uaa00-\uaa36\uaa40-\uaa4d\uaa50-\uaa59\uaa60-\uaa76\uaa7a-\uaac2\uaadb-\uaadd\uaae0-\uaaef\uaaf2-\uaaf6\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uab30-\uab5a\uab5c-\uab67\uab70-\uabea\uabec-\uabed\uabf0-\uabf9\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe00-\ufe0f\ufe20-\ufe2f\ufe33-\ufe34\ufe4d-\ufe4f\ufe70-\ufe74\ufe76-\ufefc\uff10-\uff19\uff21-\uff3a\uff3f\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc]|\ud800[\udc00-\udc0b\udc0d-\udc26\udc28-\udc3a\udc3c-\udc3d\udc3f-\udc4d\udc50-\udc5d\udc80-\udcfa\udd40-\udd74\uddfd\ude80-\ude9c\udea0-\uded0\udee0\udf00-\udf1f\udf2d-\udf4a\udf50-\udf7a\udf80-\udf9d\udfa0-\udfc3\udfc8-\udfcf\udfd1-\udfd5]|\ud801[\udc00-\udc9d\udca0-\udca9\udcb0-\udcd3\udcd8-\udcfb\udd00-\udd27\udd30-\udd63\ude00-\udf36\udf40-\udf55\udf60-\udf67]|\ud802[\udc00-\udc05\udc08\udc0a-\udc35\udc37-\udc38\udc3c\udc3f-\udc55\udc60-\udc76\udc80-\udc9e\udce0-\udcf2\udcf4-\udcf5\udd00-\udd15\udd20-\udd39\udd80-\uddb7\uddbe-\uddbf\ude00-\ude03\ude05-\ude06\ude0c-\ude13\ude15-\ude17\ude19-\ude35\ude38-\ude3a\ude3f\ude60-\ude7c\ude80-\ude9c\udec0-\udec7\udec9-\udee6\udf00-\udf35\udf40-\udf55\udf60-\udf72\udf80-\udf91]|\ud803[\udc00-\udc48\udc80-\udcb2\udcc0-\udcf2\udd00-\udd27\udd30-\udd39\udf00-\udf1c\udf27\udf30-\udf50\udfe0-\udff6]|\ud804[\udc00-\udc46\udc66-\udc6f\udc7f-\udcba\udcd0-\udce8\udcf0-\udcf9\udd00-\udd34\udd36-\udd3f\udd44-\udd46\udd50-\udd73\udd76\udd80-\uddc4\uddc9-\uddcc\uddd0-\uddda\udddc\ude00-\ude11\ude13-\ude37\ude3e\ude80-\ude86\ude88\ude8a-\ude8d\ude8f-\ude9d\ude9f-\udea8\udeb0-\udeea\udef0-\udef9\udf00-\udf03\udf05-\udf0c\udf0f-\udf10\udf13-\udf28\udf2a-\udf30\udf32-\udf33\udf35-\udf39\udf3b-\udf44\udf47-\udf48\udf4b-\udf4d\udf50\udf57\udf5d-\udf63\udf66-\udf6c\udf70-\udf74]|\ud805[\udc00-\udc4a\udc50-\udc59\udc5e-\udc5f\udc80-\udcc5\udcc7\udcd0-\udcd9\udd80-\uddb5\uddb8-\uddc0\uddd8-\udddd\ude00-\ude40\ude44\ude50-\ude59\ude80-\udeb8\udec0-\udec9\udf00-\udf1a\udf1d-\udf2b\udf30-\udf39]|\ud806[\udc00-\udc3a\udca0-\udce9\udcff\udda0-\udda7\uddaa-\uddd7\uddda-\udde1\udde3-\udde4\ude00-\ude3e\ude47\ude50-\ude99\ude9d\udec0-\udef8]|\ud807[\udc00-\udc08\udc0a-\udc36\udc38-\udc40\udc50-\udc59\udc72-\udc8f\udc92-\udca7\udca9-\udcb6\udd00-\udd06\udd08-\udd09\udd0b-\udd36\udd3a\udd3c-\udd3d\udd3f-\udd47\udd50-\udd59\udd60-\udd65\udd67-\udd68\udd6a-\udd8e\udd90-\udd91\udd93-\udd98\udda0-\udda9\udee0-\udef6]|\ud808[\udc00-\udf99]|\ud809[\udc00-\udc6e\udc80-\udd43]|\ud80c[\udc00-\udfff]|\ud80d[\udc00-\udc2e]|\ud811[\udc00-\ude46]|\ud81a[\udc00-\ude38\ude40-\ude5e\ude60-\ude69\uded0-\udeed\udef0-\udef4\udf00-\udf36\udf40-\udf43\udf50-\udf59\udf63-\udf77\udf7d-\udf8f]|\ud81b[\ude40-\ude7f\udf00-\udf4a\udf4f-\udf87\udf8f-\udf9f\udfe0-\udfe1\udfe3]|\ud81c[\udc00-\udfff]|\ud81d[\udc00-\udfff]|\ud81e[\udc00-\udfff]|\ud81f[\udc00-\udfff]|\ud820[\udc00-\udfff]|\ud821[\udc00-\udff7]|\ud822[\udc00-\udef2]|\ud82c[\udc00-\udd1e\udd50-\udd52\udd64-\udd67\udd70-\udefb]|\ud82f[\udc00-\udc6a\udc70-\udc7c\udc80-\udc88\udc90-\udc99\udc9d-\udc9e]|\ud834[\udd65-\udd69\udd6d-\udd72\udd7b-\udd82\udd85-\udd8b\uddaa-\uddad\ude42-\ude44]|\ud835[\udc00-\udc54\udc56-\udc9c\udc9e-\udc9f\udca2\udca5-\udca6\udca9-\udcac\udcae-\udcb9\udcbb\udcbd-\udcc3\udcc5-\udd05\udd07-\udd0a\udd0d-\udd14\udd16-\udd1c\udd1e-\udd39\udd3b-\udd3e\udd40-\udd44\udd46\udd4a-\udd50\udd52-\udea5\udea8-\udec0\udec2-\udeda\udedc-\udefa\udefc-\udf14\udf16-\udf34\udf36-\udf4e\udf50-\udf6e\udf70-\udf88\udf8a-\udfa8\udfaa-\udfc2\udfc4-\udfcb\udfce-\udfff]|\ud836[\ude00-\ude36\ude3b-\ude6c\ude75\ude84\ude9b-\ude9f\udea1-\udeaf]|\ud838[\udc00-\udc06\udc08-\udc18\udc1b-\udc21\udc23-\udc24\udc26-\udc2a\udd00-\udd2c\udd30-\udd3d\udd40-\udd49\udd4e\udec0-\udef9]|\ud83a[\udc00-\udcc4\udcd0-\udcd6\udd00-\udd4b\udd50-\udd59]|\ud83b[\ude00-\ude03\ude05-\ude1f\ude21-\ude22\ude24\ude27\ude29-\ude32\ude34-\ude37\ude39\ude3b\ude42\ude47\ude49\ude4b\ude4d-\ude4f\ude51-\ude52\ude54\ude57\ude59\ude5b\ude5d\ude5f\ude61-\ude62\ude64\ude67-\ude6a\ude6c-\ude72\ude74-\ude77\ude79-\ude7c\ude7e\ude80-\ude89\ude8b-\ude9b\udea1-\udea3\udea5-\udea9\udeab-\udebb]|\ud840[\udc00-\udfff]|\ud841[\udc00-\udfff]|\ud842[\udc00-\udfff]|\ud843[\udc00-\udfff]|\ud844[\udc00-\udfff]|\ud845[\udc00-\udfff]|\ud846[\udc00-\udfff]|\ud847[\udc00-\udfff]|\ud848[\udc00-\udfff]|\ud849[\udc00-\udfff]|\ud84a[\udc00-\udfff]|\ud84b[\udc00-\udfff]|\ud84c[\udc00-\udfff]|\ud84d[\udc00-\udfff]|\ud84e[\udc00-\udfff]|\ud84f[\udc00-\udfff]|\ud850[\udc00-\udfff]|\ud851[\udc00-\udfff]|\ud852[\udc00-\udfff]|\ud853[\udc00-\udfff]|\ud854[\udc00-\udfff]|\ud855[\udc00-\udfff]|\ud856[\udc00-\udfff]|\ud857[\udc00-\udfff]|\ud858[\udc00-\udfff]|\ud859[\udc00-\udfff]|\ud85a[\udc00-\udfff]|\ud85b[\udc00-\udfff]|\ud85c[\udc00-\udfff]|\ud85d[\udc00-\udfff]|\ud85e[\udc00-\udfff]|\ud85f[\udc00-\udfff]|\ud860[\udc00-\udfff]|\ud861[\udc00-\udfff]|\ud862[\udc00-\udfff]|\ud863[\udc00-\udfff]|\ud864[\udc00-\udfff]|\ud865[\udc00-\udfff]|\ud866[\udc00-\udfff]|\ud867[\udc00-\udfff]|\ud868[\udc00-\udfff]|\ud869[\udc00-\uded6\udf00-\udfff]|\ud86a[\udc00-\udfff]|\ud86b[\udc00-\udfff]|\ud86c[\udc00-\udfff]|\ud86d[\udc00-\udf34\udf40-\udfff]|\ud86e[\udc00-\udc1d\udc20-\udfff]|\ud86f[\udc00-\udfff]|\ud870[\udc00-\udfff]|\ud871[\udc00-\udfff]|\ud872[\udc00-\udfff]|\ud873[\udc00-\udea1\udeb0-\udfff]|\ud874[\udc00-\udfff]|\ud875[\udc00-\udfff]|\ud876[\udc00-\udfff]|\ud877[\udc00-\udfff]|\ud878[\udc00-\udfff]|\ud879[\udc00-\udfff]|\ud87a[\udc00-\udfe0]|\ud87e[\udc00-\ude1d]|\udb40[\udd00-\uddef])|[$_]|(\\u[0-9a-fA-F]{4}|\\u\{[0-9a-fA-F]{1,}\})|[\u200c\u200d])*>/, function() {
      yytext = yytext.slice(3, -1);
      validateUnicodeGroupName(yytext, this.getCurrentState());
      return "NAMED_CAPTURE_GROUP";
    }], [/^\(/, function() {
      return "L_PAREN";
    }], [/^\)/, function() {
      return "R_PAREN";
    }], [/^[*?+[^$]/, function() {
      return "CHAR";
    }], [/^\\\]/, function() {
      return "ESC_CHAR";
    }], [/^\]/, function() {
      this.popState();
      return "R_BRACKET";
    }], [/^\^/, function() {
      return "BOS";
    }], [/^\$/, function() {
      return "EOS";
    }], [/^\*/, function() {
      return "STAR";
    }], [/^\?/, function() {
      return "Q_MARK";
    }], [/^\+/, function() {
      return "PLUS";
    }], [/^\|/, function() {
      return "BAR";
    }], [/^\./, function() {
      return "ANY";
    }], [/^\//, function() {
      return "SLASH";
    }], [/^[^*?+\[()\\|]/, function() {
      return "CHAR";
    }], [/^\[\^/, function() {
      var s = this.getCurrentState();
      this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
      return "NEG_CLASS";
    }], [/^\[/, function() {
      var s = this.getCurrentState();
      this.pushState(s === "u" || s === "xu" ? "u_class" : "class");
      return "L_BRACKET";
    }]];
    var lexRulesByConditions = { "INITIAL": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u": [8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "xu": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "x": [0, 1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "u_class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51], "class": [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] };
    var EOF_TOKEN = {
      type: EOF,
      value: ""
    };
    tokenizer = {
      initString: function initString(string) {
        this._string = string;
        this._cursor = 0;
        this._states = ["INITIAL"];
        this._tokensQueue = [];
        this._currentLine = 1;
        this._currentColumn = 0;
        this._currentLineBeginOffset = 0;
        this._tokenStartOffset = 0;
        this._tokenEndOffset = 0;
        this._tokenStartLine = 1;
        this._tokenEndLine = 1;
        this._tokenStartColumn = 0;
        this._tokenEndColumn = 0;
        return this;
      },
      getStates: function getStates() {
        return this._states;
      },
      getCurrentState: function getCurrentState() {
        return this._states[this._states.length - 1];
      },
      pushState: function pushState(state) {
        this._states.push(state);
      },
      begin: function begin(state) {
        this.pushState(state);
      },
      popState: function popState() {
        if (this._states.length > 1) {
          return this._states.pop();
        }
        return this._states[0];
      },
      getNextToken: function getNextToken() {
        if (this._tokensQueue.length > 0) {
          return this.onToken(this._toToken(this._tokensQueue.shift()));
        }
        if (!this.hasMoreTokens()) {
          return this.onToken(EOF_TOKEN);
        }
        var string = this._string.slice(this._cursor);
        var lexRulesForState = lexRulesByConditions[this.getCurrentState()];
        for (var i = 0; i < lexRulesForState.length; i++) {
          var lexRuleIndex = lexRulesForState[i];
          var lexRule = lexRules[lexRuleIndex];
          var matched = this._match(string, lexRule[0]);
          if (string === "" && matched === "") {
            this._cursor++;
          }
          if (matched !== null) {
            yytext = matched;
            yyleng = yytext.length;
            var token = lexRule[1].call(this);
            if (!token) {
              return this.getNextToken();
            }
            if (Array.isArray(token)) {
              var tokensToQueue = token.slice(1);
              token = token[0];
              if (tokensToQueue.length > 0) {
                var _tokensQueue;
                (_tokensQueue = this._tokensQueue).unshift.apply(_tokensQueue, _toConsumableArray(tokensToQueue));
              }
            }
            return this.onToken(this._toToken(token, yytext));
          }
        }
        if (this.isEOF()) {
          this._cursor++;
          return EOF_TOKEN;
        }
        this.throwUnexpectedToken(string[0], this._currentLine, this._currentColumn);
      },
      throwUnexpectedToken: function throwUnexpectedToken(symbol, line, column) {
        var lineSource = this._string.split("\n")[line - 1];
        var lineData = "";
        if (lineSource) {
          var pad = " ".repeat(column);
          lineData = "\n\n" + lineSource + "\n" + pad + "^\n";
        }
        throw new SyntaxError(lineData + 'Unexpected token: "' + symbol + '" ' + ("at " + line + ":" + column + "."));
      },
      getCursor: function getCursor() {
        return this._cursor;
      },
      getCurrentLine: function getCurrentLine() {
        return this._currentLine;
      },
      getCurrentColumn: function getCurrentColumn() {
        return this._currentColumn;
      },
      _captureLocation: function _captureLocation(matched) {
        var nlRe = /\n/g;
        this._tokenStartOffset = this._cursor;
        this._tokenStartLine = this._currentLine;
        this._tokenStartColumn = this._tokenStartOffset - this._currentLineBeginOffset;
        var nlMatch = void 0;
        while ((nlMatch = nlRe.exec(matched)) !== null) {
          this._currentLine++;
          this._currentLineBeginOffset = this._tokenStartOffset + nlMatch.index + 1;
        }
        this._tokenEndOffset = this._cursor + matched.length;
        this._tokenEndLine = this._currentLine;
        this._tokenEndColumn = this._currentColumn = this._tokenEndOffset - this._currentLineBeginOffset;
      },
      _toToken: function _toToken(tokenType) {
        var yytext2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
        return {
          type: tokenType,
          value: yytext2,
          startOffset: this._tokenStartOffset,
          endOffset: this._tokenEndOffset,
          startLine: this._tokenStartLine,
          endLine: this._tokenEndLine,
          startColumn: this._tokenStartColumn,
          endColumn: this._tokenEndColumn
        };
      },
      isEOF: function isEOF() {
        return this._cursor === this._string.length;
      },
      hasMoreTokens: function hasMoreTokens() {
        return this._cursor <= this._string.length;
      },
      _match: function _match(string, regexp) {
        var matched = string.match(regexp);
        if (matched) {
          this._captureLocation(matched[0]);
          this._cursor += matched[0].length;
          return matched[0];
        }
        return null;
      },
      onToken: function onToken(token) {
        return token;
      }
    };
    yy.lexer = tokenizer;
    yy.tokenizer = tokenizer;
    yy.options = {
      captureLocations: true
    };
    var yyparse = {
      setOptions: function setOptions(options) {
        yy.options = options;
        return this;
      },
      getOptions: function getOptions() {
        return yy.options;
      },
      parse: function parse(string, parseOptions) {
        if (!tokenizer) {
          throw new Error("Tokenizer instance wasn't specified.");
        }
        tokenizer.initString(string);
        var globalOptions = yy.options;
        if (parseOptions) {
          yy.options = Object.assign({}, yy.options, parseOptions);
        }
        yyparse.onParseBegin(string, tokenizer, yy.options);
        stack.length = 0;
        stack.push(0);
        var token = tokenizer.getNextToken();
        var shiftedToken = null;
        do {
          if (!token) {
            yy.options = globalOptions;
            unexpectedEndOfInput();
          }
          var state = stack[stack.length - 1];
          var column = tokens[token.type];
          if (!table[state].hasOwnProperty(column)) {
            yy.options = globalOptions;
            unexpectedToken(token);
          }
          var entry = table[state][column];
          if (entry[0] === "s") {
            var _loc2 = null;
            if (yy.options.captureLocations) {
              _loc2 = {
                startOffset: token.startOffset,
                endOffset: token.endOffset,
                startLine: token.startLine,
                endLine: token.endLine,
                startColumn: token.startColumn,
                endColumn: token.endColumn
              };
            }
            shiftedToken = this.onShift(token);
            stack.push({ symbol: tokens[shiftedToken.type], semanticValue: shiftedToken.value, loc: _loc2 }, Number(entry.slice(1)));
            token = tokenizer.getNextToken();
          } else if (entry[0] === "r") {
            var productionNumber = entry.slice(1);
            var production = productions[productionNumber];
            var hasSemanticAction = typeof production[2] === "function";
            var semanticValueArgs = hasSemanticAction ? [] : null;
            var locationArgs = hasSemanticAction && yy.options.captureLocations ? [] : null;
            if (production[1] !== 0) {
              var rhsLength = production[1];
              while (rhsLength-- > 0) {
                stack.pop();
                var stackEntry = stack.pop();
                if (hasSemanticAction) {
                  semanticValueArgs.unshift(stackEntry.semanticValue);
                  if (locationArgs) {
                    locationArgs.unshift(stackEntry.loc);
                  }
                }
              }
            }
            var reduceStackEntry = { symbol: production[0] };
            if (hasSemanticAction) {
              yytext = shiftedToken ? shiftedToken.value : null;
              yyleng = shiftedToken ? shiftedToken.value.length : null;
              var semanticActionArgs = locationArgs !== null ? semanticValueArgs.concat(locationArgs) : semanticValueArgs;
              production[2].apply(production, _toConsumableArray(semanticActionArgs));
              reduceStackEntry.semanticValue = __;
              if (locationArgs) {
                reduceStackEntry.loc = __loc;
              }
            }
            var nextState = stack[stack.length - 1];
            var symbolToReduceWith = production[0];
            stack.push(reduceStackEntry, table[nextState][symbolToReduceWith]);
          } else if (entry === "acc") {
            stack.pop();
            var parsed = stack.pop();
            if (stack.length !== 1 || stack[0] !== 0 || tokenizer.hasMoreTokens()) {
              yy.options = globalOptions;
              unexpectedToken(token);
            }
            if (parsed.hasOwnProperty("semanticValue")) {
              yy.options = globalOptions;
              yyparse.onParseEnd(parsed.semanticValue);
              return parsed.semanticValue;
            }
            yyparse.onParseEnd();
            yy.options = globalOptions;
            return true;
          }
        } while (tokenizer.hasMoreTokens() || stack.length > 1);
      },
      setTokenizer: function setTokenizer(customTokenizer) {
        tokenizer = customTokenizer;
        return yyparse;
      },
      getTokenizer: function getTokenizer() {
        return tokenizer;
      },
      onParseBegin: function onParseBegin(string, tokenizer2, options) {
      },
      onParseEnd: function onParseEnd(parsed) {
      },
      onShift: function onShift(token) {
        return token;
      }
    };
    var capturingGroupsCount = 0;
    var namedGroups = {};
    var parsingString = "";
    yyparse.onParseBegin = function(string, lexer) {
      parsingString = string;
      capturingGroupsCount = 0;
      namedGroups = {};
      var lastSlash = string.lastIndexOf("/");
      var flags = string.slice(lastSlash);
      if (flags.includes("x") && flags.includes("u")) {
        lexer.pushState("xu");
      } else {
        if (flags.includes("x")) {
          lexer.pushState("x");
        }
        if (flags.includes("u")) {
          lexer.pushState("u");
        }
      }
    };
    yyparse.onShift = function(token) {
      if (token.type === "L_PAREN" || token.type === "NAMED_CAPTURE_GROUP") {
        token.value = new String(token.value);
        token.value.groupNumber = ++capturingGroupsCount;
      }
      return token;
    };
    function getRange(text) {
      var range = text.match(/\d+/g).map(Number);
      if (Number.isFinite(range[1]) && range[1] < range[0]) {
        throw new SyntaxError("Numbers out of order in " + text + " quantifier");
      }
      return range;
    }
    function checkClassRange(from, to) {
      if (from.kind === "control" || to.kind === "control" || !isNaN(from.codePoint) && !isNaN(to.codePoint) && from.codePoint > to.codePoint) {
        throw new SyntaxError("Range " + from.value + "-" + to.value + " out of order in character class");
      }
    }
    var unicodeProperties = require_parser_unicode_properties();
    function UnicodeProperty(matched, loc2) {
      var negative = matched[1] === "P";
      var separatorIdx = matched.indexOf("=");
      var name = matched.slice(3, separatorIdx !== -1 ? separatorIdx : -1);
      var value = void 0;
      var isShorthand = separatorIdx === -1 && unicodeProperties.isGeneralCategoryValue(name);
      var isBinaryProperty = separatorIdx === -1 && unicodeProperties.isBinaryPropertyName(name);
      if (isShorthand) {
        value = name;
        name = "General_Category";
      } else if (isBinaryProperty) {
        value = name;
      } else {
        if (!unicodeProperties.isValidName(name)) {
          throw new SyntaxError("Invalid unicode property name: " + name + ".");
        }
        value = matched.slice(separatorIdx + 1, -1);
        if (!unicodeProperties.isValidValue(name, value)) {
          throw new SyntaxError("Invalid " + name + " unicode property value: " + value + ".");
        }
      }
      return Node({
        type: "UnicodeProperty",
        name,
        value,
        negative,
        shorthand: isShorthand,
        binary: isBinaryProperty,
        canonicalName: unicodeProperties.getCanonicalName(name) || name,
        canonicalValue: unicodeProperties.getCanonicalValue(value) || value
      }, loc2);
    }
    function Char(value, kind, loc2) {
      var symbol = void 0;
      var codePoint = void 0;
      switch (kind) {
        case "decimal": {
          codePoint = Number(value.slice(1));
          symbol = String.fromCodePoint(codePoint);
          break;
        }
        case "oct": {
          codePoint = parseInt(value.slice(1), 8);
          symbol = String.fromCodePoint(codePoint);
          break;
        }
        case "hex":
        case "unicode": {
          if (value.lastIndexOf("\\u") > 0) {
            var _value$split$slice = value.split("\\u").slice(1), _value$split$slice2 = _slicedToArray(_value$split$slice, 2), lead = _value$split$slice2[0], trail = _value$split$slice2[1];
            lead = parseInt(lead, 16);
            trail = parseInt(trail, 16);
            codePoint = (lead - 55296) * 1024 + (trail - 56320) + 65536;
            symbol = String.fromCodePoint(codePoint);
          } else {
            var hex = value.slice(2).replace("{", "");
            codePoint = parseInt(hex, 16);
            if (codePoint > 1114111) {
              throw new SyntaxError("Bad character escape sequence: " + value);
            }
            symbol = String.fromCodePoint(codePoint);
          }
          break;
        }
        case "meta": {
          switch (value) {
            case "\\t":
              symbol = "	";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\n":
              symbol = "\n";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\r":
              symbol = "\r";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\v":
              symbol = "\v";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\f":
              symbol = "\f";
              codePoint = symbol.codePointAt(0);
              break;
            case "\\b":
              symbol = "\b";
              codePoint = symbol.codePointAt(0);
            case "\\0":
              symbol = "\0";
              codePoint = 0;
            case ".":
              symbol = ".";
              codePoint = NaN;
              break;
            default:
              codePoint = NaN;
          }
          break;
        }
        case "simple": {
          symbol = value;
          codePoint = symbol.codePointAt(0);
          break;
        }
      }
      return Node({
        type: "Char",
        value,
        kind,
        symbol,
        codePoint
      }, loc2);
    }
    var validFlags = "gimsuxy";
    function checkFlags(flags) {
      var seen = /* @__PURE__ */ new Set();
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = flags[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var flag = _step.value;
          if (seen.has(flag) || !validFlags.includes(flag)) {
            throw new SyntaxError("Invalid flags: " + flags);
          }
          seen.add(flag);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return flags.split("").sort().join("");
    }
    function GroupRefOrDecChar(text, textLoc) {
      var reference = Number(text.slice(1));
      if (reference > 0 && reference <= capturingGroupsCount) {
        return Node({
          type: "Backreference",
          kind: "number",
          number: reference,
          reference
        }, textLoc);
      }
      return Char(text, "decimal", textLoc);
    }
    var uReStart = /^\\u[0-9a-fA-F]{4}/;
    var ucpReStart = /^\\u\{[0-9a-fA-F]{1,}\}/;
    var ucpReAnywhere = /\\u\{[0-9a-fA-F]{1,}\}/;
    function validateUnicodeGroupName(name, state) {
      var isUnicodeName = ucpReAnywhere.test(name);
      var isUnicodeState = state === "u" || state === "xu" || state === "u_class";
      if (isUnicodeName && !isUnicodeState) {
        throw new SyntaxError('invalid group Unicode name "' + name + '", use `u` flag.');
      }
      return name;
    }
    var uidRe = /\\u(?:([dD][89aAbB][0-9a-fA-F]{2})\\u([dD][c-fC-F][0-9a-fA-F]{2})|([dD][89aAbB][0-9a-fA-F]{2})|([dD][c-fC-F][0-9a-fA-F]{2})|([0-9a-ce-fA-CE-F][0-9a-fA-F]{3}|[dD][0-7][0-9a-fA-F]{2})|\{(0*(?:[0-9a-fA-F]{1,5}|10[0-9a-fA-F]{4}))\})/;
    function decodeUnicodeGroupName(name) {
      return name.replace(new RegExp(uidRe, "g"), function(_, leadSurrogate, trailSurrogate, leadSurrogateOnly, trailSurrogateOnly, nonSurrogate, codePoint) {
        if (leadSurrogate) {
          return String.fromCodePoint(parseInt(leadSurrogate, 16), parseInt(trailSurrogate, 16));
        }
        if (leadSurrogateOnly) {
          return String.fromCodePoint(parseInt(leadSurrogateOnly, 16));
        }
        if (trailSurrogateOnly) {
          return String.fromCodePoint(parseInt(trailSurrogateOnly, 16));
        }
        if (nonSurrogate) {
          return String.fromCodePoint(parseInt(nonSurrogate, 16));
        }
        if (codePoint) {
          return String.fromCodePoint(parseInt(codePoint, 16));
        }
        return _;
      });
    }
    function NamedGroupRefOrChars(text, textLoc) {
      var referenceRaw = text.slice(3, -1);
      var reference = decodeUnicodeGroupName(referenceRaw);
      if (namedGroups.hasOwnProperty(reference)) {
        return Node({
          type: "Backreference",
          kind: "name",
          number: namedGroups[reference],
          reference,
          referenceRaw
        }, textLoc);
      }
      var startOffset = null;
      var startLine = null;
      var endLine = null;
      var startColumn = null;
      if (textLoc) {
        startOffset = textLoc.startOffset;
        startLine = textLoc.startLine;
        endLine = textLoc.endLine;
        startColumn = textLoc.startColumn;
      }
      var charRe = /^[\w$<>]/;
      var loc2 = void 0;
      var chars = [
        Char(text.slice(1, 2), "simple", startOffset ? {
          startLine,
          endLine,
          startColumn,
          startOffset,
          endOffset: startOffset += 2,
          endColumn: startColumn += 2
        } : null)
      ];
      chars[0].escaped = true;
      text = text.slice(2);
      while (text.length > 0) {
        var matched = null;
        if ((matched = text.match(uReStart)) || (matched = text.match(ucpReStart))) {
          if (startOffset) {
            loc2 = {
              startLine,
              endLine,
              startColumn,
              startOffset,
              endOffset: startOffset += matched[0].length,
              endColumn: startColumn += matched[0].length
            };
          }
          chars.push(Char(matched[0], "unicode", loc2));
          text = text.slice(matched[0].length);
        } else if (matched = text.match(charRe)) {
          if (startOffset) {
            loc2 = {
              startLine,
              endLine,
              startColumn,
              startOffset,
              endOffset: ++startOffset,
              endColumn: ++startColumn
            };
          }
          chars.push(Char(matched[0], "simple", loc2));
          text = text.slice(1);
        }
      }
      return chars;
    }
    function Node(node, loc2) {
      if (yy.options.captureLocations) {
        node.loc = {
          source: parsingString.slice(loc2.startOffset, loc2.endOffset),
          start: {
            line: loc2.startLine,
            column: loc2.startColumn,
            offset: loc2.startOffset
          },
          end: {
            line: loc2.endLine,
            column: loc2.endColumn,
            offset: loc2.endOffset
          }
        };
      }
      return node;
    }
    function loc(start, end) {
      if (!yy.options.captureLocations) {
        return null;
      }
      return {
        startOffset: start.startOffset,
        endOffset: end.endOffset,
        startLine: start.startLine,
        endLine: end.endLine,
        startColumn: start.startColumn,
        endColumn: end.endColumn
      };
    }
    function unexpectedToken(token) {
      if (token.type === EOF) {
        unexpectedEndOfInput();
      }
      tokenizer.throwUnexpectedToken(token.value, token.startLine, token.startColumn);
    }
    function unexpectedEndOfInput() {
      parseError("Unexpected end of input.");
    }
    function parseError(message) {
      throw new SyntaxError(message);
    }
    module2.exports = yyparse;
  }
});

// node_modules/regexp-tree/dist/parser/index.js
var require_parser = __commonJS({
  "node_modules/regexp-tree/dist/parser/index.js"(exports2, module2) {
    "use strict";
    var regexpTreeParser = require_regexp_tree();
    var generatedParseFn = regexpTreeParser.parse.bind(regexpTreeParser);
    regexpTreeParser.parse = function(regexp, options) {
      return generatedParseFn("" + regexp, options);
    };
    regexpTreeParser.setOptions({ captureLocations: false });
    module2.exports = regexpTreeParser;
  }
});

// node_modules/regexp-tree/dist/traverse/node-path.js
var require_node_path = __commonJS({
  "node_modules/regexp-tree/dist/traverse/node-path.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var DEFAULT_COLLECTION_PROP = "expressions";
    var DEFAULT_SINGLE_PROP = "expression";
    var NodePath = function() {
      function NodePath2(node) {
        var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
        var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
        _classCallCheck(this, NodePath2);
        this.node = node;
        this.parentPath = parentPath;
        this.parent = parentPath ? parentPath.node : null;
        this.property = property;
        this.index = index;
      }
      _createClass(NodePath2, [{
        key: "_enforceProp",
        value: function _enforceProp(property) {
          if (!this.node.hasOwnProperty(property)) {
            throw new Error("Node of type " + this.node.type + ` doesn't have "` + property + '" collection.');
          }
        }
      }, {
        key: "setChild",
        value: function setChild(node) {
          var index = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var childPath = void 0;
          if (index != null) {
            if (!property) {
              property = DEFAULT_COLLECTION_PROP;
            }
            this._enforceProp(property);
            this.node[property][index] = node;
            childPath = NodePath2.getForNode(node, this, property, index);
          } else {
            if (!property) {
              property = DEFAULT_SINGLE_PROP;
            }
            this._enforceProp(property);
            this.node[property] = node;
            childPath = NodePath2.getForNode(node, this, property, null);
          }
          return childPath;
        }
      }, {
        key: "appendChild",
        value: function appendChild(node) {
          var property = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          if (!property) {
            property = DEFAULT_COLLECTION_PROP;
          }
          this._enforceProp(property);
          var end = this.node[property].length;
          return this.setChild(node, end, property);
        }
      }, {
        key: "insertChildAt",
        value: function insertChildAt(node, index) {
          var property = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : DEFAULT_COLLECTION_PROP;
          this._enforceProp(property);
          this.node[property].splice(index, 0, node);
          if (index <= NodePath2.getTraversingIndex()) {
            NodePath2.updateTraversingIndex(1);
          }
          this._rebuildIndex(this.node, property);
        }
      }, {
        key: "remove",
        value: function remove() {
          if (this.isRemoved()) {
            return;
          }
          NodePath2.registry.delete(this.node);
          this.node = null;
          if (!this.parent) {
            return;
          }
          if (this.index !== null) {
            this.parent[this.property].splice(this.index, 1);
            if (this.index <= NodePath2.getTraversingIndex()) {
              NodePath2.updateTraversingIndex(-1);
            }
            this._rebuildIndex(this.parent, this.property);
            this.index = null;
            this.property = null;
            return;
          }
          delete this.parent[this.property];
          this.property = null;
        }
      }, {
        key: "_rebuildIndex",
        value: function _rebuildIndex(parent, property) {
          var parentPath = NodePath2.getForNode(parent);
          for (var i = 0; i < parent[property].length; i++) {
            var path = NodePath2.getForNode(parent[property][i], parentPath, property, i);
            path.index = i;
          }
        }
      }, {
        key: "isRemoved",
        value: function isRemoved() {
          return this.node === null;
        }
      }, {
        key: "replace",
        value: function replace(newNode) {
          NodePath2.registry.delete(this.node);
          this.node = newNode;
          if (!this.parent) {
            return null;
          }
          if (this.index !== null) {
            this.parent[this.property][this.index] = newNode;
          } else {
            this.parent[this.property] = newNode;
          }
          return NodePath2.getForNode(newNode, this.parentPath, this.property, this.index);
        }
      }, {
        key: "update",
        value: function update(nodeProps) {
          Object.assign(this.node, nodeProps);
        }
      }, {
        key: "getParent",
        value: function getParent() {
          return this.parentPath;
        }
      }, {
        key: "getChild",
        value: function getChild() {
          var n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this.node.expressions) {
            return NodePath2.getForNode(this.node.expressions[n], this, DEFAULT_COLLECTION_PROP, n);
          } else if (this.node.expression && n == 0) {
            return NodePath2.getForNode(this.node.expression, this, DEFAULT_SINGLE_PROP);
          }
          return null;
        }
      }, {
        key: "hasEqualSource",
        value: function hasEqualSource(path) {
          return JSON.stringify(this.node, jsonSkipLoc) === JSON.stringify(path.node, jsonSkipLoc);
        }
      }, {
        key: "jsonEncode",
        value: function jsonEncode() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, format = _ref.format, useLoc = _ref.useLoc;
          return JSON.stringify(this.node, useLoc ? null : jsonSkipLoc, format);
        }
      }, {
        key: "getPreviousSibling",
        value: function getPreviousSibling() {
          if (!this.parent || this.index == null) {
            return null;
          }
          return NodePath2.getForNode(this.parent[this.property][this.index - 1], NodePath2.getForNode(this.parent), this.property, this.index - 1);
        }
      }, {
        key: "getNextSibling",
        value: function getNextSibling() {
          if (!this.parent || this.index == null) {
            return null;
          }
          return NodePath2.getForNode(this.parent[this.property][this.index + 1], NodePath2.getForNode(this.parent), this.property, this.index + 1);
        }
      }], [{
        key: "getForNode",
        value: function getForNode(node) {
          var parentPath = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
          var prop = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
          var index = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : -1;
          if (!node) {
            return null;
          }
          if (!NodePath2.registry.has(node)) {
            NodePath2.registry.set(node, new NodePath2(node, parentPath, prop, index == -1 ? null : index));
          }
          var path = NodePath2.registry.get(node);
          if (parentPath !== null) {
            path.parentPath = parentPath;
            path.parent = path.parentPath.node;
          }
          if (prop !== null) {
            path.property = prop;
          }
          if (index >= 0) {
            path.index = index;
          }
          return path;
        }
      }, {
        key: "initRegistry",
        value: function initRegistry() {
          if (!NodePath2.registry) {
            NodePath2.registry = /* @__PURE__ */ new Map();
          }
          NodePath2.registry.clear();
        }
      }, {
        key: "updateTraversingIndex",
        value: function updateTraversingIndex(dx) {
          return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1] += dx;
        }
      }, {
        key: "getTraversingIndex",
        value: function getTraversingIndex() {
          return NodePath2.traversingIndexStack[NodePath2.traversingIndexStack.length - 1];
        }
      }]);
      return NodePath2;
    }();
    NodePath.initRegistry();
    NodePath.traversingIndexStack = [];
    function jsonSkipLoc(prop, value) {
      if (prop === "loc") {
        return void 0;
      }
      return value;
    }
    module2.exports = NodePath;
  }
});

// node_modules/regexp-tree/dist/traverse/index.js
var require_traverse = __commonJS({
  "node_modules/regexp-tree/dist/traverse/index.js"(exports2, module2) {
    "use strict";
    var NodePath = require_node_path();
    function astTraverse(root) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var pre = options.pre;
      var post = options.post;
      var skipProperty = options.skipProperty;
      function visit(node, parent, prop, idx) {
        if (!node || typeof node.type !== "string") {
          return;
        }
        var res = void 0;
        if (pre) {
          res = pre(node, parent, prop, idx);
        }
        if (res !== false) {
          if (parent && parent[prop]) {
            if (!isNaN(idx)) {
              node = parent[prop][idx];
            } else {
              node = parent[prop];
            }
          }
          for (var _prop in node) {
            if (node.hasOwnProperty(_prop)) {
              if (skipProperty ? skipProperty(_prop, node) : _prop[0] === "$") {
                continue;
              }
              var child = node[_prop];
              if (Array.isArray(child)) {
                var index = 0;
                NodePath.traversingIndexStack.push(index);
                while (index < child.length) {
                  visit(child[index], node, _prop, index);
                  index = NodePath.updateTraversingIndex(1);
                }
                NodePath.traversingIndexStack.pop();
              } else {
                visit(child, node, _prop);
              }
            }
          }
        }
        if (post) {
          post(node, parent, prop, idx);
        }
      }
      visit(root, null);
    }
    module2.exports = {
      traverse: function traverse(ast, handlers) {
        var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : { asNodes: false };
        if (!Array.isArray(handlers)) {
          handlers = [handlers];
        }
        handlers = handlers.filter(function(handler) {
          if (typeof handler.shouldRun !== "function") {
            return true;
          }
          return handler.shouldRun(ast);
        });
        NodePath.initRegistry();
        handlers.forEach(function(handler) {
          if (typeof handler.init === "function") {
            handler.init(ast);
          }
        });
        function getPathFor(node, parent, prop, index) {
          var parentPath = NodePath.getForNode(parent);
          var nodePath = NodePath.getForNode(node, parentPath, prop, index);
          return nodePath;
        }
        astTraverse(ast, {
          pre: function pre(node, parent, prop, index) {
            var nodePath = void 0;
            if (!options.asNodes) {
              nodePath = getPathFor(node, parent, prop, index);
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = handlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var handler = _step.value;
                if (typeof handler["*"] === "function") {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var handlerResult = handler["*"](nodePath);
                      if (handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handler["*"](node, parent, prop, index);
                  }
                }
                var handlerFuncPre = void 0;
                if (typeof handler[node.type] === "function") {
                  handlerFuncPre = handler[node.type];
                } else if (typeof handler[node.type] === "object" && typeof handler[node.type].pre === "function") {
                  handlerFuncPre = handler[node.type].pre;
                }
                if (handlerFuncPre) {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var _handlerResult = handlerFuncPre.call(handler, nodePath);
                      if (_handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handlerFuncPre.call(handler, node, parent, prop, index);
                  }
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          },
          post: function post(node, parent, prop, index) {
            if (!node) {
              return;
            }
            var nodePath = void 0;
            if (!options.asNodes) {
              nodePath = getPathFor(node, parent, prop, index);
            }
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = handlers[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var handler = _step2.value;
                var handlerFuncPost = void 0;
                if (typeof handler[node.type] === "object" && typeof handler[node.type].post === "function") {
                  handlerFuncPost = handler[node.type].post;
                }
                if (handlerFuncPost) {
                  if (nodePath) {
                    if (!nodePath.isRemoved()) {
                      var handlerResult = handlerFuncPost.call(handler, nodePath);
                      if (handlerResult === false) {
                        return false;
                      }
                    }
                  } else {
                    handlerFuncPost.call(handler, node, parent, prop, index);
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          },
          skipProperty: function skipProperty(prop) {
            return prop === "loc";
          }
        });
      }
    };
  }
});

// node_modules/regexp-tree/dist/transform/index.js
var require_transform = __commonJS({
  "node_modules/regexp-tree/dist/transform/index.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var generator = require_generator();
    var parser = require_parser();
    var traverse = require_traverse();
    var TransformResult = function() {
      function TransformResult2(ast) {
        var extra = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
        _classCallCheck(this, TransformResult2);
        this._ast = ast;
        this._source = null;
        this._string = null;
        this._regexp = null;
        this._extra = extra;
      }
      _createClass(TransformResult2, [{
        key: "getAST",
        value: function getAST() {
          return this._ast;
        }
      }, {
        key: "setExtra",
        value: function setExtra(extra) {
          this._extra = extra;
        }
      }, {
        key: "getExtra",
        value: function getExtra() {
          return this._extra;
        }
      }, {
        key: "toRegExp",
        value: function toRegExp() {
          if (!this._regexp) {
            this._regexp = new RegExp(this.getSource(), this._ast.flags);
          }
          return this._regexp;
        }
      }, {
        key: "getSource",
        value: function getSource() {
          if (!this._source) {
            this._source = generator.generate(this._ast.body);
          }
          return this._source;
        }
      }, {
        key: "getFlags",
        value: function getFlags() {
          return this._ast.flags;
        }
      }, {
        key: "toString",
        value: function toString() {
          if (!this._string) {
            this._string = generator.generate(this._ast);
          }
          return this._string;
        }
      }]);
      return TransformResult2;
    }();
    module2.exports = {
      TransformResult,
      transform: function transform(regexp, handlers) {
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser.parse(regexp, {
            captureLocations: true
          });
        }
        traverse.traverse(ast, handlers);
        return new TransformResult(ast);
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/index.js
var require_compat_transpiler = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/index.js"(exports2, module2) {
    "use strict";
    var compatTransforms = require_transforms();
    var _transform = require_transform();
    module2.exports = {
      transform: function transform(regexp) {
        var transformsWhitelist = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
        var transformToApply = transformsWhitelist.length > 0 ? transformsWhitelist : Object.keys(compatTransforms);
        var result = void 0;
        var extra = {};
        transformToApply.forEach(function(transformName) {
          if (!compatTransforms.hasOwnProperty(transformName)) {
            throw new Error("Unknown compat-transform: " + transformName + ". Available transforms are: " + Object.keys(compatTransforms).join(", "));
          }
          var handler = compatTransforms[transformName];
          result = _transform.transform(regexp, handler);
          regexp = result.getAST();
          if (typeof handler.getExtra === "function") {
            extra[transformName] = handler.getExtra();
          }
        });
        result.setExtra(extra);
        return result;
      }
    };
  }
});

// node_modules/regexp-tree/dist/utils/clone.js
var require_clone = __commonJS({
  "node_modules/regexp-tree/dist/utils/clone.js"(exports2, module2) {
    "use strict";
    module2.exports = function clone(obj) {
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      var res = void 0;
      if (Array.isArray(obj)) {
        res = [];
      } else {
        res = {};
      }
      for (var i in obj) {
        res[i] = clone(obj[i]);
      }
      return res;
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js
var require_char_surrogate_pair_to_single_unicode_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-surrogate-pair-to-single-unicode-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      shouldRun: function shouldRun(ast) {
        return ast.flags.includes("u");
      },
      Char: function Char(path) {
        var node = path.node;
        if (node.kind !== "unicode" || !node.isSurrogatePair || isNaN(node.codePoint)) {
          return;
        }
        node.value = "\\u{" + node.codePoint.toString(16) + "}";
        delete node.isSurrogatePair;
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js
var require_char_code_to_simple_char_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-code-to-simple-char-transform.js"(exports2, module2) {
    "use strict";
    var UPPER_A_CP = "A".codePointAt(0);
    var UPPER_Z_CP = "Z".codePointAt(0);
    var LOWER_A_CP = "a".codePointAt(0);
    var LOWER_Z_CP = "z".codePointAt(0);
    var DIGIT_0_CP = "0".codePointAt(0);
    var DIGIT_9_CP = "9".codePointAt(0);
    module2.exports = {
      Char: function Char(path) {
        var node = path.node, parent = path.parent;
        if (isNaN(node.codePoint) || node.kind === "simple") {
          return;
        }
        if (parent.type === "ClassRange") {
          if (!isSimpleRange(parent)) {
            return;
          }
        }
        if (!isPrintableASCIIChar(node.codePoint)) {
          return;
        }
        var symbol = String.fromCodePoint(node.codePoint);
        var newChar = {
          type: "Char",
          kind: "simple",
          value: symbol,
          symbol,
          codePoint: node.codePoint
        };
        if (needsEscape(symbol, parent.type)) {
          newChar.escaped = true;
        }
        path.replace(newChar);
      }
    };
    function isSimpleRange(classRange) {
      var from = classRange.from, to = classRange.to;
      return from.codePoint >= DIGIT_0_CP && from.codePoint <= DIGIT_9_CP && to.codePoint >= DIGIT_0_CP && to.codePoint <= DIGIT_9_CP || from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP || from.codePoint >= LOWER_A_CP && from.codePoint <= LOWER_Z_CP && to.codePoint >= LOWER_A_CP && to.codePoint <= LOWER_Z_CP;
    }
    function isPrintableASCIIChar(codePoint) {
      return codePoint >= 32 && codePoint <= 126;
    }
    function needsEscape(symbol, parentType) {
      if (parentType === "ClassRange" || parentType === "CharacterClass") {
        return /[\]\\^-]/.test(symbol);
      }
      return /[*[()+?^$./\\|{}]/.test(symbol);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js
var require_char_case_insensitive_lowercase_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-case-insensitive-lowercase-transform.js"(exports2, module2) {
    "use strict";
    var UPPER_A_CP = "A".codePointAt(0);
    var UPPER_Z_CP = "Z".codePointAt(0);
    module2.exports = {
      _AZClassRanges: null,
      _hasUFlag: false,
      init: function init(ast) {
        this._AZClassRanges = /* @__PURE__ */ new Set();
        this._hasUFlag = ast.flags.includes("u");
      },
      shouldRun: function shouldRun(ast) {
        return ast.flags.includes("i");
      },
      Char: function Char(path) {
        var node = path.node, parent = path.parent;
        if (isNaN(node.codePoint)) {
          return;
        }
        if (!this._hasUFlag && node.codePoint >= 4096) {
          return;
        }
        if (parent.type === "ClassRange") {
          if (!this._AZClassRanges.has(parent) && !isAZClassRange(parent)) {
            return;
          }
          this._AZClassRanges.add(parent);
        }
        var lower = node.symbol.toLowerCase();
        if (lower !== node.symbol) {
          node.value = displaySymbolAsValue(lower, node);
          node.symbol = lower;
          node.codePoint = lower.codePointAt(0);
        }
      }
    };
    function isAZClassRange(classRange) {
      var from = classRange.from, to = classRange.to;
      return from.codePoint >= UPPER_A_CP && from.codePoint <= UPPER_Z_CP && to.codePoint >= UPPER_A_CP && to.codePoint <= UPPER_Z_CP;
    }
    function displaySymbolAsValue(symbol, node) {
      var codePoint = symbol.codePointAt(0);
      if (node.kind === "decimal") {
        return "\\" + codePoint;
      }
      if (node.kind === "oct") {
        return "\\0" + codePoint.toString(8);
      }
      if (node.kind === "hex") {
        return "\\x" + codePoint.toString(16);
      }
      if (node.kind === "unicode") {
        if (node.isSurrogatePair) {
          var _getSurrogatePairFrom = getSurrogatePairFromCodePoint(codePoint), lead = _getSurrogatePairFrom.lead, trail = _getSurrogatePairFrom.trail;
          return "\\u" + "0".repeat(4 - lead.length) + lead + "\\u" + "0".repeat(4 - trail.length) + trail;
        } else if (node.value.includes("{")) {
          return "\\u{" + codePoint.toString(16) + "}";
        } else {
          var code = codePoint.toString(16);
          return "\\u" + "0".repeat(4 - code.length) + code;
        }
      }
      return symbol;
    }
    function getSurrogatePairFromCodePoint(codePoint) {
      var lead = Math.floor((codePoint - 65536) / 1024) + 55296;
      var trail = (codePoint - 65536) % 1024 + 56320;
      return {
        lead: lead.toString(16),
        trail: trail.toString(16)
      };
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js
var require_char_class_remove_duplicates_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-remove-duplicates-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        var sources = {};
        for (var i = 0; i < node.expressions.length; i++) {
          var childPath = path.getChild(i);
          var source = childPath.jsonEncode();
          if (sources.hasOwnProperty(source)) {
            childPath.remove();
            i--;
          }
          sources[source] = true;
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/transform/utils.js
var require_utils2 = __commonJS({
  "node_modules/regexp-tree/dist/transform/utils.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function disjunctionToList(node) {
      if (node.type !== "Disjunction") {
        throw new TypeError('Expected "Disjunction" node, got "' + node.type + '"');
      }
      var list = [];
      if (node.left && node.left.type === "Disjunction") {
        list.push.apply(list, _toConsumableArray(disjunctionToList(node.left)).concat([node.right]));
      } else {
        list.push(node.left, node.right);
      }
      return list;
    }
    function listToDisjunction(list) {
      return list.reduce(function(left, right) {
        return {
          type: "Disjunction",
          left,
          right
        };
      });
    }
    function increaseQuantifierByOne(quantifier) {
      if (quantifier.kind === "*") {
        quantifier.kind = "+";
      } else if (quantifier.kind === "+") {
        quantifier.kind = "Range";
        quantifier.from = 2;
        delete quantifier.to;
      } else if (quantifier.kind === "?") {
        quantifier.kind = "Range";
        quantifier.from = 1;
        quantifier.to = 2;
      } else if (quantifier.kind === "Range") {
        quantifier.from += 1;
        if (quantifier.to) {
          quantifier.to += 1;
        }
      }
    }
    module2.exports = {
      disjunctionToList,
      listToDisjunction,
      increaseQuantifierByOne
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js
var require_quantifiers_merge_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/quantifiers-merge-transform.js"(exports2, module2) {
    "use strict";
    var _require = require_utils2();
    var increaseQuantifierByOne = _require.increaseQuantifierByOne;
    module2.exports = {
      Repetition: function Repetition(path) {
        var node = path.node, parent = path.parent;
        if (parent.type !== "Alternative" || !path.index) {
          return;
        }
        var previousSibling = path.getPreviousSibling();
        if (!previousSibling) {
          return;
        }
        if (previousSibling.node.type === "Repetition") {
          if (!previousSibling.getChild().hasEqualSource(path.getChild())) {
            return;
          }
          var _extractFromTo = extractFromTo(previousSibling.node.quantifier), previousSiblingFrom = _extractFromTo.from, previousSiblingTo = _extractFromTo.to;
          var _extractFromTo2 = extractFromTo(node.quantifier), nodeFrom = _extractFromTo2.from, nodeTo = _extractFromTo2.to;
          if (previousSibling.node.quantifier.greedy !== node.quantifier.greedy && !isGreedyOpenRange(previousSibling.node.quantifier) && !isGreedyOpenRange(node.quantifier)) {
            return;
          }
          node.quantifier.kind = "Range";
          node.quantifier.from = previousSiblingFrom + nodeFrom;
          if (previousSiblingTo && nodeTo) {
            node.quantifier.to = previousSiblingTo + nodeTo;
          } else {
            delete node.quantifier.to;
          }
          if (isGreedyOpenRange(previousSibling.node.quantifier) || isGreedyOpenRange(node.quantifier)) {
            node.quantifier.greedy = true;
          }
          previousSibling.remove();
        } else {
          if (!previousSibling.hasEqualSource(path.getChild())) {
            return;
          }
          increaseQuantifierByOne(node.quantifier);
          previousSibling.remove();
        }
      }
    };
    function isGreedyOpenRange(quantifier) {
      return quantifier.greedy && (quantifier.kind === "+" || quantifier.kind === "*" || quantifier.kind === "Range" && !quantifier.to);
    }
    function extractFromTo(quantifier) {
      var from = void 0, to = void 0;
      if (quantifier.kind === "*") {
        from = 0;
      } else if (quantifier.kind === "+") {
        from = 1;
      } else if (quantifier.kind === "?") {
        from = 0;
        to = 1;
      } else {
        from = quantifier.from;
        if (quantifier.to) {
          to = quantifier.to;
        }
      }
      return { from, to };
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js
var require_quantifier_range_to_symbol_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/quantifier-range-to-symbol-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Quantifier: function Quantifier(path) {
        var node = path.node;
        if (node.kind !== "Range") {
          return;
        }
        rewriteOpenZero(path);
        rewriteOpenOne(path);
        rewriteExactOne(path);
      }
    };
    function rewriteOpenZero(path) {
      var node = path.node;
      if (node.from !== 0 || node.to) {
        return;
      }
      node.kind = "*";
      delete node.from;
    }
    function rewriteOpenOne(path) {
      var node = path.node;
      if (node.from !== 1 || node.to) {
        return;
      }
      node.kind = "+";
      delete node.from;
    }
    function rewriteExactOne(path) {
      var node = path.node;
      if (node.from !== 1 || node.to !== 1) {
        return;
      }
      path.parentPath.replace(path.parentPath.node.expression);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js
var require_char_class_classranges_to_chars_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-to-chars-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      ClassRange: function ClassRange(path) {
        var node = path.node;
        if (node.from.codePoint === node.to.codePoint) {
          path.replace(node.from);
        } else if (node.from.codePoint === node.to.codePoint - 1) {
          path.getParent().insertChildAt(node.to, path.index + 1);
          path.replace(node.from);
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js
var require_char_class_to_meta_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-meta-transform.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module2.exports = {
      _hasIFlag: false,
      _hasUFlag: false,
      init: function init(ast) {
        this._hasIFlag = ast.flags.includes("i");
        this._hasUFlag = ast.flags.includes("u");
      },
      CharacterClass: function CharacterClass(path) {
        rewriteNumberRanges(path);
        rewriteWordRanges(path, this._hasIFlag, this._hasUFlag);
        rewriteWhitespaceRanges(path);
      }
    };
    function rewriteNumberRanges(path) {
      var node = path.node;
      node.expressions.forEach(function(expression, i) {
        if (isFullNumberRange(expression)) {
          path.getChild(i).replace({
            type: "Char",
            value: "\\d",
            kind: "meta"
          });
        }
      });
    }
    function rewriteWordRanges(path, hasIFlag, hasUFlag) {
      var node = path.node;
      var numberPath = null;
      var lowerCasePath = null;
      var upperCasePath = null;
      var underscorePath = null;
      var u017fPath = null;
      var u212aPath = null;
      node.expressions.forEach(function(expression, i) {
        if (isMetaChar(expression, "\\d")) {
          numberPath = path.getChild(i);
        } else if (isLowerCaseRange(expression)) {
          lowerCasePath = path.getChild(i);
        } else if (isUpperCaseRange(expression)) {
          upperCasePath = path.getChild(i);
        } else if (isUnderscore(expression)) {
          underscorePath = path.getChild(i);
        } else if (hasIFlag && hasUFlag && isCodePoint(expression, 383)) {
          u017fPath = path.getChild(i);
        } else if (hasIFlag && hasUFlag && isCodePoint(expression, 8490)) {
          u212aPath = path.getChild(i);
        }
      });
      if (numberPath && (lowerCasePath && upperCasePath || hasIFlag && (lowerCasePath || upperCasePath)) && underscorePath && (!hasUFlag || !hasIFlag || u017fPath && u212aPath)) {
        numberPath.replace({
          type: "Char",
          value: "\\w",
          kind: "meta"
        });
        if (lowerCasePath) {
          lowerCasePath.remove();
        }
        if (upperCasePath) {
          upperCasePath.remove();
        }
        underscorePath.remove();
        if (u017fPath) {
          u017fPath.remove();
        }
        if (u212aPath) {
          u212aPath.remove();
        }
      }
    }
    var whitespaceRangeTests = [function(node) {
      return isChar(node, " ");
    }].concat(_toConsumableArray(["\\f", "\\n", "\\r", "\\t", "\\v"].map(function(char) {
      return function(node) {
        return isMetaChar(node, char);
      };
    })), _toConsumableArray([160, 5760, 8232, 8233, 8239, 8287, 12288, 65279].map(function(codePoint) {
      return function(node) {
        return isCodePoint(node, codePoint);
      };
    })), [function(node) {
      return node.type === "ClassRange" && isCodePoint(node.from, 8192) && isCodePoint(node.to, 8202);
    }]);
    function rewriteWhitespaceRanges(path) {
      var node = path.node;
      if (node.expressions.length < whitespaceRangeTests.length || !whitespaceRangeTests.every(function(test) {
        return node.expressions.some(function(expression) {
          return test(expression);
        });
      })) {
        return;
      }
      var nNode = node.expressions.find(function(expression) {
        return isMetaChar(expression, "\\n");
      });
      nNode.value = "\\s";
      nNode.symbol = void 0;
      nNode.codePoint = NaN;
      node.expressions.map(function(expression, i) {
        return whitespaceRangeTests.some(function(test) {
          return test(expression);
        }) ? path.getChild(i) : void 0;
      }).filter(Boolean).forEach(function(path2) {
        return path2.remove();
      });
    }
    function isFullNumberRange(node) {
      return node.type === "ClassRange" && node.from.value === "0" && node.to.value === "9";
    }
    function isChar(node, value) {
      var kind = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "simple";
      return node.type === "Char" && node.value === value && node.kind === kind;
    }
    function isMetaChar(node, value) {
      return isChar(node, value, "meta");
    }
    function isLowerCaseRange(node) {
      return node.type === "ClassRange" && node.from.value === "a" && node.to.value === "z";
    }
    function isUpperCaseRange(node) {
      return node.type === "ClassRange" && node.from.value === "A" && node.to.value === "Z";
    }
    function isUnderscore(node) {
      return node.type === "Char" && node.value === "_" && node.kind === "simple";
    }
    function isCodePoint(node, codePoint) {
      return node.type === "Char" && node.kind === "unicode" && node.codePoint === codePoint;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js
var require_char_class_to_single_char_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-to-single-char-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        if (node.expressions.length !== 1 || !hasAppropriateSiblings(path) || !isAppropriateChar(node.expressions[0])) {
          return;
        }
        var _node$expressions$ = node.expressions[0], value = _node$expressions$.value, kind = _node$expressions$.kind, escaped = _node$expressions$.escaped;
        if (node.negative) {
          if (!isMeta(value)) {
            return;
          }
          value = getInverseMeta(value);
        }
        path.replace({
          type: "Char",
          value,
          kind,
          escaped: escaped || shouldEscape(value)
        });
      }
    };
    function isAppropriateChar(node) {
      return node.type === "Char" && node.value !== "\\b";
    }
    function isMeta(value) {
      return /^\\[dwsDWS]$/.test(value);
    }
    function getInverseMeta(value) {
      return /[dws]/.test(value) ? value.toUpperCase() : value.toLowerCase();
    }
    function hasAppropriateSiblings(path) {
      var parent = path.parent, index = path.index;
      if (parent.type !== "Alternative") {
        return true;
      }
      var previousNode = parent.expressions[index - 1];
      if (previousNode == null) {
        return true;
      }
      if (previousNode.type === "Backreference" && previousNode.kind === "number") {
        return false;
      }
      if (previousNode.type === "Char" && previousNode.kind === "decimal") {
        return false;
      }
      return true;
    }
    function shouldEscape(value) {
      return /[*[()+?$./{}|]/.test(value);
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js
var require_char_escape_unescape_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-escape-unescape-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      _hasXFlag: false,
      init: function init(ast) {
        this._hasXFlag = ast.flags.includes("x");
      },
      Char: function Char(path) {
        var node = path.node;
        if (!node.escaped) {
          return;
        }
        if (shouldUnescape(path, this._hasXFlag)) {
          delete node.escaped;
        }
      }
    };
    function shouldUnescape(path, hasXFlag) {
      var value = path.node.value, index = path.index, parent = path.parent;
      if (parent.type !== "CharacterClass" && parent.type !== "ClassRange") {
        return !preservesEscape(value, index, parent, hasXFlag);
      }
      return !preservesInCharClass(value, index, parent);
    }
    function preservesInCharClass(value, index, parent) {
      if (value === "^") {
        return index === 0 && !parent.negative;
      }
      if (value === "-") {
        return true;
      }
      return /[\]\\]/.test(value);
    }
    function preservesEscape(value, index, parent, hasXFlag) {
      if (value === "{") {
        return preservesOpeningCurlyBraceEscape(index, parent);
      }
      if (value === "}") {
        return preservesClosingCurlyBraceEscape(index, parent);
      }
      if (hasXFlag && /[ #]/.test(value)) {
        return true;
      }
      return /[*[()+?^$./\\|]/.test(value);
    }
    function consumeNumbers(startIndex, parent, rtl) {
      var i = startIndex;
      var siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
      while (siblingNode && siblingNode.type === "Char" && siblingNode.kind === "simple" && !siblingNode.escaped && /\d/.test(siblingNode.value)) {
        rtl ? i-- : i++;
        siblingNode = (rtl ? i >= 0 : i < parent.expressions.length) && parent.expressions[i];
      }
      return Math.abs(startIndex - i);
    }
    function isSimpleChar(node, value) {
      return node && node.type === "Char" && node.kind === "simple" && !node.escaped && node.value === value;
    }
    function preservesOpeningCurlyBraceEscape(index, parent) {
      if (index == null) {
        return false;
      }
      var nbFollowingNumbers = consumeNumbers(index + 1, parent);
      var i = index + nbFollowingNumbers + 1;
      var nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
      if (nbFollowingNumbers) {
        if (isSimpleChar(nextSiblingNode, "}")) {
          return true;
        }
        if (isSimpleChar(nextSiblingNode, ",")) {
          nbFollowingNumbers = consumeNumbers(i + 1, parent);
          i = i + nbFollowingNumbers + 1;
          nextSiblingNode = i < parent.expressions.length && parent.expressions[i];
          return isSimpleChar(nextSiblingNode, "}");
        }
      }
      return false;
    }
    function preservesClosingCurlyBraceEscape(index, parent) {
      if (index == null) {
        return false;
      }
      var nbPrecedingNumbers = consumeNumbers(index - 1, parent, true);
      var i = index - nbPrecedingNumbers - 1;
      var previousSiblingNode = i >= 0 && parent.expressions[i];
      if (nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{")) {
        return true;
      }
      if (isSimpleChar(previousSiblingNode, ",")) {
        nbPrecedingNumbers = consumeNumbers(i - 1, parent, true);
        i = i - nbPrecedingNumbers - 1;
        previousSiblingNode = i < parent.expressions.length && parent.expressions[i];
        return nbPrecedingNumbers && isSimpleChar(previousSiblingNode, "{");
      }
      return false;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js
var require_char_class_classranges_merge_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/char-class-classranges-merge-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      _hasIUFlags: false,
      init: function init(ast) {
        this._hasIUFlags = ast.flags.includes("i") && ast.flags.includes("u");
      },
      CharacterClass: function CharacterClass(path) {
        var node = path.node;
        var expressions = node.expressions;
        var metas = [];
        expressions.forEach(function(expression2) {
          if (isMeta(expression2)) {
            metas.push(expression2.value);
          }
        });
        expressions.sort(sortCharClass);
        for (var i = 0; i < expressions.length; i++) {
          var expression = expressions[i];
          if (fitsInMetas(expression, metas, this._hasIUFlags) || combinesWithPrecedingClassRange(expression, expressions[i - 1]) || combinesWithFollowingClassRange(expression, expressions[i + 1])) {
            expressions.splice(i, 1);
            i--;
          } else {
            var nbMergedChars = charCombinesWithPrecedingChars(expression, i, expressions);
            expressions.splice(i - nbMergedChars + 1, nbMergedChars);
            i -= nbMergedChars;
          }
        }
      }
    };
    function sortCharClass(a, b) {
      var aValue = getSortValue(a);
      var bValue = getSortValue(b);
      if (aValue === bValue) {
        if (a.type === "ClassRange" && b.type !== "ClassRange") {
          return -1;
        }
        if (b.type === "ClassRange" && a.type !== "ClassRange") {
          return 1;
        }
        if (a.type === "ClassRange" && b.type === "ClassRange") {
          return getSortValue(a.to) - getSortValue(b.to);
        }
        if (isMeta(a) && isMeta(b) || isControl(a) && isControl(b)) {
          return a.value < b.value ? -1 : 1;
        }
      }
      return aValue - bValue;
    }
    function getSortValue(expression) {
      if (expression.type === "Char") {
        if (expression.value === "-") {
          return Infinity;
        }
        if (expression.kind === "control") {
          return Infinity;
        }
        if (expression.kind === "meta" && isNaN(expression.codePoint)) {
          return -1;
        }
        return expression.codePoint;
      }
      return expression.from.codePoint;
    }
    function isMeta(expression) {
      var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      return expression.type === "Char" && expression.kind === "meta" && (value ? expression.value === value : /^\\[dws]$/i.test(expression.value));
    }
    function isControl(expression) {
      return expression.type === "Char" && expression.kind === "control";
    }
    function fitsInMetas(expression, metas, hasIUFlags) {
      for (var i = 0; i < metas.length; i++) {
        if (fitsInMeta(expression, metas[i], hasIUFlags)) {
          return true;
        }
      }
      return false;
    }
    function fitsInMeta(expression, meta, hasIUFlags) {
      if (expression.type === "ClassRange") {
        return fitsInMeta(expression.from, meta, hasIUFlags) && fitsInMeta(expression.to, meta, hasIUFlags);
      }
      if (meta === "\\S" && (isMeta(expression, "\\w") || isMeta(expression, "\\d"))) {
        return true;
      }
      if (meta === "\\D" && (isMeta(expression, "\\W") || isMeta(expression, "\\s"))) {
        return true;
      }
      if (meta === "\\w" && isMeta(expression, "\\d")) {
        return true;
      }
      if (meta === "\\W" && isMeta(expression, "\\s")) {
        return true;
      }
      if (expression.type !== "Char" || isNaN(expression.codePoint)) {
        return false;
      }
      if (meta === "\\s") {
        return fitsInMetaS(expression);
      }
      if (meta === "\\S") {
        return !fitsInMetaS(expression);
      }
      if (meta === "\\d") {
        return fitsInMetaD(expression);
      }
      if (meta === "\\D") {
        return !fitsInMetaD(expression);
      }
      if (meta === "\\w") {
        return fitsInMetaW(expression, hasIUFlags);
      }
      if (meta === "\\W") {
        return !fitsInMetaW(expression, hasIUFlags);
      }
      return false;
    }
    function fitsInMetaS(expression) {
      return expression.codePoint === 9 || expression.codePoint === 10 || expression.codePoint === 11 || expression.codePoint === 12 || expression.codePoint === 13 || expression.codePoint === 32 || expression.codePoint === 160 || expression.codePoint === 5760 || expression.codePoint >= 8192 && expression.codePoint <= 8202 || expression.codePoint === 8232 || expression.codePoint === 8233 || expression.codePoint === 8239 || expression.codePoint === 8287 || expression.codePoint === 12288 || expression.codePoint === 65279;
    }
    function fitsInMetaD(expression) {
      return expression.codePoint >= 48 && expression.codePoint <= 57;
    }
    function fitsInMetaW(expression, hasIUFlags) {
      return fitsInMetaD(expression) || expression.codePoint >= 65 && expression.codePoint <= 90 || expression.codePoint >= 97 && expression.codePoint <= 122 || expression.value === "_" || hasIUFlags && (expression.codePoint === 383 || expression.codePoint === 8490);
    }
    function combinesWithPrecedingClassRange(expression, classRange) {
      if (classRange && classRange.type === "ClassRange") {
        if (fitsInClassRange(expression, classRange)) {
          return true;
        } else if (isMetaWCharOrCode(expression) && classRange.to.codePoint === expression.codePoint - 1) {
          classRange.to = expression;
          return true;
        } else if (expression.type === "ClassRange" && expression.from.codePoint <= classRange.to.codePoint + 1 && expression.to.codePoint >= classRange.from.codePoint - 1) {
          if (expression.from.codePoint < classRange.from.codePoint) {
            classRange.from = expression.from;
          }
          if (expression.to.codePoint > classRange.to.codePoint) {
            classRange.to = expression.to;
          }
          return true;
        }
      }
      return false;
    }
    function combinesWithFollowingClassRange(expression, classRange) {
      if (classRange && classRange.type === "ClassRange") {
        if (isMetaWCharOrCode(expression) && classRange.from.codePoint === expression.codePoint + 1) {
          classRange.from = expression;
          return true;
        }
      }
      return false;
    }
    function fitsInClassRange(expression, classRange) {
      if (expression.type === "Char" && isNaN(expression.codePoint)) {
        return false;
      }
      if (expression.type === "ClassRange") {
        return fitsInClassRange(expression.from, classRange) && fitsInClassRange(expression.to, classRange);
      }
      return expression.codePoint >= classRange.from.codePoint && expression.codePoint <= classRange.to.codePoint;
    }
    function charCombinesWithPrecedingChars(expression, index, expressions) {
      if (!isMetaWCharOrCode(expression)) {
        return 0;
      }
      var nbMergedChars = 0;
      while (index > 0) {
        var currentExpression = expressions[index];
        var precedingExpresion = expressions[index - 1];
        if (isMetaWCharOrCode(precedingExpresion) && precedingExpresion.codePoint === currentExpression.codePoint - 1) {
          nbMergedChars++;
          index--;
        } else {
          break;
        }
      }
      if (nbMergedChars > 1) {
        expressions[index] = {
          type: "ClassRange",
          from: expressions[index],
          to: expression
        };
        return nbMergedChars;
      }
      return 0;
    }
    function isMetaWCharOrCode(expression) {
      return expression && expression.type === "Char" && !isNaN(expression.codePoint) && (fitsInMetaW(expression, false) || expression.kind === "unicode" || expression.kind === "hex" || expression.kind === "oct" || expression.kind === "decimal");
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js
var require_disjunction_remove_duplicates_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/disjunction-remove-duplicates-transform.js"(exports2, module2) {
    "use strict";
    var NodePath = require_node_path();
    var _require = require_utils2();
    var disjunctionToList = _require.disjunctionToList;
    var listToDisjunction = _require.listToDisjunction;
    module2.exports = {
      Disjunction: function Disjunction(path) {
        var node = path.node;
        var uniqueNodesMap = {};
        var parts = disjunctionToList(node).filter(function(part) {
          var encoded = part ? NodePath.getForNode(part).jsonEncode() : "null";
          if (uniqueNodesMap.hasOwnProperty(encoded)) {
            return false;
          }
          uniqueNodesMap[encoded] = part;
          return true;
        });
        path.replace(listToDisjunction(parts));
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js
var require_group_single_chars_to_char_class = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/group-single-chars-to-char-class.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Disjunction: function Disjunction(path) {
        var node = path.node, parent = path.parent;
        if (!handlers[parent.type]) {
          return;
        }
        var charset = /* @__PURE__ */ new Map();
        if (!shouldProcess(node, charset) || !charset.size) {
          return;
        }
        var characterClass = {
          type: "CharacterClass",
          expressions: Array.from(charset.keys()).sort().map(function(key) {
            return charset.get(key);
          })
        };
        handlers[parent.type](path.getParent(), characterClass);
      }
    };
    var handlers = {
      RegExp: function RegExp2(path, characterClass) {
        var node = path.node;
        node.body = characterClass;
      },
      Group: function Group(path, characterClass) {
        var node = path.node;
        if (node.capturing) {
          node.expression = characterClass;
        } else {
          path.replace(characterClass);
        }
      }
    };
    function shouldProcess(expression, charset) {
      if (!expression) {
        return false;
      }
      var type = expression.type;
      if (type === "Disjunction") {
        var left = expression.left, right = expression.right;
        return shouldProcess(left, charset) && shouldProcess(right, charset);
      } else if (type === "Char") {
        var value = expression.value;
        charset.set(value, expression);
        return true;
      } else if (type === "CharacterClass" && !expression.negative) {
        return expression.expressions.every(function(expression2) {
          return shouldProcess(expression2, charset);
        });
      }
      return false;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js
var require_remove_empty_group_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/remove-empty-group-transform.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      Group: function Group(path) {
        var node = path.node, parent = path.parent;
        var childPath = path.getChild();
        if (node.capturing || childPath) {
          return;
        }
        if (parent.type === "Repetition") {
          path.getParent().replace(node);
        } else if (parent.type !== "RegExp") {
          path.remove();
        }
      }
    };
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js
var require_ungroup_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/ungroup-transform.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module2.exports = {
      Group: function Group(path) {
        var node = path.node, parent = path.parent;
        var childPath = path.getChild();
        if (node.capturing || !childPath) {
          return;
        }
        if (!hasAppropriateSiblings(path)) {
          return;
        }
        if (childPath.node.type === "Disjunction" && parent.type !== "RegExp") {
          return;
        }
        if (parent.type === "Repetition" && childPath.node.type !== "Char" && childPath.node.type !== "CharacterClass") {
          return;
        }
        if (childPath.node.type === "Alternative") {
          var parentPath = path.getParent();
          if (parentPath.node.type === "Alternative") {
            parentPath.replace({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(parent.expressions.slice(0, path.index)), _toConsumableArray(childPath.node.expressions), _toConsumableArray(parent.expressions.slice(path.index + 1)))
            });
          }
        } else {
          path.replace(childPath.node);
        }
      }
    };
    function hasAppropriateSiblings(path) {
      var parent = path.parent, index = path.index;
      if (parent.type !== "Alternative") {
        return true;
      }
      var previousNode = parent.expressions[index - 1];
      if (previousNode == null) {
        return true;
      }
      if (previousNode.type === "Backreference" && previousNode.kind === "number") {
        return false;
      }
      if (previousNode.type === "Char" && previousNode.kind === "decimal") {
        return false;
      }
      return true;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js
var require_combine_repeating_patterns_transform = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/combine-repeating-patterns-transform.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var NodePath = require_node_path();
    var _require = require_utils2();
    var increaseQuantifierByOne = _require.increaseQuantifierByOne;
    module2.exports = {
      Alternative: function Alternative(path) {
        var node = path.node;
        var index = 1;
        while (index < node.expressions.length) {
          var child = path.getChild(index);
          index = Math.max(1, combineRepeatingPatternLeft(path, child, index));
          if (index >= node.expressions.length) {
            break;
          }
          child = path.getChild(index);
          index = Math.max(1, combineWithPreviousRepetition(path, child, index));
          if (index >= node.expressions.length) {
            break;
          }
          child = path.getChild(index);
          index = Math.max(1, combineRepetitionWithPrevious(path, child, index));
          index++;
        }
      }
    };
    function combineRepeatingPatternLeft(alternative, child, index) {
      var node = alternative.node;
      var nbPossibleLengths = Math.ceil(index / 2);
      var i = 0;
      while (i < nbPossibleLengths) {
        var startIndex = index - 2 * i - 1;
        var right = void 0, left = void 0;
        if (i === 0) {
          right = child;
          left = alternative.getChild(startIndex);
        } else {
          right = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(index - i, index)), [child.node])
          });
          left = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(startIndex, index - i)))
          });
        }
        if (right.hasEqualSource(left)) {
          for (var j = 0; j < 2 * i + 1; j++) {
            alternative.getChild(startIndex).remove();
          }
          child.replace({
            type: "Repetition",
            expression: i === 0 && right.node.type !== "Repetition" ? right.node : {
              type: "Group",
              capturing: false,
              expression: right.node
            },
            quantifier: {
              type: "Quantifier",
              kind: "Range",
              from: 2,
              to: 2,
              greedy: true
            }
          });
          return startIndex;
        }
        i++;
      }
      return index;
    }
    function combineWithPreviousRepetition(alternative, child, index) {
      var node = alternative.node;
      var i = 0;
      while (i < index) {
        var previousChild = alternative.getChild(i);
        if (previousChild.node.type === "Repetition" && previousChild.node.quantifier.greedy) {
          var left = previousChild.getChild();
          var right = void 0;
          if (left.node.type === "Group" && !left.node.capturing) {
            left = left.getChild();
          }
          if (i + 1 === index) {
            right = child;
            if (right.node.type === "Group" && !right.node.capturing) {
              right = right.getChild();
            }
          } else {
            right = NodePath.getForNode({
              type: "Alternative",
              expressions: [].concat(_toConsumableArray(node.expressions.slice(i + 1, index + 1)))
            });
          }
          if (left.hasEqualSource(right)) {
            for (var j = i; j < index; j++) {
              alternative.getChild(i + 1).remove();
            }
            increaseQuantifierByOne(previousChild.node.quantifier);
            return i;
          }
        }
        i++;
      }
      return index;
    }
    function combineRepetitionWithPrevious(alternative, child, index) {
      var node = alternative.node;
      if (child.node.type === "Repetition" && child.node.quantifier.greedy) {
        var right = child.getChild();
        var left = void 0;
        if (right.node.type === "Group" && !right.node.capturing) {
          right = right.getChild();
        }
        var rightLength = void 0;
        if (right.node.type === "Alternative") {
          rightLength = right.node.expressions.length;
          left = NodePath.getForNode({
            type: "Alternative",
            expressions: [].concat(_toConsumableArray(node.expressions.slice(index - rightLength, index)))
          });
        } else {
          rightLength = 1;
          left = alternative.getChild(index - 1);
          if (left.node.type === "Group" && !left.node.capturing) {
            left = left.getChild();
          }
        }
        if (left.hasEqualSource(right)) {
          for (var j = index - rightLength; j < index; j++) {
            alternative.getChild(index - rightLength).remove();
          }
          increaseQuantifierByOne(child.node.quantifier);
          return index - rightLength;
        }
      }
      return index;
    }
  }
});

// node_modules/regexp-tree/dist/optimizer/transforms/index.js
var require_transforms2 = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/transforms/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ new Map([
      ["charSurrogatePairToSingleUnicode", require_char_surrogate_pair_to_single_unicode_transform()],
      ["charCodeToSimpleChar", require_char_code_to_simple_char_transform()],
      ["charCaseInsensitiveLowerCaseTransform", require_char_case_insensitive_lowercase_transform()],
      ["charClassRemoveDuplicates", require_char_class_remove_duplicates_transform()],
      ["quantifiersMerge", require_quantifiers_merge_transform()],
      ["quantifierRangeToSymbol", require_quantifier_range_to_symbol_transform()],
      ["charClassClassrangesToChars", require_char_class_classranges_to_chars_transform()],
      ["charClassToMeta", require_char_class_to_meta_transform()],
      ["charClassToSingleChar", require_char_class_to_single_char_transform()],
      ["charEscapeUnescape", require_char_escape_unescape_transform()],
      ["charClassClassrangesMerge", require_char_class_classranges_merge_transform()],
      ["disjunctionRemoveDuplicates", require_disjunction_remove_duplicates_transform()],
      ["groupSingleCharsToCharClass", require_group_single_chars_to_char_class()],
      ["removeEmptyGroup", require_remove_empty_group_transform()],
      ["ungroup", require_ungroup_transform()],
      ["combineRepeatingPatterns", require_combine_repeating_patterns_transform()]
    ]);
  }
});

// node_modules/regexp-tree/dist/optimizer/index.js
var require_optimizer = __commonJS({
  "node_modules/regexp-tree/dist/optimizer/index.js"(exports2, module2) {
    "use strict";
    var clone = require_clone();
    var parser = require_parser();
    var transform = require_transform();
    var optimizationTransforms = require_transforms2();
    module2.exports = {
      optimize: function optimize(regexp) {
        var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$whitelist = _ref.whitelist, whitelist = _ref$whitelist === void 0 ? [] : _ref$whitelist, _ref$blacklist = _ref.blacklist, blacklist = _ref$blacklist === void 0 ? [] : _ref$blacklist;
        var transformsRaw = whitelist.length > 0 ? whitelist : Array.from(optimizationTransforms.keys());
        var transformToApply = transformsRaw.filter(function(transform2) {
          return !blacklist.includes(transform2);
        });
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser.parse(regexp);
        }
        var result = new transform.TransformResult(ast);
        var prevResultString = void 0;
        do {
          prevResultString = result.toString();
          ast = clone(result.getAST());
          transformToApply.forEach(function(transformName) {
            if (!optimizationTransforms.has(transformName)) {
              throw new Error("Unknown optimization-transform: " + transformName + ". Available transforms are: " + Array.from(optimizationTransforms.keys()).join(", "));
            }
            var transformer = optimizationTransforms.get(transformName);
            var newResult = transform.transform(ast, transformer);
            if (newResult.toString() !== result.toString()) {
              if (newResult.toString().length <= result.toString().length) {
                result = newResult;
              } else {
                ast = clone(result.getAST());
              }
            }
          });
        } while (result.toString() !== prevResultString);
        return result;
      }
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js
var require_special_symbols = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/special-symbols.js"(exports2, module2) {
    "use strict";
    var EPSILON = "\u03B5";
    var EPSILON_CLOSURE = EPSILON + "*";
    module2.exports = {
      EPSILON,
      EPSILON_CLOSURE
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js
var require_nfa = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa.js"(exports2, module2) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
    var NFA = function() {
      function NFA2(inState, outState) {
        _classCallCheck(this, NFA2);
        this.in = inState;
        this.out = outState;
      }
      _createClass(NFA2, [{
        key: "matches",
        value: function matches(string) {
          return this.in.matches(string);
        }
      }, {
        key: "getAlphabet",
        value: function getAlphabet() {
          if (!this._alphabet) {
            this._alphabet = /* @__PURE__ */ new Set();
            var table = this.getTransitionTable();
            for (var state in table) {
              var transitions = table[state];
              for (var symbol in transitions) {
                if (symbol !== EPSILON_CLOSURE) {
                  this._alphabet.add(symbol);
                }
              }
            }
          }
          return this._alphabet;
        }
      }, {
        key: "getAcceptingStates",
        value: function getAcceptingStates() {
          if (!this._acceptingStates) {
            this.getTransitionTable();
          }
          return this._acceptingStates;
        }
      }, {
        key: "getAcceptingStateNumbers",
        value: function getAcceptingStateNumbers() {
          if (!this._acceptingStateNumbers) {
            this._acceptingStateNumbers = /* @__PURE__ */ new Set();
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.getAcceptingStates()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var acceptingState = _step.value;
                this._acceptingStateNumbers.add(acceptingState.number);
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }
          return this._acceptingStateNumbers;
        }
      }, {
        key: "getTransitionTable",
        value: function getTransitionTable() {
          var _this = this;
          if (!this._transitionTable) {
            this._transitionTable = {};
            this._acceptingStates = /* @__PURE__ */ new Set();
            var visited = /* @__PURE__ */ new Set();
            var symbols = /* @__PURE__ */ new Set();
            var visitState = function visitState2(state) {
              if (visited.has(state)) {
                return;
              }
              visited.add(state);
              state.number = visited.size;
              _this._transitionTable[state.number] = {};
              if (state.accepting) {
                _this._acceptingStates.add(state);
              }
              var transitions = state.getTransitions();
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = void 0;
              try {
                for (var _iterator2 = transitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  var _ref = _step2.value;
                  var _ref2 = _slicedToArray(_ref, 2);
                  var symbol = _ref2[0];
                  var symbolTransitions = _ref2[1];
                  var combinedState = [];
                  symbols.add(symbol);
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = void 0;
                  try {
                    for (var _iterator3 = symbolTransitions[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var nextState = _step3.value;
                      visitState2(nextState);
                      combinedState.push(nextState.number);
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                  _this._transitionTable[state.number][symbol] = combinedState;
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            };
            visitState(this.in);
            visited.forEach(function(state) {
              delete _this._transitionTable[state.number][EPSILON];
              _this._transitionTable[state.number][EPSILON_CLOSURE] = [].concat(_toConsumableArray(state.getEpsilonClosure())).map(function(s) {
                return s.number;
              });
            });
          }
          return this._transitionTable;
        }
      }]);
      return NFA2;
    }();
    module2.exports = NFA;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js
var require_dfa_minimizer = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa-minimizer.js"(exports2, module2) {
    "use strict";
    var _slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    function _toArray(arr) {
      return Array.isArray(arr) ? arr : Array.from(arr);
    }
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var currentTransitionMap = null;
    function minimize(dfa) {
      var table = dfa.getTransitionTable();
      var allStates = Object.keys(table);
      var alphabet = dfa.getAlphabet();
      var accepting = dfa.getAcceptingStateNumbers();
      currentTransitionMap = {};
      var nonAccepting = /* @__PURE__ */ new Set();
      allStates.forEach(function(state) {
        state = Number(state);
        var isAccepting = accepting.has(state);
        if (isAccepting) {
          currentTransitionMap[state] = accepting;
        } else {
          nonAccepting.add(state);
          currentTransitionMap[state] = nonAccepting;
        }
      });
      var all = [
        [nonAccepting, accepting].filter(function(set2) {
          return set2.size > 0;
        })
      ];
      var current = void 0;
      var previous = void 0;
      current = all[all.length - 1];
      previous = all[all.length - 2];
      var _loop = function _loop2() {
        var newTransitionMap = {};
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = current[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _set = _step3.value;
            var handledStates = {};
            var _set2 = _toArray(_set), first = _set2[0], rest = _set2.slice(1);
            handledStates[first] = /* @__PURE__ */ new Set([first]);
            var _iteratorNormalCompletion4 = true;
            var _didIteratorError4 = false;
            var _iteratorError4 = void 0;
            try {
              restSets:
                for (var _iterator4 = rest[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var state = _step4.value;
                  var _iteratorNormalCompletion5 = true;
                  var _didIteratorError5 = false;
                  var _iteratorError5 = void 0;
                  try {
                    for (var _iterator5 = Object.keys(handledStates)[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
                      var handledState = _step5.value;
                      if (areEquivalent(state, handledState, table, alphabet)) {
                        handledStates[handledState].add(state);
                        handledStates[state] = handledStates[handledState];
                        continue restSets;
                      }
                    }
                  } catch (err) {
                    _didIteratorError5 = true;
                    _iteratorError5 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion5 && _iterator5.return) {
                        _iterator5.return();
                      }
                    } finally {
                      if (_didIteratorError5) {
                        throw _iteratorError5;
                      }
                    }
                  }
                  handledStates[state] = /* @__PURE__ */ new Set([state]);
                }
            } catch (err) {
              _didIteratorError4 = true;
              _iteratorError4 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion4 && _iterator4.return) {
                  _iterator4.return();
                }
              } finally {
                if (_didIteratorError4) {
                  throw _iteratorError4;
                }
              }
            }
            Object.assign(newTransitionMap, handledStates);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        currentTransitionMap = newTransitionMap;
        var newSets = new Set(Object.keys(newTransitionMap).map(function(state2) {
          return newTransitionMap[state2];
        }));
        all.push([].concat(_toConsumableArray(newSets)));
        current = all[all.length - 1];
        previous = all[all.length - 2];
      };
      while (!sameRow(current, previous)) {
        _loop();
      }
      var remaped = /* @__PURE__ */ new Map();
      var idx = 1;
      current.forEach(function(set2) {
        return remaped.set(set2, idx++);
      });
      var minimizedTable = {};
      var minimizedAcceptingStates = /* @__PURE__ */ new Set();
      var updateAcceptingStates = function updateAcceptingStates2(set2, idx2) {
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = void 0;
        try {
          for (var _iterator = set2[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var state = _step.value;
            if (accepting.has(state)) {
              minimizedAcceptingStates.add(idx2);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }
      };
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = remaped.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var _ref = _step2.value;
          var _ref2 = _slicedToArray(_ref, 2);
          var set = _ref2[0];
          var _idx = _ref2[1];
          minimizedTable[_idx] = {};
          var _iteratorNormalCompletion6 = true;
          var _didIteratorError6 = false;
          var _iteratorError6 = void 0;
          try {
            for (var _iterator6 = alphabet[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {
              var symbol = _step6.value;
              updateAcceptingStates(set, _idx);
              var originalTransition = void 0;
              var _iteratorNormalCompletion7 = true;
              var _didIteratorError7 = false;
              var _iteratorError7 = void 0;
              try {
                for (var _iterator7 = set[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {
                  var originalState = _step7.value;
                  originalTransition = table[originalState][symbol];
                  if (originalTransition) {
                    break;
                  }
                }
              } catch (err) {
                _didIteratorError7 = true;
                _iteratorError7 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion7 && _iterator7.return) {
                    _iterator7.return();
                  }
                } finally {
                  if (_didIteratorError7) {
                    throw _iteratorError7;
                  }
                }
              }
              if (originalTransition) {
                minimizedTable[_idx][symbol] = remaped.get(currentTransitionMap[originalTransition]);
              }
            }
          } catch (err) {
            _didIteratorError6 = true;
            _iteratorError6 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion6 && _iterator6.return) {
                _iterator6.return();
              }
            } finally {
              if (_didIteratorError6) {
                throw _iteratorError6;
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      dfa.setTransitionTable(minimizedTable);
      dfa.setAcceptingStateNumbers(minimizedAcceptingStates);
      return dfa;
    }
    function sameRow(r1, r2) {
      if (!r2) {
        return false;
      }
      if (r1.length !== r2.length) {
        return false;
      }
      for (var i = 0; i < r1.length; i++) {
        var s1 = r1[i];
        var s2 = r2[i];
        if (s1.size !== s2.size) {
          return false;
        }
        if ([].concat(_toConsumableArray(s1)).sort().join(",") !== [].concat(_toConsumableArray(s2)).sort().join(",")) {
          return false;
        }
      }
      return true;
    }
    function areEquivalent(s1, s2, table, alphabet) {
      var _iteratorNormalCompletion8 = true;
      var _didIteratorError8 = false;
      var _iteratorError8 = void 0;
      try {
        for (var _iterator8 = alphabet[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {
          var symbol = _step8.value;
          if (!goToSameSet(s1, s2, table, symbol)) {
            return false;
          }
        }
      } catch (err) {
        _didIteratorError8 = true;
        _iteratorError8 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion8 && _iterator8.return) {
            _iterator8.return();
          }
        } finally {
          if (_didIteratorError8) {
            throw _iteratorError8;
          }
        }
      }
      return true;
    }
    function goToSameSet(s1, s2, table, symbol) {
      if (!currentTransitionMap[s1] || !currentTransitionMap[s2]) {
        return false;
      }
      var originalTransitionS1 = table[s1][symbol];
      var originalTransitionS2 = table[s2][symbol];
      if (!originalTransitionS1 && !originalTransitionS2) {
        return true;
      }
      return currentTransitionMap[s1].has(originalTransitionS1) && currentTransitionMap[s2].has(originalTransitionS2);
    }
    module2.exports = {
      minimize
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js
var require_dfa = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/dfa/dfa.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var DFAMinimizer = require_dfa_minimizer();
    var _require = require_special_symbols();
    var EPSILON_CLOSURE = _require.EPSILON_CLOSURE;
    var DFA = function() {
      function DFA2(nfa) {
        _classCallCheck(this, DFA2);
        this._nfa = nfa;
      }
      _createClass(DFA2, [{
        key: "minimize",
        value: function minimize() {
          this.getTransitionTable();
          this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
          this._originalTransitionTable = this._transitionTable;
          DFAMinimizer.minimize(this);
        }
      }, {
        key: "getAlphabet",
        value: function getAlphabet() {
          return this._nfa.getAlphabet();
        }
      }, {
        key: "getAcceptingStateNumbers",
        value: function getAcceptingStateNumbers() {
          if (!this._acceptingStateNumbers) {
            this.getTransitionTable();
          }
          return this._acceptingStateNumbers;
        }
      }, {
        key: "getOriginaAcceptingStateNumbers",
        value: function getOriginaAcceptingStateNumbers() {
          if (!this._originalAcceptingStateNumbers) {
            this.getTransitionTable();
          }
          return this._originalAcceptingStateNumbers;
        }
      }, {
        key: "setTransitionTable",
        value: function setTransitionTable(table) {
          this._transitionTable = table;
        }
      }, {
        key: "setAcceptingStateNumbers",
        value: function setAcceptingStateNumbers(stateNumbers) {
          this._acceptingStateNumbers = stateNumbers;
        }
      }, {
        key: "getTransitionTable",
        value: function getTransitionTable() {
          var _this = this;
          if (this._transitionTable) {
            return this._transitionTable;
          }
          var nfaTable = this._nfa.getTransitionTable();
          var nfaStates = Object.keys(nfaTable);
          this._acceptingStateNumbers = /* @__PURE__ */ new Set();
          var startState = nfaTable[nfaStates[0]][EPSILON_CLOSURE];
          var worklist = [startState];
          var alphabet = this.getAlphabet();
          var nfaAcceptingStates = this._nfa.getAcceptingStateNumbers();
          var dfaTable = {};
          var updateAcceptingStates = function updateAcceptingStates2(states2) {
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = nfaAcceptingStates[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var nfaAcceptingState = _step.value;
                if (states2.indexOf(nfaAcceptingState) !== -1) {
                  _this._acceptingStateNumbers.add(states2.join(","));
                  break;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          };
          while (worklist.length > 0) {
            var states = worklist.shift();
            var dfaStateLabel = states.join(",");
            dfaTable[dfaStateLabel] = {};
            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = void 0;
            try {
              for (var _iterator2 = alphabet[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var symbol = _step2.value;
                var onSymbol = [];
                updateAcceptingStates(states);
                var _iteratorNormalCompletion3 = true;
                var _didIteratorError3 = false;
                var _iteratorError3 = void 0;
                try {
                  for (var _iterator3 = states[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                    var state = _step3.value;
                    var nfaStatesOnSymbol = nfaTable[state][symbol];
                    if (!nfaStatesOnSymbol) {
                      continue;
                    }
                    var _iteratorNormalCompletion4 = true;
                    var _didIteratorError4 = false;
                    var _iteratorError4 = void 0;
                    try {
                      for (var _iterator4 = nfaStatesOnSymbol[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                        var nfaStateOnSymbol = _step4.value;
                        if (!nfaTable[nfaStateOnSymbol]) {
                          continue;
                        }
                        onSymbol.push.apply(onSymbol, _toConsumableArray(nfaTable[nfaStateOnSymbol][EPSILON_CLOSURE]));
                      }
                    } catch (err) {
                      _didIteratorError4 = true;
                      _iteratorError4 = err;
                    } finally {
                      try {
                        if (!_iteratorNormalCompletion4 && _iterator4.return) {
                          _iterator4.return();
                        }
                      } finally {
                        if (_didIteratorError4) {
                          throw _iteratorError4;
                        }
                      }
                    }
                  }
                } catch (err) {
                  _didIteratorError3 = true;
                  _iteratorError3 = err;
                } finally {
                  try {
                    if (!_iteratorNormalCompletion3 && _iterator3.return) {
                      _iterator3.return();
                    }
                  } finally {
                    if (_didIteratorError3) {
                      throw _iteratorError3;
                    }
                  }
                }
                var dfaStatesOnSymbolSet = new Set(onSymbol);
                var dfaStatesOnSymbol = [].concat(_toConsumableArray(dfaStatesOnSymbolSet));
                if (dfaStatesOnSymbol.length > 0) {
                  var dfaOnSymbolStr = dfaStatesOnSymbol.join(",");
                  dfaTable[dfaStateLabel][symbol] = dfaOnSymbolStr;
                  if (!dfaTable.hasOwnProperty(dfaOnSymbolStr)) {
                    worklist.unshift(dfaStatesOnSymbol);
                  }
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
          return this._transitionTable = this._remapStateNumbers(dfaTable);
        }
      }, {
        key: "_remapStateNumbers",
        value: function _remapStateNumbers(calculatedDFATable) {
          var newStatesMap = {};
          this._originalTransitionTable = calculatedDFATable;
          var transitionTable = {};
          Object.keys(calculatedDFATable).forEach(function(originalNumber2, newNumber) {
            newStatesMap[originalNumber2] = newNumber + 1;
          });
          for (var originalNumber in calculatedDFATable) {
            var originalRow = calculatedDFATable[originalNumber];
            var row = {};
            for (var symbol in originalRow) {
              row[symbol] = newStatesMap[originalRow[symbol]];
            }
            transitionTable[newStatesMap[originalNumber]] = row;
          }
          this._originalAcceptingStateNumbers = this._acceptingStateNumbers;
          this._acceptingStateNumbers = /* @__PURE__ */ new Set();
          var _iteratorNormalCompletion5 = true;
          var _didIteratorError5 = false;
          var _iteratorError5 = void 0;
          try {
            for (var _iterator5 = this._originalAcceptingStateNumbers[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {
              var _originalNumber = _step5.value;
              this._acceptingStateNumbers.add(newStatesMap[_originalNumber]);
            }
          } catch (err) {
            _didIteratorError5 = true;
            _iteratorError5 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion5 && _iterator5.return) {
                _iterator5.return();
              }
            } finally {
              if (_didIteratorError5) {
                throw _iteratorError5;
              }
            }
          }
          return transitionTable;
        }
      }, {
        key: "getOriginalTransitionTable",
        value: function getOriginalTransitionTable() {
          if (!this._originalTransitionTable) {
            this.getTransitionTable();
          }
          return this._originalTransitionTable;
        }
      }, {
        key: "matches",
        value: function matches(string) {
          var state = 1;
          var i = 0;
          var table = this.getTransitionTable();
          while (string[i]) {
            state = table[state][string[i++]];
            if (!state) {
              return false;
            }
          }
          if (!this.getAcceptingStateNumbers().has(state)) {
            return false;
          }
          return true;
        }
      }]);
      return DFA2;
    }();
    module2.exports = DFA;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js
var require_state = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/state.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var State = function() {
      function State2() {
        var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$accepting = _ref.accepting, accepting = _ref$accepting === void 0 ? false : _ref$accepting;
        _classCallCheck(this, State2);
        this._transitions = /* @__PURE__ */ new Map();
        this.accepting = accepting;
      }
      _createClass(State2, [{
        key: "getTransitions",
        value: function getTransitions() {
          return this._transitions;
        }
      }, {
        key: "addTransition",
        value: function addTransition(symbol, toState) {
          this.getTransitionsOnSymbol(symbol).add(toState);
          return this;
        }
      }, {
        key: "getTransitionsOnSymbol",
        value: function getTransitionsOnSymbol(symbol) {
          var transitions = this._transitions.get(symbol);
          if (!transitions) {
            transitions = /* @__PURE__ */ new Set();
            this._transitions.set(symbol, transitions);
          }
          return transitions;
        }
      }]);
      return State2;
    }();
    module2.exports = State;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js
var require_nfa_state = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-state.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var State = require_state();
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    var NFAState = function(_State) {
      _inherits(NFAState2, _State);
      function NFAState2() {
        _classCallCheck(this, NFAState2);
        return _possibleConstructorReturn(this, (NFAState2.__proto__ || Object.getPrototypeOf(NFAState2)).apply(this, arguments));
      }
      _createClass(NFAState2, [{
        key: "matches",
        value: function matches(string) {
          var visited = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : /* @__PURE__ */ new Set();
          if (visited.has(this)) {
            return false;
          }
          visited.add(this);
          if (string.length === 0) {
            if (this.accepting) {
              return true;
            }
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = void 0;
            try {
              for (var _iterator = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                var nextState = _step.value;
                if (nextState.matches("", visited)) {
                  return true;
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
            return false;
          }
          var symbol = string[0];
          var rest = string.slice(1);
          var symbolTransitions = this.getTransitionsOnSymbol(symbol);
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = void 0;
          try {
            for (var _iterator2 = symbolTransitions[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var _nextState = _step2.value;
              if (_nextState.matches(rest)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = void 0;
          try {
            for (var _iterator3 = this.getTransitionsOnSymbol(EPSILON)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var _nextState2 = _step3.value;
              if (_nextState2.matches(string, visited)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }
          return false;
        }
      }, {
        key: "getEpsilonClosure",
        value: function getEpsilonClosure() {
          var _this2 = this;
          if (!this._epsilonClosure) {
            (function() {
              var epsilonTransitions = _this2.getTransitionsOnSymbol(EPSILON);
              var closure = _this2._epsilonClosure = /* @__PURE__ */ new Set();
              closure.add(_this2);
              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = void 0;
              try {
                for (var _iterator4 = epsilonTransitions[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var nextState = _step4.value;
                  if (!closure.has(nextState)) {
                    closure.add(nextState);
                    var nextClosure = nextState.getEpsilonClosure();
                    nextClosure.forEach(function(state) {
                      return closure.add(state);
                    });
                  }
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            })();
          }
          return this._epsilonClosure;
        }
      }]);
      return NFAState2;
    }(State);
    module2.exports = NFAState;
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js
var require_builders = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/builders.js"(exports2, module2) {
    "use strict";
    var NFA = require_nfa();
    var NFAState = require_nfa_state();
    var _require = require_special_symbols();
    var EPSILON = _require.EPSILON;
    function char(c) {
      var inState = new NFAState();
      var outState = new NFAState({
        accepting: true
      });
      return new NFA(inState.addTransition(c, outState), outState);
    }
    function e() {
      return char(EPSILON);
    }
    function altPair(first, second) {
      first.out.accepting = false;
      second.out.accepting = true;
      first.out.addTransition(EPSILON, second.in);
      return new NFA(first.in, second.out);
    }
    function alt(first) {
      for (var _len = arguments.length, fragments = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        fragments[_key - 1] = arguments[_key];
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = fragments[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var fragment = _step.value;
          first = altPair(first, fragment);
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return first;
    }
    function orPair(first, second) {
      var inState = new NFAState();
      var outState = new NFAState();
      inState.addTransition(EPSILON, first.in);
      inState.addTransition(EPSILON, second.in);
      outState.accepting = true;
      first.out.accepting = false;
      second.out.accepting = false;
      first.out.addTransition(EPSILON, outState);
      second.out.addTransition(EPSILON, outState);
      return new NFA(inState, outState);
    }
    function or(first) {
      for (var _len2 = arguments.length, fragments = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        fragments[_key2 - 1] = arguments[_key2];
      }
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = void 0;
      try {
        for (var _iterator2 = fragments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var fragment = _step2.value;
          first = orPair(first, fragment);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
      return first;
    }
    function repExplicit(fragment) {
      var inState = new NFAState();
      var outState = new NFAState({
        accepting: true
      });
      inState.addTransition(EPSILON, fragment.in);
      inState.addTransition(EPSILON, outState);
      fragment.out.accepting = false;
      fragment.out.addTransition(EPSILON, outState);
      outState.addTransition(EPSILON, fragment.in);
      return new NFA(inState, outState);
    }
    function rep(fragment) {
      fragment.in.addTransition(EPSILON, fragment.out);
      fragment.out.addTransition(EPSILON, fragment.in);
      return fragment;
    }
    function plusRep(fragment) {
      fragment.out.addTransition(EPSILON, fragment.in);
      return fragment;
    }
    function questionRep(fragment) {
      fragment.in.addTransition(EPSILON, fragment.out);
      return fragment;
    }
    module2.exports = {
      alt,
      char,
      e,
      or,
      rep,
      repExplicit,
      plusRep,
      questionRep
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js
var require_nfa_from_regexp = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/nfa/nfa-from-regexp.js"(exports2, module2) {
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    var parser = require_parser();
    var _require = require_builders();
    var alt = _require.alt;
    var char = _require.char;
    var or = _require.or;
    var rep = _require.rep;
    var plusRep = _require.plusRep;
    var questionRep = _require.questionRep;
    function gen(node) {
      if (node && !generator[node.type]) {
        throw new Error(node.type + " is not supported in NFA/DFA interpreter.");
      }
      return node ? generator[node.type](node) : "";
    }
    var generator = {
      RegExp: function RegExp2(node) {
        if (node.flags !== "") {
          throw new Error("NFA/DFA: Flags are not supported yet.");
        }
        return gen(node.body);
      },
      Alternative: function Alternative(node) {
        var fragments = (node.expressions || []).map(gen);
        return alt.apply(void 0, _toConsumableArray(fragments));
      },
      Disjunction: function Disjunction(node) {
        return or(gen(node.left), gen(node.right));
      },
      Repetition: function Repetition(node) {
        switch (node.quantifier.kind) {
          case "*":
            return rep(gen(node.expression));
          case "+":
            return plusRep(gen(node.expression));
          case "?":
            return questionRep(gen(node.expression));
          default:
            throw new Error("Unknown repeatition: " + node.quantifier.kind + ".");
        }
      },
      Char: function Char(node) {
        if (node.kind !== "simple") {
          throw new Error("NFA/DFA: Only simple chars are supported yet.");
        }
        return char(node.value);
      },
      Group: function Group(node) {
        return gen(node.expression);
      }
    };
    module2.exports = {
      build: function build(regexp) {
        var ast = regexp;
        if (regexp instanceof RegExp) {
          regexp = "" + regexp;
        }
        if (typeof regexp === "string") {
          ast = parser.parse(regexp, {
            captureLocations: true
          });
        }
        return gen(ast);
      }
    };
  }
});

// node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js
var require_finite_automaton = __commonJS({
  "node_modules/regexp-tree/dist/interpreter/finite-automaton/index.js"(exports2, module2) {
    "use strict";
    var NFA = require_nfa();
    var DFA = require_dfa();
    var nfaFromRegExp = require_nfa_from_regexp();
    var builders = require_builders();
    module2.exports = {
      NFA,
      DFA,
      builders,
      toNFA: function toNFA(regexp) {
        return nfaFromRegExp.build(regexp);
      },
      toDFA: function toDFA(regexp) {
        return new DFA(this.toNFA(regexp));
      },
      test: function test(regexp, string) {
        return this.toDFA(regexp).matches(string);
      }
    };
  }
});

// node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js
var require_runtime = __commonJS({
  "node_modules/regexp-tree/dist/compat-transpiler/runtime/index.js"(exports2, module2) {
    "use strict";
    var _createClass = function() {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor)
            descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }
      return function(Constructor, protoProps, staticProps) {
        if (protoProps)
          defineProperties(Constructor.prototype, protoProps);
        if (staticProps)
          defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var RegExpTree = function() {
      function RegExpTree2(re, _ref) {
        var flags = _ref.flags, groups = _ref.groups, source = _ref.source;
        _classCallCheck(this, RegExpTree2);
        this._re = re;
        this._groups = groups;
        this.flags = flags;
        this.source = source || re.source;
        this.dotAll = flags.includes("s");
        this.global = re.global;
        this.ignoreCase = re.ignoreCase;
        this.multiline = re.multiline;
        this.sticky = re.sticky;
        this.unicode = re.unicode;
      }
      _createClass(RegExpTree2, [{
        key: "test",
        value: function test(string) {
          return this._re.test(string);
        }
      }, {
        key: "compile",
        value: function compile(string) {
          return this._re.compile(string);
        }
      }, {
        key: "toString",
        value: function toString() {
          if (!this._toStringResult) {
            this._toStringResult = "/" + this.source + "/" + this.flags;
          }
          return this._toStringResult;
        }
      }, {
        key: "exec",
        value: function exec(string) {
          var result = this._re.exec(string);
          if (!this._groups || !result) {
            return result;
          }
          result.groups = {};
          for (var group in this._groups) {
            var groupNumber = this._groups[group];
            result.groups[group] = result[groupNumber];
          }
          return result;
        }
      }]);
      return RegExpTree2;
    }();
    module2.exports = {
      RegExpTree
    };
  }
});

// node_modules/regexp-tree/dist/regexp-tree.js
var require_regexp_tree2 = __commonJS({
  "node_modules/regexp-tree/dist/regexp-tree.js"(exports2, module2) {
    "use strict";
    var compatTranspiler = require_compat_transpiler();
    var generator = require_generator();
    var optimizer = require_optimizer();
    var parser = require_parser();
    var _transform = require_transform();
    var _traverse = require_traverse();
    var fa = require_finite_automaton();
    var _require = require_runtime();
    var RegExpTree = _require.RegExpTree;
    var regexpTree = {
      parser,
      fa,
      TransformResult: _transform.TransformResult,
      parse: function parse(regexp, options) {
        return parser.parse("" + regexp, options);
      },
      traverse: function traverse(ast, handlers, options) {
        return _traverse.traverse(ast, handlers, options);
      },
      transform: function transform(regexp, handlers) {
        return _transform.transform(regexp, handlers);
      },
      generate: function generate(ast) {
        return generator.generate(ast);
      },
      toRegExp: function toRegExp(regexp) {
        var compat = this.compatTranspile(regexp);
        return new RegExp(compat.getSource(), compat.getFlags());
      },
      optimize: function optimize(regexp, whitelist) {
        var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, blacklist = _ref.blacklist;
        return optimizer.optimize(regexp, { whitelist, blacklist });
      },
      compatTranspile: function compatTranspile(regexp, whitelist) {
        return compatTranspiler.transform(regexp, whitelist);
      },
      exec: function exec(re, string) {
        if (typeof re === "string") {
          var compat = this.compatTranspile(re);
          var extra = compat.getExtra();
          if (extra.namedCapturingGroups) {
            re = new RegExpTree(compat.toRegExp(), {
              flags: compat.getFlags(),
              source: compat.getSource(),
              groups: extra.namedCapturingGroups
            });
          } else {
            re = compat.toRegExp();
          }
        }
        return re.exec(string);
      }
    };
    module2.exports = regexpTree;
  }
});

// node_modules/regexp-tree/index.js
var require_regexp_tree3 = __commonJS({
  "node_modules/regexp-tree/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_regexp_tree2();
  }
});

// node_modules/regexp-match-indices/implementation.js
var require_implementation = __commonJS({
  "node_modules/regexp-match-indices/implementation.js"(exports2, module2) {
    "use strict";
    var config = require_config();
    var nativeExec = require_native();
    var regexp_tree_1 = require_regexp_tree3();
    var weakMeasurementRegExp = /* @__PURE__ */ new WeakMap();
    function exec(string) {
      return config.mode === "spec-compliant" ? execSpecCompliant(this, string) : execLazy(this, string);
    }
    function execLazy(regexp, string) {
      const index = regexp.lastIndex;
      const result = nativeExec.call(regexp, string);
      if (result === null)
        return null;
      let indicesArray;
      Object.defineProperty(result, "indices", {
        enumerable: true,
        configurable: true,
        get() {
          if (indicesArray === void 0) {
            const { measurementRegExp, groupInfos } = getMeasurementRegExp(regexp);
            measurementRegExp.lastIndex = index;
            const measuredResult = nativeExec.call(measurementRegExp, string);
            if (measuredResult === null)
              throw new TypeError();
            makeDataProperty(result, "indices", indicesArray = makeIndicesArray(measuredResult, groupInfos));
          }
          return indicesArray;
        },
        set(value) {
          makeDataProperty(result, "indices", value);
        }
      });
      return result;
    }
    function execSpecCompliant(regexp, string) {
      const { measurementRegExp, groupInfos } = getMeasurementRegExp(regexp);
      measurementRegExp.lastIndex = regexp.lastIndex;
      const measuredResult = nativeExec.call(measurementRegExp, string);
      if (measuredResult === null)
        return null;
      regexp.lastIndex = measurementRegExp.lastIndex;
      const result = [];
      makeDataProperty(result, 0, measuredResult[0]);
      for (const groupInfo of groupInfos) {
        makeDataProperty(result, groupInfo.oldGroupNumber, measuredResult[groupInfo.newGroupNumber]);
      }
      makeDataProperty(result, "index", measuredResult.index);
      makeDataProperty(result, "input", measuredResult.input);
      makeDataProperty(result, "groups", measuredResult.groups);
      makeDataProperty(result, "indices", makeIndicesArray(measuredResult, groupInfos));
      return result;
    }
    function getMeasurementRegExp(regexp) {
      let transformed = weakMeasurementRegExp.get(regexp);
      if (!transformed) {
        transformed = transformMeasurementGroups(regexp_tree_1.parse(`/${regexp.source}/${regexp.flags}`));
        weakMeasurementRegExp.set(regexp, transformed);
      }
      const groupInfos = transformed.getExtra();
      const measurementRegExp = transformed.toRegExp();
      return { measurementRegExp, groupInfos };
    }
    function makeIndicesArray(measuredResult, groupInfos) {
      const matchStart = measuredResult.index;
      const matchEnd = matchStart + measuredResult[0].length;
      const hasGroups = !!measuredResult.groups;
      const indicesArray = [];
      const groups = hasGroups ? /* @__PURE__ */ Object.create(null) : void 0;
      makeDataProperty(indicesArray, 0, [matchStart, matchEnd]);
      for (const groupInfo of groupInfos) {
        let indices;
        if (measuredResult[groupInfo.newGroupNumber] !== void 0) {
          let startIndex = matchStart;
          if (groupInfo.measurementGroups) {
            for (const measurementGroup of groupInfo.measurementGroups) {
              startIndex += measuredResult[measurementGroup].length;
            }
          }
          const endIndex = startIndex + measuredResult[groupInfo.newGroupNumber].length;
          indices = [startIndex, endIndex];
        }
        makeDataProperty(indicesArray, groupInfo.oldGroupNumber, indices);
        if (groups && groupInfo.groupName !== void 0) {
          makeDataProperty(groups, groupInfo.groupName, indices);
        }
      }
      makeDataProperty(indicesArray, "groups", groups);
      return indicesArray;
    }
    function makeDataProperty(result, key, value) {
      const existingDesc = Object.getOwnPropertyDescriptor(result, key);
      if (existingDesc ? existingDesc.configurable : Object.isExtensible(result)) {
        const newDesc = {
          enumerable: existingDesc ? existingDesc.enumerable : true,
          configurable: existingDesc ? existingDesc.configurable : true,
          writable: true,
          value
        };
        Object.defineProperty(result, key, newDesc);
      }
    }
    var groupRenumbers;
    var hasBackreferences = false;
    var nodesContainingCapturingGroup = /* @__PURE__ */ new Set();
    var containsCapturingGroupStack = [];
    var containsCapturingGroup = false;
    var nextNewGroupNumber = 1;
    var measurementGroupStack = [];
    var measurementGroupsForGroup = /* @__PURE__ */ new Map();
    var newGroupNumberForGroup = /* @__PURE__ */ new Map();
    var handlers = {
      init() {
        hasBackreferences = false;
        nodesContainingCapturingGroup.clear();
        containsCapturingGroupStack.length = 0;
        containsCapturingGroup = false;
        nextNewGroupNumber = 1;
        measurementGroupStack.length = 0;
        measurementGroupsForGroup.clear();
        newGroupNumberForGroup.clear();
        groupRenumbers = [];
      },
      RegExp(path) {
        regexp_tree_1.traverse(path.node, visitor);
        if (nodesContainingCapturingGroup.size > 0) {
          regexp_tree_1.transform(path.node, builder);
          regexp_tree_1.transform(path.node, groupRenumberer);
          if (hasBackreferences) {
            regexp_tree_1.transform(path.node, backreferenceRenumberer);
          }
        }
        return false;
      }
    };
    var nodeCallbacks = {
      pre(path) {
        containsCapturingGroupStack.push(containsCapturingGroup);
        containsCapturingGroup = path.node.type === "Group" && path.node.capturing;
      },
      post(path) {
        if (containsCapturingGroup) {
          nodesContainingCapturingGroup.add(path.node);
        }
        containsCapturingGroup = containsCapturingGroupStack.pop() || containsCapturingGroup;
      }
    };
    var visitor = {
      Alternative: nodeCallbacks,
      Disjunction: nodeCallbacks,
      Assertion: nodeCallbacks,
      Group: nodeCallbacks,
      Repetition: nodeCallbacks,
      Backreference(path) {
        hasBackreferences = true;
      }
    };
    var builder = {
      Alternative(path) {
        if (nodesContainingCapturingGroup.has(path.node)) {
          let lastMeasurementIndex = 0;
          let pendingTerms = [];
          const measurementGroups = [];
          const terms = [];
          for (let i = 0; i < path.node.expressions.length; i++) {
            const term = path.node.expressions[i];
            if (nodesContainingCapturingGroup.has(term)) {
              if (i > lastMeasurementIndex) {
                const measurementGroup = {
                  type: "Group",
                  capturing: true,
                  number: -1,
                  expression: pendingTerms.length > 1 ? { type: "Alternative", expressions: pendingTerms } : pendingTerms.length === 1 ? pendingTerms[0] : null
                };
                terms.push(measurementGroup);
                measurementGroups.push(measurementGroup);
                lastMeasurementIndex = i;
                pendingTerms = [];
              }
              measurementGroupStack.push(measurementGroups);
              regexp_tree_1.transform(term, builder);
              measurementGroupStack.pop();
              pendingTerms.push(term);
              continue;
            }
            pendingTerms.push(term);
          }
          path.update({ expressions: terms.concat(pendingTerms) });
        }
        return false;
      },
      Group(path) {
        if (!path.node.capturing)
          return;
        measurementGroupsForGroup.set(path.node, getMeasurementGroups());
      }
    };
    var groupRenumberer = {
      Group(path) {
        if (!groupRenumbers)
          throw new Error("Not initialized.");
        if (!path.node.capturing)
          return;
        const oldGroupNumber = path.node.number;
        const newGroupNumber = nextNewGroupNumber++;
        const measurementGroups = measurementGroupsForGroup.get(path.node);
        if (oldGroupNumber !== -1) {
          groupRenumbers.push({
            oldGroupNumber,
            newGroupNumber,
            measurementGroups: measurementGroups && measurementGroups.map((group) => group.number),
            groupName: path.node.name
          });
          newGroupNumberForGroup.set(oldGroupNumber, newGroupNumber);
        }
        path.update({ number: newGroupNumber });
      }
    };
    var backreferenceRenumberer = {
      Backreference(path) {
        const newGroupNumber = newGroupNumberForGroup.get(path.node.number);
        if (newGroupNumber) {
          if (path.node.kind === "number") {
            path.update({
              number: newGroupNumber,
              reference: newGroupNumber
            });
          } else {
            path.update({
              number: newGroupNumber
            });
          }
        }
      }
    };
    function getMeasurementGroups() {
      const measurementGroups = [];
      for (const array of measurementGroupStack) {
        for (const item of array) {
          measurementGroups.push(item);
        }
      }
      return measurementGroups;
    }
    function transformMeasurementGroups(ast) {
      const result = regexp_tree_1.transform(ast, handlers);
      return new regexp_tree_1.TransformResult(result.getAST(), groupRenumbers);
    }
    module2.exports = exec;
  }
});

// node_modules/regexp-match-indices/polyfill.js
var require_polyfill = __commonJS({
  "node_modules/regexp-match-indices/polyfill.js"(exports2, module2) {
    "use strict";
    var nativeExec = require_native();
    var implementation = require_implementation();
    function getPolyfill() {
      const re = new RegExp("a");
      const match = nativeExec.call(re, "a");
      if (match.indices) {
        return nativeExec;
      }
      return implementation;
    }
    module2.exports = getPolyfill;
  }
});

// node_modules/regexp-match-indices/shim.js
var require_shim = __commonJS({
  "node_modules/regexp-match-indices/shim.js"(exports2, module2) {
    "use strict";
    var getPolyfill = require_polyfill();
    function shim() {
      const polyfill = getPolyfill();
      if (RegExp.prototype.exec !== polyfill) {
        RegExp.prototype.exec = polyfill;
      }
    }
    module2.exports = shim;
  }
});

// node_modules/regexp-match-indices/index.js
var require_regexp_match_indices = __commonJS({
  "node_modules/regexp-match-indices/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    var native = require_native();
    var getPolyfill = require_polyfill();
    var shim = require_shim();
    var config = require_config();
    var polyfill = getPolyfill();
    function exec(regexp, string) {
      return polyfill.call(regexp, string);
    }
    exec.implementation = implementation;
    exec.native = native;
    exec.getPolyfill = getPolyfill;
    exec.shim = shim;
    exec.config = config;
    (function(exec2) {
    })(exec || (exec = {}));
    module2.exports = exec;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Group.js
var require_Group = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/Group.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Group = function() {
      function Group2(value, start, end, children) {
        this.value = value;
        this.start = start;
        this.end = end;
        this.children = children;
      }
      Object.defineProperty(Group2.prototype, "values", {
        get: function() {
          return (this.children.length === 0 ? [this] : this.children).map(function(g) {
            return g.value;
          });
        },
        enumerable: false,
        configurable: true
      });
      return Group2;
    }();
    exports2.default = Group;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/GroupBuilder.js
var require_GroupBuilder = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/GroupBuilder.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Group_js_1 = __importDefault(require_Group());
    var GroupBuilder = function() {
      function GroupBuilder2() {
        this.capturing = true;
        this.groupBuilders = [];
      }
      GroupBuilder2.prototype.add = function(groupBuilder) {
        this.groupBuilders.push(groupBuilder);
      };
      GroupBuilder2.prototype.build = function(match, nextGroupIndex) {
        var groupIndex = nextGroupIndex();
        var children = this.groupBuilders.map(function(gb) {
          return gb.build(match, nextGroupIndex);
        });
        var value = match[groupIndex];
        var index = match.indices[groupIndex];
        var start = index ? index[0] : void 0;
        var end = index ? index[1] : void 0;
        return new Group_js_1.default(value, start, end, children);
      };
      GroupBuilder2.prototype.setNonCapturing = function() {
        this.capturing = false;
      };
      Object.defineProperty(GroupBuilder2.prototype, "children", {
        get: function() {
          return this.groupBuilders;
        },
        enumerable: false,
        configurable: true
      });
      GroupBuilder2.prototype.moveChildrenTo = function(groupBuilder) {
        this.groupBuilders.forEach(function(child) {
          return groupBuilder.add(child);
        });
      };
      return GroupBuilder2;
    }();
    exports2.default = GroupBuilder;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/TreeRegexp.js
var require_TreeRegexp = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/TreeRegexp.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var regexp_match_indices_1 = __importDefault(require_regexp_match_indices());
    var GroupBuilder_js_1 = __importDefault(require_GroupBuilder());
    var TreeRegexp = function() {
      function TreeRegexp2(regexp) {
        if (regexp instanceof RegExp) {
          this.regexp = regexp;
        } else {
          this.regexp = new RegExp(regexp);
        }
        this.groupBuilder = TreeRegexp2.createGroupBuilder(this.regexp);
      }
      TreeRegexp2.createGroupBuilder = function(regexp) {
        var source = regexp.source;
        var stack = [new GroupBuilder_js_1.default()];
        var groupStartStack = [];
        var escaping = false;
        var charClass = false;
        for (var i = 0; i < source.length; i++) {
          var c = source[i];
          if (c === "[" && !escaping) {
            charClass = true;
          } else if (c === "]" && !escaping) {
            charClass = false;
          } else if (c === "(" && !escaping && !charClass) {
            groupStartStack.push(i);
            var nonCapturing = TreeRegexp2.isNonCapturing(source, i);
            var groupBuilder = new GroupBuilder_js_1.default();
            if (nonCapturing) {
              groupBuilder.setNonCapturing();
            }
            stack.push(groupBuilder);
          } else if (c === ")" && !escaping && !charClass) {
            var gb = stack.pop();
            if (!gb)
              throw new Error("Empty stack");
            var groupStart = groupStartStack.pop();
            if (gb.capturing) {
              gb.source = source.substring((groupStart || 0) + 1, i);
              stack[stack.length - 1].add(gb);
            } else {
              gb.moveChildrenTo(stack[stack.length - 1]);
            }
          }
          escaping = c === "\\" && !escaping;
        }
        var result = stack.pop();
        if (!result)
          throw new Error("Empty stack");
        return result;
      };
      TreeRegexp2.isNonCapturing = function(source, i) {
        if (source[i + 1] !== "?") {
          return false;
        }
        if (source[i + 2] !== "<") {
          return true;
        }
        return source[i + 3] === "=" || source[i + 3] === "!";
      };
      TreeRegexp2.prototype.match = function(s) {
        var match = (0, regexp_match_indices_1.default)(this.regexp, s);
        if (!match) {
          return null;
        }
        var groupIndex = 0;
        var nextGroupIndex = function() {
          return groupIndex++;
        };
        return this.groupBuilder.build(match, nextGroupIndex);
      };
      return TreeRegexp2;
    }();
    exports2.default = TreeRegexp;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpression.js
var require_CucumberExpression = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpression.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Argument_js_1 = __importDefault(require_Argument());
    var Ast_js_1 = require_Ast();
    var CucumberExpressionParser_js_1 = __importDefault(require_CucumberExpressionParser());
    var Errors_js_1 = require_Errors2();
    var TreeRegexp_js_1 = __importDefault(require_TreeRegexp());
    var ESCAPE_PATTERN = function() {
      return /([\\^[({$.|?*+})\]])/g;
    };
    var CucumberExpression = function() {
      function CucumberExpression2(expression, parameterTypeRegistry) {
        this.expression = expression;
        this.parameterTypeRegistry = parameterTypeRegistry;
        this.parameterTypes = [];
        var parser = new CucumberExpressionParser_js_1.default();
        this.ast = parser.parse(expression);
        var pattern = this.rewriteToRegex(this.ast);
        this.treeRegexp = new TreeRegexp_js_1.default(pattern);
      }
      CucumberExpression2.prototype.rewriteToRegex = function(node) {
        switch (node.type) {
          case Ast_js_1.NodeType.text:
            return CucumberExpression2.escapeRegex(node.text());
          case Ast_js_1.NodeType.optional:
            return this.rewriteOptional(node);
          case Ast_js_1.NodeType.alternation:
            return this.rewriteAlternation(node);
          case Ast_js_1.NodeType.alternative:
            return this.rewriteAlternative(node);
          case Ast_js_1.NodeType.parameter:
            return this.rewriteParameter(node);
          case Ast_js_1.NodeType.expression:
            return this.rewriteExpression(node);
          default:
            throw new Error(node.type);
        }
      };
      CucumberExpression2.escapeRegex = function(expression) {
        return expression.replace(ESCAPE_PATTERN(), "\\$1");
      };
      CucumberExpression2.prototype.rewriteOptional = function(node) {
        var _this = this;
        this.assertNoParameters(node, function(astNode) {
          return (0, Errors_js_1.createParameterIsNotAllowedInOptional)(astNode, _this.expression);
        });
        this.assertNoOptionals(node, function(astNode) {
          return (0, Errors_js_1.createOptionalIsNotAllowedInOptional)(astNode, _this.expression);
        });
        this.assertNotEmpty(node, function(astNode) {
          return (0, Errors_js_1.createOptionalMayNotBeEmpty)(astNode, _this.expression);
        });
        var regex = (node.nodes || []).map(function(node2) {
          return _this.rewriteToRegex(node2);
        }).join("");
        return "(?:".concat(regex, ")?");
      };
      CucumberExpression2.prototype.rewriteAlternation = function(node) {
        var e_1, _a;
        var _this = this;
        try {
          for (var _b = __values(node.nodes || []), _c = _b.next(); !_c.done; _c = _b.next()) {
            var alternative = _c.value;
            if (!alternative.nodes || alternative.nodes.length == 0) {
              throw (0, Errors_js_1.createAlternativeMayNotBeEmpty)(alternative, this.expression);
            }
            this.assertNotEmpty(alternative, function(astNode) {
              return (0, Errors_js_1.createAlternativeMayNotExclusivelyContainOptionals)(astNode, _this.expression);
            });
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var regex = (node.nodes || []).map(function(node2) {
          return _this.rewriteToRegex(node2);
        }).join("|");
        return "(?:".concat(regex, ")");
      };
      CucumberExpression2.prototype.rewriteAlternative = function(node) {
        var _this = this;
        return (node.nodes || []).map(function(lastNode) {
          return _this.rewriteToRegex(lastNode);
        }).join("");
      };
      CucumberExpression2.prototype.rewriteParameter = function(node) {
        var name = node.text();
        var parameterType = this.parameterTypeRegistry.lookupByTypeName(name);
        if (!parameterType) {
          throw (0, Errors_js_1.createUndefinedParameterType)(node, this.expression, name);
        }
        this.parameterTypes.push(parameterType);
        var regexps = parameterType.regexpStrings;
        if (regexps.length == 1) {
          return "(".concat(regexps[0], ")");
        }
        return "((?:".concat(regexps.join(")|(?:"), "))");
      };
      CucumberExpression2.prototype.rewriteExpression = function(node) {
        var _this = this;
        var regex = (node.nodes || []).map(function(node2) {
          return _this.rewriteToRegex(node2);
        }).join("");
        return "^".concat(regex, "$");
      };
      CucumberExpression2.prototype.assertNotEmpty = function(node, createNodeWasNotEmptyException) {
        var textNodes = (node.nodes || []).filter(function(astNode) {
          return Ast_js_1.NodeType.text == astNode.type;
        });
        if (textNodes.length == 0) {
          throw createNodeWasNotEmptyException(node);
        }
      };
      CucumberExpression2.prototype.assertNoParameters = function(node, createNodeContainedAParameterError) {
        var parameterNodes = (node.nodes || []).filter(function(astNode) {
          return Ast_js_1.NodeType.parameter == astNode.type;
        });
        if (parameterNodes.length > 0) {
          throw createNodeContainedAParameterError(parameterNodes[0]);
        }
      };
      CucumberExpression2.prototype.assertNoOptionals = function(node, createNodeContainedAnOptionalError) {
        var parameterNodes = (node.nodes || []).filter(function(astNode) {
          return Ast_js_1.NodeType.optional == astNode.type;
        });
        if (parameterNodes.length > 0) {
          throw createNodeContainedAnOptionalError(parameterNodes[0]);
        }
      };
      CucumberExpression2.prototype.match = function(text) {
        var group = this.treeRegexp.match(text);
        if (!group) {
          return null;
        }
        return Argument_js_1.default.build(group, this.parameterTypes);
      };
      Object.defineProperty(CucumberExpression2.prototype, "regexp", {
        get: function() {
          return this.treeRegexp.regexp;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(CucumberExpression2.prototype, "source", {
        get: function() {
          return this.expression;
        },
        enumerable: false,
        configurable: true
      });
      return CucumberExpression2;
    }();
    exports2.default = CucumberExpression;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/GeneratedExpression.js
var require_GeneratedExpression = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/GeneratedExpression.js"(exports2) {
    "use strict";
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GeneratedExpression = function() {
      function GeneratedExpression2(expressionTemplate, parameterTypes) {
        this.expressionTemplate = expressionTemplate;
        this.parameterTypes = parameterTypes;
      }
      Object.defineProperty(GeneratedExpression2.prototype, "source", {
        get: function() {
          return format.apply(void 0, __spreadArray([this.expressionTemplate], __read(this.parameterTypes.map(function(t) {
            return t.name || "";
          })), false));
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GeneratedExpression2.prototype, "parameterNames", {
        get: function() {
          return this.parameterInfos.map(function(i) {
            return "".concat(i.name).concat(i.count === 1 ? "" : i.count.toString());
          });
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(GeneratedExpression2.prototype, "parameterInfos", {
        get: function() {
          var usageByTypeName = {};
          return this.parameterTypes.map(function(t) {
            return getParameterInfo(t, usageByTypeName);
          });
        },
        enumerable: false,
        configurable: true
      });
      return GeneratedExpression2;
    }();
    exports2.default = GeneratedExpression;
    function getParameterInfo(parameterType, usageByName) {
      var name = parameterType.name || "";
      var counter = usageByName[name];
      counter = counter ? counter + 1 : 1;
      usageByName[name] = counter;
      var type;
      if (parameterType.type) {
        if (typeof parameterType.type === "string") {
          type = parameterType.type;
        } else if ("name" in parameterType.type) {
          type = parameterType.type.name;
        } else {
          type = null;
        }
      } else {
        type = null;
      }
      return {
        type,
        name,
        count: counter
      };
    }
    function format(pattern) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      return pattern.replace(/{(\d+)}/g, function(match, number) {
        return args[number];
      });
    }
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CombinatorialGeneratedExpressionFactory.js
var require_CombinatorialGeneratedExpressionFactory = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CombinatorialGeneratedExpressionFactory.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var GeneratedExpression_js_1 = __importDefault(require_GeneratedExpression());
    var MAX_EXPRESSIONS = 256;
    var CombinatorialGeneratedExpressionFactory = function() {
      function CombinatorialGeneratedExpressionFactory2(expressionTemplate, parameterTypeCombinations) {
        this.expressionTemplate = expressionTemplate;
        this.parameterTypeCombinations = parameterTypeCombinations;
        this.expressionTemplate = expressionTemplate;
      }
      CombinatorialGeneratedExpressionFactory2.prototype.generateExpressions = function() {
        var generatedExpressions = [];
        this.generatePermutations(generatedExpressions, 0, []);
        return generatedExpressions;
      };
      CombinatorialGeneratedExpressionFactory2.prototype.generatePermutations = function(generatedExpressions, depth, currentParameterTypes) {
        if (generatedExpressions.length >= MAX_EXPRESSIONS) {
          return;
        }
        if (depth === this.parameterTypeCombinations.length) {
          generatedExpressions.push(new GeneratedExpression_js_1.default(this.expressionTemplate, currentParameterTypes));
          return;
        }
        for (var i = 0; i < this.parameterTypeCombinations[depth].length; ++i) {
          if (generatedExpressions.length >= MAX_EXPRESSIONS) {
            return;
          }
          var newCurrentParameterTypes = currentParameterTypes.slice();
          newCurrentParameterTypes.push(this.parameterTypeCombinations[depth][i]);
          this.generatePermutations(generatedExpressions, depth + 1, newCurrentParameterTypes);
        }
      };
      return CombinatorialGeneratedExpressionFactory2;
    }();
    exports2.default = CombinatorialGeneratedExpressionFactory;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterType.js
var require_ParameterType = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterType.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CucumberExpressionError_js_1 = __importDefault(require_CucumberExpressionError());
    var ILLEGAL_PARAMETER_NAME_PATTERN = /([[\]()$.|?*+])/;
    var UNESCAPE_PATTERN = function() {
      return /(\\([[$.|?*+\]]))/g;
    };
    var ParameterType = function() {
      function ParameterType2(name, regexps, type, transform, useForSnippets, preferForRegexpMatch) {
        this.name = name;
        this.type = type;
        this.useForSnippets = useForSnippets;
        this.preferForRegexpMatch = preferForRegexpMatch;
        if (transform === void 0) {
          transform = function(s) {
            return s;
          };
        }
        if (useForSnippets === void 0) {
          this.useForSnippets = true;
        }
        if (preferForRegexpMatch === void 0) {
          this.preferForRegexpMatch = false;
        }
        if (name) {
          ParameterType2.checkParameterTypeName(name);
        }
        this.regexpStrings = stringArray(regexps);
        this.transformFn = transform;
      }
      ParameterType2.compare = function(pt1, pt2) {
        if (pt1.preferForRegexpMatch && !pt2.preferForRegexpMatch) {
          return -1;
        }
        if (pt2.preferForRegexpMatch && !pt1.preferForRegexpMatch) {
          return 1;
        }
        return (pt1.name || "").localeCompare(pt2.name || "");
      };
      ParameterType2.checkParameterTypeName = function(typeName) {
        if (!this.isValidParameterTypeName(typeName)) {
          throw new CucumberExpressionError_js_1.default("Illegal character in parameter name {".concat(typeName, "}. Parameter names may not contain '{', '}', '(', ')', '\\' or '/'"));
        }
      };
      ParameterType2.isValidParameterTypeName = function(typeName) {
        var unescapedTypeName = typeName.replace(UNESCAPE_PATTERN(), "$2");
        return !unescapedTypeName.match(ILLEGAL_PARAMETER_NAME_PATTERN);
      };
      ParameterType2.prototype.transform = function(thisObj, groupValues) {
        return this.transformFn.apply(thisObj, groupValues);
      };
      return ParameterType2;
    }();
    exports2.default = ParameterType;
    function stringArray(regexps) {
      var array = Array.isArray(regexps) ? regexps : [regexps];
      return array.map(function(r) {
        return r instanceof RegExp ? regexpSource(r) : r;
      });
    }
    function regexpSource(regexp) {
      var e_1, _a;
      var flags = regexpFlags(regexp);
      try {
        for (var _b = __values(["g", "i", "m", "y"]), _c = _b.next(); !_c.done; _c = _b.next()) {
          var flag = _c.value;
          if (flags.indexOf(flag) !== -1) {
            throw new CucumberExpressionError_js_1.default("ParameterType Regexps can't use flag '".concat(flag, "'"));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a = _b.return))
            _a.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return regexp.source;
    }
    function regexpFlags(regexp) {
      var flags = regexp.flags;
      if (flags === void 0) {
        flags = "";
        if (regexp.ignoreCase) {
          flags += "i";
        }
        if (regexp.global) {
          flags += "g";
        }
        if (regexp.multiline) {
          flags += "m";
        }
      }
      return flags;
    }
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterTypeMatcher.js
var require_ParameterTypeMatcher = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterTypeMatcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ParameterTypeMatcher = function() {
      function ParameterTypeMatcher2(parameterType, regexpString, text, matchPosition) {
        if (matchPosition === void 0) {
          matchPosition = 0;
        }
        this.parameterType = parameterType;
        this.regexpString = regexpString;
        this.text = text;
        this.matchPosition = matchPosition;
        var captureGroupRegexp = new RegExp("(".concat(regexpString, ")"));
        this.match = captureGroupRegexp.exec(text.slice(this.matchPosition));
      }
      ParameterTypeMatcher2.prototype.advanceTo = function(newMatchPosition) {
        for (var advancedPos = newMatchPosition; advancedPos < this.text.length; advancedPos++) {
          var matcher = new ParameterTypeMatcher2(this.parameterType, this.regexpString, this.text, advancedPos);
          if (matcher.find) {
            return matcher;
          }
        }
        return new ParameterTypeMatcher2(this.parameterType, this.regexpString, this.text, this.text.length);
      };
      Object.defineProperty(ParameterTypeMatcher2.prototype, "find", {
        get: function() {
          return this.match && this.group !== "" && this.fullWord;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParameterTypeMatcher2.prototype, "start", {
        get: function() {
          if (!this.match)
            throw new Error("No match");
          return this.matchPosition + this.match.index;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParameterTypeMatcher2.prototype, "fullWord", {
        get: function() {
          return this.matchStartWord && this.matchEndWord;
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParameterTypeMatcher2.prototype, "matchStartWord", {
        get: function() {
          return this.start === 0 || this.text[this.start - 1].match(/\p{Z}|\p{P}|\p{S}/u);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParameterTypeMatcher2.prototype, "matchEndWord", {
        get: function() {
          var nextCharacterIndex = this.start + this.group.length;
          return nextCharacterIndex === this.text.length || this.text[nextCharacterIndex].match(/\p{Z}|\p{P}|\p{S}/u);
        },
        enumerable: false,
        configurable: true
      });
      Object.defineProperty(ParameterTypeMatcher2.prototype, "group", {
        get: function() {
          if (!this.match)
            throw new Error("No match");
          return this.match[0];
        },
        enumerable: false,
        configurable: true
      });
      ParameterTypeMatcher2.compare = function(a, b) {
        var posComparison = a.start - b.start;
        if (posComparison !== 0) {
          return posComparison;
        }
        var lengthComparison = b.group.length - a.group.length;
        if (lengthComparison !== 0) {
          return lengthComparison;
        }
        return 0;
      };
      return ParameterTypeMatcher2;
    }();
    exports2.default = ParameterTypeMatcher;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionGenerator.js
var require_CucumberExpressionGenerator = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/CucumberExpressionGenerator.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CombinatorialGeneratedExpressionFactory_js_1 = __importDefault(require_CombinatorialGeneratedExpressionFactory());
    var ParameterType_js_1 = __importDefault(require_ParameterType());
    var ParameterTypeMatcher_js_1 = __importDefault(require_ParameterTypeMatcher());
    var CucumberExpressionGenerator = function() {
      function CucumberExpressionGenerator2(parameterTypes) {
        this.parameterTypes = parameterTypes;
      }
      CucumberExpressionGenerator2.prototype.generateExpressions = function(text) {
        var parameterTypeCombinations = [];
        var parameterTypeMatchers = this.createParameterTypeMatchers(text);
        var expressionTemplate = "";
        var pos = 0;
        var counter = 0;
        var _loop_1 = function() {
          var e_1, _a, e_2, _b;
          var matchingParameterTypeMatchers = [];
          try {
            for (var parameterTypeMatchers_1 = (e_1 = void 0, __values(parameterTypeMatchers)), parameterTypeMatchers_1_1 = parameterTypeMatchers_1.next(); !parameterTypeMatchers_1_1.done; parameterTypeMatchers_1_1 = parameterTypeMatchers_1.next()) {
              var parameterTypeMatcher = parameterTypeMatchers_1_1.value;
              var advancedParameterTypeMatcher = parameterTypeMatcher.advanceTo(pos);
              if (advancedParameterTypeMatcher.find) {
                matchingParameterTypeMatchers.push(advancedParameterTypeMatcher);
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (parameterTypeMatchers_1_1 && !parameterTypeMatchers_1_1.done && (_a = parameterTypeMatchers_1.return))
                _a.call(parameterTypeMatchers_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
          if (matchingParameterTypeMatchers.length > 0) {
            matchingParameterTypeMatchers = matchingParameterTypeMatchers.sort(ParameterTypeMatcher_js_1.default.compare);
            var bestParameterTypeMatcher_1 = matchingParameterTypeMatchers[0];
            var bestParameterTypeMatchers = matchingParameterTypeMatchers.filter(function(m) {
              return ParameterTypeMatcher_js_1.default.compare(m, bestParameterTypeMatcher_1) === 0;
            });
            var parameterTypes = [];
            try {
              for (var bestParameterTypeMatchers_1 = (e_2 = void 0, __values(bestParameterTypeMatchers)), bestParameterTypeMatchers_1_1 = bestParameterTypeMatchers_1.next(); !bestParameterTypeMatchers_1_1.done; bestParameterTypeMatchers_1_1 = bestParameterTypeMatchers_1.next()) {
                var parameterTypeMatcher = bestParameterTypeMatchers_1_1.value;
                if (parameterTypes.indexOf(parameterTypeMatcher.parameterType) === -1) {
                  parameterTypes.push(parameterTypeMatcher.parameterType);
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (bestParameterTypeMatchers_1_1 && !bestParameterTypeMatchers_1_1.done && (_b = bestParameterTypeMatchers_1.return))
                  _b.call(bestParameterTypeMatchers_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
            parameterTypes = parameterTypes.sort(ParameterType_js_1.default.compare);
            parameterTypeCombinations.push(parameterTypes);
            expressionTemplate += escape(text.slice(pos, bestParameterTypeMatcher_1.start));
            expressionTemplate += "{{".concat(counter++, "}}");
            pos = bestParameterTypeMatcher_1.start + bestParameterTypeMatcher_1.group.length;
          } else {
            return "break";
          }
          if (pos >= text.length) {
            return "break";
          }
        };
        while (true) {
          var state_1 = _loop_1();
          if (state_1 === "break")
            break;
        }
        expressionTemplate += escape(text.slice(pos));
        return new CombinatorialGeneratedExpressionFactory_js_1.default(expressionTemplate, parameterTypeCombinations).generateExpressions();
      };
      CucumberExpressionGenerator2.prototype.createParameterTypeMatchers = function(text) {
        var e_3, _a;
        var parameterMatchers = [];
        try {
          for (var _b = __values(this.parameterTypes()), _c = _b.next(); !_c.done; _c = _b.next()) {
            var parameterType = _c.value;
            if (parameterType.useForSnippets) {
              parameterMatchers = parameterMatchers.concat(CucumberExpressionGenerator2.createParameterTypeMatchers2(parameterType, text));
            }
          }
        } catch (e_3_1) {
          e_3 = { error: e_3_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_3)
              throw e_3.error;
          }
        }
        return parameterMatchers;
      };
      CucumberExpressionGenerator2.createParameterTypeMatchers2 = function(parameterType, text) {
        return parameterType.regexpStrings.map(function(regexp) {
          return new ParameterTypeMatcher_js_1.default(parameterType, regexp, text);
        });
      };
      return CucumberExpressionGenerator2;
    }();
    exports2.default = CucumberExpressionGenerator;
    function escape(s) {
      return s.replace(/\(/g, "\\(").replace(/{/g, "\\{").replace(/\//g, "\\/");
    }
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/RegularExpression.js
var require_RegularExpression = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/RegularExpression.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var Argument_js_1 = __importDefault(require_Argument());
    var ParameterType_js_1 = __importDefault(require_ParameterType());
    var TreeRegexp_js_1 = __importDefault(require_TreeRegexp());
    var RegularExpression = function() {
      function RegularExpression2(regexp, parameterTypeRegistry) {
        this.regexp = regexp;
        this.parameterTypeRegistry = parameterTypeRegistry;
        this.treeRegexp = new TreeRegexp_js_1.default(regexp);
      }
      RegularExpression2.prototype.match = function(text) {
        var _this = this;
        var group = this.treeRegexp.match(text);
        if (!group) {
          return null;
        }
        var parameterTypes = this.treeRegexp.groupBuilder.children.map(function(groupBuilder) {
          var parameterTypeRegexp = groupBuilder.source;
          var parameterType = _this.parameterTypeRegistry.lookupByRegexp(parameterTypeRegexp, _this.regexp, text);
          return parameterType || new ParameterType_js_1.default(void 0, parameterTypeRegexp, String, function(s) {
            return s === void 0 ? null : s;
          }, false, false);
        });
        return Argument_js_1.default.build(group, parameterTypes);
      };
      Object.defineProperty(RegularExpression2.prototype, "source", {
        get: function() {
          return this.regexp.source;
        },
        enumerable: false,
        configurable: true
      });
      return RegularExpression2;
    }();
    exports2.default = RegularExpression;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ExpressionFactory.js
var require_ExpressionFactory = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ExpressionFactory.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CucumberExpression_js_1 = __importDefault(require_CucumberExpression());
    var RegularExpression_js_1 = __importDefault(require_RegularExpression());
    var ExpressionFactory = function() {
      function ExpressionFactory2(parameterTypeRegistry) {
        this.parameterTypeRegistry = parameterTypeRegistry;
      }
      ExpressionFactory2.prototype.createExpression = function(expression) {
        return typeof expression === "string" ? new CucumberExpression_js_1.default(expression, this.parameterTypeRegistry) : new RegularExpression_js_1.default(expression, this.parameterTypeRegistry);
      };
      return ExpressionFactory2;
    }();
    exports2.default = ExpressionFactory;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/defineDefaultParameterTypes.js
var require_defineDefaultParameterTypes = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/defineDefaultParameterTypes.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ParameterType_js_1 = __importDefault(require_ParameterType());
    var INTEGER_REGEXPS = [/-?\d+/, /\d+/];
    var FLOAT_REGEXP = /(?=.*\d.*)[-+]?\d*(?:\.(?=\d.*))?\d*(?:\d+[E][+-]?\d+)?/;
    var WORD_REGEXP = /[^\s]+/;
    var STRING_REGEXP = /"([^"\\]*(\\.[^"\\]*)*)"|'([^'\\]*(\\.[^'\\]*)*)'/;
    var ANONYMOUS_REGEXP = /.*/;
    function defineDefaultParameterTypes(registry) {
      registry.defineParameterType(new ParameterType_js_1.default("int", INTEGER_REGEXPS, Number, function(s) {
        return s === void 0 ? null : Number(s);
      }, true, true));
      registry.defineParameterType(new ParameterType_js_1.default("float", FLOAT_REGEXP, Number, function(s) {
        return s === void 0 ? null : parseFloat(s);
      }, true, false));
      registry.defineParameterType(new ParameterType_js_1.default("word", WORD_REGEXP, String, function(s) {
        return s;
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("string", STRING_REGEXP, String, function(s1, s2) {
        return (s1 || s2 || "").replace(/\\"/g, '"').replace(/\\'/g, "'");
      }, true, false));
      registry.defineParameterType(new ParameterType_js_1.default("", ANONYMOUS_REGEXP, String, function(s) {
        return s;
      }, false, true));
      registry.defineParameterType(new ParameterType_js_1.default("double", FLOAT_REGEXP, Number, function(s) {
        return s === void 0 ? null : parseFloat(s);
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("bigdecimal", FLOAT_REGEXP, String, function(s) {
        return s === void 0 ? null : s;
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("byte", INTEGER_REGEXPS, Number, function(s) {
        return s === void 0 ? null : Number(s);
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("short", INTEGER_REGEXPS, Number, function(s) {
        return s === void 0 ? null : Number(s);
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("long", INTEGER_REGEXPS, Number, function(s) {
        return s === void 0 ? null : Number(s);
      }, false, false));
      registry.defineParameterType(new ParameterType_js_1.default("biginteger", INTEGER_REGEXPS, BigInt, function(s) {
        return s === void 0 ? null : BigInt(s);
      }, false, false));
    }
    exports2.default = defineDefaultParameterTypes;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterTypeRegistry.js
var require_ParameterTypeRegistry = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/ParameterTypeRegistry.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var CucumberExpressionError_js_1 = __importDefault(require_CucumberExpressionError());
    var CucumberExpressionGenerator_js_1 = __importDefault(require_CucumberExpressionGenerator());
    var defineDefaultParameterTypes_js_1 = __importDefault(require_defineDefaultParameterTypes());
    var Errors_js_1 = require_Errors2();
    var ParameterType_js_1 = __importDefault(require_ParameterType());
    var ParameterTypeRegistry = function() {
      function ParameterTypeRegistry2() {
        this.parameterTypeByName = /* @__PURE__ */ new Map();
        this.parameterTypesByRegexp = /* @__PURE__ */ new Map();
        (0, defineDefaultParameterTypes_js_1.default)(this);
      }
      Object.defineProperty(ParameterTypeRegistry2.prototype, "parameterTypes", {
        get: function() {
          return this.parameterTypeByName.values();
        },
        enumerable: false,
        configurable: true
      });
      ParameterTypeRegistry2.prototype.lookupByTypeName = function(typeName) {
        return this.parameterTypeByName.get(typeName);
      };
      ParameterTypeRegistry2.prototype.lookupByRegexp = function(parameterTypeRegexp, expressionRegexp, text) {
        var _this = this;
        var parameterTypes = this.parameterTypesByRegexp.get(parameterTypeRegexp);
        if (!parameterTypes) {
          return void 0;
        }
        if (parameterTypes.length > 1 && !parameterTypes[0].preferForRegexpMatch) {
          var generatedExpressions = new CucumberExpressionGenerator_js_1.default(function() {
            return _this.parameterTypes;
          }).generateExpressions(text);
          throw Errors_js_1.AmbiguousParameterTypeError.forRegExp(parameterTypeRegexp, expressionRegexp, parameterTypes, generatedExpressions);
        }
        return parameterTypes[0];
      };
      ParameterTypeRegistry2.prototype.defineParameterType = function(parameterType) {
        var e_1, _a;
        if (parameterType.name !== void 0) {
          if (this.parameterTypeByName.has(parameterType.name)) {
            if (parameterType.name.length === 0) {
              throw new CucumberExpressionError_js_1.default("The anonymous parameter type has already been defined");
            } else {
              throw new CucumberExpressionError_js_1.default("There is already a parameter type with name ".concat(parameterType.name));
            }
          }
          this.parameterTypeByName.set(parameterType.name, parameterType);
        }
        try {
          for (var _b = __values(parameterType.regexpStrings), _c = _b.next(); !_c.done; _c = _b.next()) {
            var parameterTypeRegexp = _c.value;
            if (!this.parameterTypesByRegexp.has(parameterTypeRegexp)) {
              this.parameterTypesByRegexp.set(parameterTypeRegexp, []);
            }
            var parameterTypes = this.parameterTypesByRegexp.get(parameterTypeRegexp);
            var existingParameterType = parameterTypes[0];
            if (parameterTypes.length > 0 && existingParameterType.preferForRegexpMatch && parameterType.preferForRegexpMatch) {
              throw new CucumberExpressionError_js_1.default("There can only be one preferential parameter type per regexp. " + "The regexp /".concat(parameterTypeRegexp, "/ is used for two preferential parameter types, {").concat(existingParameterType.name, "} and {").concat(parameterType.name, "}"));
            }
            if (parameterTypes.indexOf(parameterType) === -1) {
              parameterTypes.push(parameterType);
              this.parameterTypesByRegexp.set(parameterTypeRegexp, parameterTypes.sort(ParameterType_js_1.default.compare));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a = _b.return))
              _a.call(_b);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      };
      return ParameterTypeRegistry2;
    }();
    exports2.default = ParameterTypeRegistry;
  }
});

// node_modules/@cucumber/cucumber-expressions/dist/cjs/src/index.js
var require_src5 = __commonJS({
  "node_modules/@cucumber/cucumber-expressions/dist/cjs/src/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TokenType = exports2.Token = exports2.RegularExpression = exports2.ParameterTypeRegistry = exports2.ParameterType = exports2.NodeType = exports2.Node = exports2.Group = exports2.GeneratedExpression = exports2.ExpressionFactory = exports2.CucumberExpressionGenerator = exports2.CucumberExpression = exports2.Argument = void 0;
    var Argument_js_1 = __importDefault(require_Argument());
    exports2.Argument = Argument_js_1.default;
    var Ast_js_1 = require_Ast();
    Object.defineProperty(exports2, "Node", { enumerable: true, get: function() {
      return Ast_js_1.Node;
    } });
    Object.defineProperty(exports2, "NodeType", { enumerable: true, get: function() {
      return Ast_js_1.NodeType;
    } });
    Object.defineProperty(exports2, "Token", { enumerable: true, get: function() {
      return Ast_js_1.Token;
    } });
    Object.defineProperty(exports2, "TokenType", { enumerable: true, get: function() {
      return Ast_js_1.TokenType;
    } });
    var CucumberExpression_js_1 = __importDefault(require_CucumberExpression());
    exports2.CucumberExpression = CucumberExpression_js_1.default;
    var CucumberExpressionGenerator_js_1 = __importDefault(require_CucumberExpressionGenerator());
    exports2.CucumberExpressionGenerator = CucumberExpressionGenerator_js_1.default;
    var ExpressionFactory_js_1 = __importDefault(require_ExpressionFactory());
    exports2.ExpressionFactory = ExpressionFactory_js_1.default;
    var GeneratedExpression_js_1 = __importDefault(require_GeneratedExpression());
    exports2.GeneratedExpression = GeneratedExpression_js_1.default;
    var Group_js_1 = __importDefault(require_Group());
    exports2.Group = Group_js_1.default;
    var ParameterType_js_1 = __importDefault(require_ParameterType());
    exports2.ParameterType = ParameterType_js_1.default;
    var ParameterTypeRegistry_js_1 = __importDefault(require_ParameterTypeRegistry());
    exports2.ParameterTypeRegistry = ParameterTypeRegistry_js_1.default;
    var RegularExpression_js_1 = __importDefault(require_RegularExpression());
    exports2.RegularExpression = RegularExpression_js_1.default;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/csharpLanguage.js
var require_csharpLanguage = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/csharpLanguage.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.csharpLanguage = void 0;
    var helpers_js_1 = require_helpers();
    exports2.csharpLanguage = {
      defineParameterTypeQueries: [
        '\n    (method_declaration\n      (attribute_list\n        (attribute\n          name: (identifier) @attribute-name\n          (attribute_argument_list\n            (attribute_argument\n              [\n                (verbatim_string_literal) \n                (string_literal)\n              ] @expression\n            )\n          )\n        )\n      )\n      type: (identifier) @name\n      (#eq? @attribute-name "StepArgumentTransformation")\n    ) @root\n    ',
        '\n    (method_declaration\n      (attribute_list\n        (attribute\n          name: (identifier) @attribute-name\n          .\n        )\n      )\n      type: (identifier) @name\n      (#eq? @attribute-name "StepArgumentTransformation")\n    ) @root\n        '
      ],
      defineStepDefinitionQueries: [
        '\n(method_declaration\n  (attribute_list\n    (attribute\n      name: (identifier) @annotation-name\n      (attribute_argument_list\n        (attribute_argument\n          (verbatim_string_literal) @expression\n        )\n      )\n    )\n  )\n  (#match? @annotation-name "Given|When|Then|And|But|StepDefinition")\n) @root\n',
        '\n(method_declaration\n  (attribute_list\n    (attribute\n      name: (identifier) @annotation-name\n      (attribute_argument_list\n        (attribute_argument\n          (string_literal) @expression\n        )\n      )\n    )\n  )\n  (#match? @annotation-name "Given|When|Then|And|But|StepDefinition")\n) @root\n'
      ],
      convertParameterTypeExpression: function(expression) {
        if (expression === null) {
          return /.*/;
        }
        return convertExpression(expression);
      },
      convertStepDefinitionExpression: function(expression) {
        return convertExpression(expression);
      },
      buildParameterTypeLinks: function(matches) {
        var e_1, _a, e_2, _b;
        var parameterTypeLinks = [];
        var propsByName = {};
        try {
          for (var matches_1 = __values(matches), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
            var _c = matches_1_1.value, source = _c.source, match = _c.match;
            var nameNode = syntaxNode(match, "name");
            var expressionNode = syntaxNode(match, "expression");
            var rootNode = syntaxNode(match, "root");
            if (nameNode && rootNode) {
              var parameterTypeName = (0, helpers_js_1.stripQuotes)(nameNode.text);
              var selectionNode = expressionNode || nameNode;
              var locationLink = (0, helpers_js_1.createLocationLink)(rootNode, selectionNode, source.uri);
              var props = propsByName[parameterTypeName] = propsByName[parameterTypeName] || { locationLink, regexps: [] };
              var parameterTypeExpression = expressionNode ? expressionNode.text : null;
              props.regexps.push(this.convertParameterTypeExpression(parameterTypeExpression));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (matches_1_1 && !matches_1_1.done && (_a = matches_1.return))
              _a.call(matches_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        try {
          for (var _d = __values(Object.entries(propsByName)), _e = _d.next(); !_e.done; _e = _d.next()) {
            var _f = __read(_e.value, 2), name_1 = _f[0], _g = _f[1], regexps = _g.regexps, locationLink = _g.locationLink;
            var parameterType = (0, helpers_js_1.makeParameterType)(name_1, regexps);
            parameterTypeLinks.push({ parameterType, locationLink });
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_e && !_e.done && (_b = _d.return))
              _b.call(_d);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        return parameterTypeLinks;
      },
      snippetParameters: {
        int: { type: "int", name: "i" },
        float: { type: "float", name: "f" },
        word: { type: "string" },
        string: { type: "string", name: "s" },
        double: { type: "double", name: "d" },
        bigdecimal: { type: "BigDecimal", name: "bigDecimal" },
        byte: { type: "byte", name: "b" },
        short: { type: "short", name: "s" },
        long: { type: "long", name: "l" },
        biginteger: { type: "BigInteger", name: "bigInteger" },
        "": { type: "object", name: "arg" }
      },
      defaultSnippetTemplate: '\n    // This step definition uses Cucumber Expressions. See https://github.com/gasparnagy/CucumberExpressions.SpecFlow\n    [{{ keyword }}("{{ expression }}")]\n    public void {{ #capitalize }}{{ #camelize }}{{ keyword }} {{expression}}{{ /camelize }}{{ /capitalize }}({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ type }} {{ name }}{{ /parameters }})\n    {\n        // {{ blurb }}\n    }\n'
    };
    function convertExpression(expression) {
      var match = expression.match(/^(@)?"(.*)"$/);
      if (!match)
        throw new Error("Could not match ".concat(expression));
      if (match[1] === "@") {
        return new RegExp(unescapeVerbatimString(match[2]));
      } else {
        return unescapeString(match[2]);
      }
    }
    function unescapeVerbatimString(s) {
      return s.replace(/""/g, '"');
    }
    function unescapeString(s) {
      return s.replace(/\\\\/g, "\\");
    }
    function syntaxNode(match, name) {
      var _a;
      return (_a = match.captures.find(function(c) {
        return c.name === name;
      })) === null || _a === void 0 ? void 0 : _a.node;
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/javaLanguage.js
var require_javaLanguage = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/javaLanguage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.javaLanguage = void 0;
    var helpers_js_1 = require_helpers();
    exports2.javaLanguage = {
      defineParameterTypeQueries: [
        '\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (string_literal) @expression\n        ]\n      )\n    )\n  )\n  name: (identifier) @name\n  (#eq? @annotation-name "ParameterType")\n) @root\n    ',
        '\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (\n            (element_value_pair\n              key: (identifier) @name-key\n              value: (string_literal) @name\n            )\n            (element_value_pair\n              key: (identifier) @value-key\n              value: (string_literal) @expression\n            )\n          )\n          (\n            (element_value_pair\n              key: (identifier) @value-key\n              value: (string_literal) @expression\n            )\n            (element_value_pair\n              key: (identifier) @name-key\n              value: (string_literal) @name\n            )\n          )\n        ]\n      )\n    )\n  )\n  (#eq? @annotation-name "ParameterType")\n  (#eq? @name-key "name")\n  (#eq? @value-key "value")\n) @root\n'
      ],
      defineStepDefinitionQueries: [
        '\n(method_declaration \n  (modifiers \n    (annotation \n      name: (identifier) @annotation-name \n      arguments: (annotation_argument_list\n        [\n          (string_literal) @expression\n        ]\n      )\n    )\n  )\n  (#match? @annotation-name "Given|When|Then")\n) @root\n'
      ],
      convertParameterTypeExpression: function(expression) {
        if (expression === null)
          throw new Error("expression cannot be null");
        var match = expression.match(/^"(.*)"$/);
        if (!match)
          throw new Error("Could not match ".concat(expression));
        return new RegExp(unescapeString(match[1]));
      },
      convertStepDefinitionExpression: function(expression) {
        var match = expression.match(/^"(\^.*\$)"$/);
        if (match) {
          return new RegExp(unescapeString(match[1]));
        }
        return unescapeString(expression.substring(1, expression.length - 1));
      },
      buildParameterTypeLinks: function(matches) {
        return (0, helpers_js_1.buildParameterTypeLinksFromMatches)(matches);
      },
      snippetParameters: {
        int: { type: "int", name: "i" },
        float: { type: "float", name: "f" },
        word: { type: "String" },
        string: { type: "String", name: "s" },
        double: { type: "double", name: "d" },
        bigdecimal: { type: "java.math.BigDecimal", name: "bigDecimal" },
        byte: { type: "byte", name: "b" },
        short: { type: "short", name: "s" },
        long: { type: "long", name: "l" },
        biginteger: { type: "java.math.BigInteger", name: "bigInteger" },
        "": { type: "Object", name: "arg" }
      },
      defaultSnippetTemplate: '\n    @{{ keyword }}("{{ expression }}")\n    public void {{ #underscore }}{{ expression }}{{ /underscore }}({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ type }} {{ name }}{{ /parameters }}) {\n        // {{ blurb }}\n    }\n'
    };
    function unescapeString(s) {
      return s.replace(/\\\\/g, "\\");
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/phpLanguage.js
var require_phpLanguage = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/phpLanguage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.phpLanguage = void 0;
    var helpers_js_1 = require_helpers();
    exports2.phpLanguage = {
      defineParameterTypeQueries: [],
      defineStepDefinitionQueries: [
        '\n(\n  (comment)+ @expression\n  (#match? @expression "Given|When|Then")\n) @root\n'
      ],
      convertParameterTypeExpression: function(expression) {
        throw new Error("Unsupported operation");
      },
      convertStepDefinitionExpression: function(expression) {
        var match = expression.match(/^(\/\*\*[\s*]*)([\s\S]*)(\n[\s]*\*\/)/);
        if (!match)
          throw new Error("Could not match ".concat(expression));
        return new RegExp(match[2].replace(/@(Given |When |Then )/, "").trim());
      },
      buildParameterTypeLinks: function(matches) {
        return (0, helpers_js_1.buildParameterTypeLinksFromMatches)(matches);
      },
      snippetParameters: {
        int: { type: "int", name: "i" },
        float: { type: "float", name: "f" },
        word: { type: "string" },
        string: { type: "string", name: "s" },
        double: { type: "float", name: "d" },
        bigdecimal: { type: "string", name: "bigDecimal" },
        byte: { type: "int", name: "b" },
        short: { type: "int", name: "s" },
        long: { type: "int", name: "l" },
        biginteger: { type: "int", name: "bigInteger" },
        "": { type: "Object", name: "arg" }
      },
      defaultSnippetTemplate: "\n    /**\n     * {{ keyword }} {{ expression }}\n     */\n    public function {{ #camelize }}{{ expression }}{{ /camelize }}({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}{{ /parameters }})\n    {\n        // {{ blurb }}\n    }\n"
    };
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/rubyLanguage.js
var require_rubyLanguage = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/rubyLanguage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.rubyLanguage = void 0;
    var helpers_js_1 = require_helpers();
    exports2.rubyLanguage = {
      defineParameterTypeQueries: [
        '\n(call\n  method: (constant) @method\n  arguments: (argument_list\n    [\n      (\n        (pair\n          key: (hash_key_symbol) @name-key\n          value: (string) @name\n        )\n        (pair\n          key: (hash_key_symbol) @regexp-key\n          value: (regex) @expression\n        )\n      )\n      (\n        (pair\n          key: (hash_key_symbol) @regexp-key\n          value: (regex) @expression\n        )\n        (pair\n          key: (hash_key_symbol) @name-key\n          value: (string) @name\n        )\n      )\n    ]\n  )\n  (#eq? @method "ParameterType")\n  (#eq? @name-key "name")\n  (#eq? @regexp-key "regexp")\n) @root\n'
      ],
      defineStepDefinitionQueries: [
        '\n(call\n  method: (constant) @method\n  arguments: (argument_list\n    [\n      (string) @expression\n      (regex) @expression\n    ]\n  )\n  (#match? @method "(Given|When|Then)$")\n) @root\n'
      ],
      convertParameterTypeExpression: function(expression) {
        if (expression === null)
          throw new Error("expression cannot be null");
        return toStringOrRegExp(expression);
      },
      convertStepDefinitionExpression: function(expression) {
        return toStringOrRegExp(expression);
      },
      buildParameterTypeLinks: function(matches) {
        return (0, helpers_js_1.buildParameterTypeLinksFromMatches)(matches);
      },
      snippetParameters: {
        int: { type: "Integer" },
        float: { type: "Float" },
        word: { type: "String" },
        string: { type: "String" },
        double: { type: "Float" },
        bigdecimal: { type: "BigDecimal" },
        byte: { type: "Integer" },
        short: { type: "Integer" },
        long: { type: "Integer" },
        biginteger: { type: "Integer" },
        "": { type: "Object", name: "arg" }
      },
      defaultSnippetTemplate: "\n{{ keyword }}('{{ expression }}') do |{{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}{{ /parameters }}|\n  // {{ blurb }}\nend\n"
    };
    function toStringOrRegExp(s) {
      var match = s.match(/^([/'"])(.*)([/'"])$/);
      if (!match)
        throw new Error("Could not match '".concat(s, "'"));
      if (match[1] === "/" && match[3] === "/")
        return new RegExp(match[2]);
      return match[2];
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/typescriptLanguage.js
var require_typescriptLanguage = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/typescriptLanguage.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.typescriptLanguage = void 0;
    var helpers_js_1 = require_helpers();
    exports2.typescriptLanguage = {
      defineParameterTypeQueries: [
        '\n(call_expression\n  function: (identifier) @function-name\n  arguments: (arguments\n    (object\n      [\n        (\n          (pair\n            key: (property_identifier) @name-key\n            value: (string) @name\n          )\n          (pair\n            key: (property_identifier) @regexp-key\n            value: [(regex) (string)] @expression\n          )\n        )\n        (\n          (pair\n            key: (property_identifier) @regexp-key\n            value: [(regex) (string)] @expression\n          )\n          (pair\n            key: (property_identifier) @name-key\n            value: (string) @name\n          )\n        )\n      ]\n    )\n  )\n  (#eq? @function-name "defineParameterType")\n  (#eq? @name-key "name")\n  (#eq? @regexp-key "regexp")\n) @root\n'
      ],
      defineStepDefinitionQueries: [
        '\n(call_expression\n  function: (identifier) @function-name\n  arguments: (arguments\n    [\n      (string) @expression\n      (regex) @expression\n    ]\n  )\n  (#match? @function-name "Given|When|Then")\n) @root\n'
      ],
      convertParameterTypeExpression: function(expression) {
        if (expression === null)
          throw new Error("expression cannot be null");
        return toStringOrRegExp(expression);
      },
      convertStepDefinitionExpression: function(expression) {
        return toStringOrRegExp(expression);
      },
      buildParameterTypeLinks: function(matches) {
        return (0, helpers_js_1.buildParameterTypeLinksFromMatches)(matches);
      },
      snippetParameters: {
        int: { type: "number" },
        float: { type: "number" },
        word: { type: "string" },
        string: { type: "string", name: "s" },
        double: { type: "number" },
        bigdecimal: { type: "string", name: "bigDecimal" },
        byte: { type: "number" },
        short: { type: "number" },
        long: { type: "number" },
        biginteger: { type: "BigInt", name: "bigInt" },
        "": { type: "unknown", name: "arg" }
      },
      defaultSnippetTemplate: "\n{{ keyword }}('{{ expression }}', ({{ #parameters }}{{ #seenParameter }}, {{ /seenParameter }}{{ name }}: {{ type }}{{ /parameters }}) => {\n  // {{ blurb }}\n})\n"
    };
    function toStringOrRegExp(s) {
      var match = s.match(/^([/'"])(.*)([/'"])$/);
      if (!match)
        throw new Error("Could not match ".concat(s));
      if (match[1] === "/" && match[3] === "/")
        return new RegExp(match[2]);
      return match[2];
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/languages.js
var require_languages = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/languages.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getLanguage = void 0;
    var csharpLanguage_js_1 = require_csharpLanguage();
    var javaLanguage_js_1 = require_javaLanguage();
    var phpLanguage_js_1 = require_phpLanguage();
    var rubyLanguage_js_1 = require_rubyLanguage();
    var typescriptLanguage_js_1 = require_typescriptLanguage();
    var languageByName = {
      java: javaLanguage_js_1.javaLanguage,
      typescript: typescriptLanguage_js_1.typescriptLanguage,
      c_sharp: csharpLanguage_js_1.csharpLanguage,
      php: phpLanguage_js_1.phpLanguage,
      ruby: rubyLanguage_js_1.rubyLanguage
    };
    function getLanguage(languageName) {
      return languageByName[languageName];
    }
    exports2.getLanguage = getLanguage;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/helpers.js
var require_helpers = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/helpers.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildParameterTypeLinksFromMatches = exports2.createLocationLink = exports2.sortLinks = exports2.makeParameterType = exports2.syntaxNode = exports2.stripQuotes = void 0;
    var cucumber_expressions_1 = require_src5();
    var vscode_languageserver_types_1 = require_main2();
    var languages_js_1 = require_languages();
    function stripQuotes(s) {
      var match = s.match(/^['"](.*)['"]$/);
      if (!match)
        return s;
      return match[1];
    }
    exports2.stripQuotes = stripQuotes;
    function syntaxNode(match, name) {
      var _a;
      return (_a = match.captures.find(function(c) {
        return c.name === name;
      })) === null || _a === void 0 ? void 0 : _a.node;
    }
    exports2.syntaxNode = syntaxNode;
    function makeParameterType(name, regexps) {
      return new cucumber_expressions_1.ParameterType(name, regexps, Object, function(arg) {
        return arg;
      }, true, false);
    }
    exports2.makeParameterType = makeParameterType;
    function sortLinks(links) {
      return links.sort(function(a, b) {
        var pathComparison = a.locationLink.targetUri.localeCompare(b.locationLink.targetUri);
        if (pathComparison !== 0)
          return pathComparison;
        return a.locationLink.targetRange.start.line - b.locationLink.targetRange.start.line;
      });
    }
    exports2.sortLinks = sortLinks;
    function createLocationLink(rootNode, selectionNode, targetUri) {
      var targetRange = vscode_languageserver_types_1.Range.create(rootNode.startPosition.row, rootNode.startPosition.column, rootNode.endPosition.row, rootNode.endPosition.column);
      var targetSelectionRange = vscode_languageserver_types_1.Range.create(selectionNode.startPosition.row, selectionNode.startPosition.column, selectionNode.endPosition.row, selectionNode.endPosition.column);
      var locationLink = {
        targetRange,
        targetSelectionRange,
        targetUri
      };
      return locationLink;
    }
    exports2.createLocationLink = createLocationLink;
    function buildParameterTypeLinksFromMatches(parameterTypeMatches) {
      var e_1, _a;
      var parameterTypeLinks = [];
      try {
        for (var parameterTypeMatches_1 = __values(parameterTypeMatches), parameterTypeMatches_1_1 = parameterTypeMatches_1.next(); !parameterTypeMatches_1_1.done; parameterTypeMatches_1_1 = parameterTypeMatches_1.next()) {
          var _b = parameterTypeMatches_1_1.value, source = _b.source, match = _b.match;
          var nameNode = syntaxNode(match, "name");
          var expressionNode = syntaxNode(match, "expression");
          var rootNode = syntaxNode(match, "root");
          if (nameNode && rootNode) {
            var parameterTypeExpression = expressionNode ? expressionNode.text : null;
            var language = (0, languages_js_1.getLanguage)(source.languageName);
            var parameterType = makeParameterType(stripQuotes(nameNode.text), language.convertParameterTypeExpression(parameterTypeExpression));
            var selectionNode = expressionNode || nameNode;
            var locationLink = createLocationLink(rootNode, selectionNode, source.uri);
            parameterTypeLinks.push({ parameterType, locationLink });
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (parameterTypeMatches_1_1 && !parameterTypeMatches_1_1.done && (_a = parameterTypeMatches_1.return))
            _a.call(parameterTypeMatches_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return parameterTypeLinks;
    }
    exports2.buildParameterTypeLinksFromMatches = buildParameterTypeLinksFromMatches;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/SourceAnalyzer.js
var require_SourceAnalyzer = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/SourceAnalyzer.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SourceAnalyzer = void 0;
    var languages_js_1 = require_languages();
    var SourceAnalyzer = function() {
      function SourceAnalyzer2(parserAdapter, sources) {
        this.parserAdapter = parserAdapter;
        this.sources = sources;
        this.errors = [];
        this.treeByContent = /* @__PURE__ */ new Map();
      }
      SourceAnalyzer2.prototype.getSourceMatches = function(getQueryStrings) {
        var e_1, _a, e_2, _b, e_3, _c;
        var result = /* @__PURE__ */ new Map();
        try {
          for (var _d = __values(this.sources), _e = _d.next(); !_e.done; _e = _d.next()) {
            var source = _e.value;
            this.parserAdapter.setLanguageName(source.languageName);
            var tree = void 0;
            try {
              tree = this.parse(source);
            } catch (err) {
              err.message += "\nuri: ".concat(source.uri);
              this.errors.push(err);
              continue;
            }
            var language = (0, languages_js_1.getLanguage)(source.languageName);
            var queryStrings = getQueryStrings(language);
            try {
              for (var queryStrings_1 = (e_2 = void 0, __values(queryStrings)), queryStrings_1_1 = queryStrings_1.next(); !queryStrings_1_1.done; queryStrings_1_1 = queryStrings_1.next()) {
                var queryString = queryStrings_1_1.value;
                var query = this.parserAdapter.query(queryString);
                var matches = query.matches(tree.rootNode);
                try {
                  for (var matches_1 = (e_3 = void 0, __values(matches)), matches_1_1 = matches_1.next(); !matches_1_1.done; matches_1_1 = matches_1.next()) {
                    var match = matches_1_1.value;
                    var sourceMatches = result.get(language) || [];
                    result.set(language, sourceMatches);
                    sourceMatches.push({ source, match });
                  }
                } catch (e_3_1) {
                  e_3 = { error: e_3_1 };
                } finally {
                  try {
                    if (matches_1_1 && !matches_1_1.done && (_c = matches_1.return))
                      _c.call(matches_1);
                  } finally {
                    if (e_3)
                      throw e_3.error;
                  }
                }
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (queryStrings_1_1 && !queryStrings_1_1.done && (_b = queryStrings_1.return))
                  _b.call(queryStrings_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_e && !_e.done && (_a = _d.return))
              _a.call(_d);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        return result;
      };
      SourceAnalyzer2.prototype.getErrors = function() {
        return this.errors;
      };
      SourceAnalyzer2.prototype.parse = function(source) {
        var tree = this.treeByContent.get(source);
        if (!tree) {
          this.treeByContent.set(source, tree = this.parserAdapter.parser.parse(source.content));
        }
        return tree;
      };
      return SourceAnalyzer2;
    }();
    exports2.SourceAnalyzer = SourceAnalyzer;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/ExpressionBuilder.js
var require_ExpressionBuilder = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/ExpressionBuilder.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExpressionBuilder = void 0;
    var cucumber_expressions_1 = require_src5();
    var helpers_js_1 = require_helpers();
    var languages_js_1 = require_languages();
    var SourceAnalyzer_js_1 = require_SourceAnalyzer();
    var ExpressionBuilder = function() {
      function ExpressionBuilder2(parserAdapter) {
        this.parserAdapter = parserAdapter;
      }
      ExpressionBuilder2.prototype.build = function(sources, parameterTypes) {
        var e_1, _a, e_2, _b, e_3, _c, e_4, _d, e_5, _e;
        var expressionLinks = [];
        var errors = [];
        var registry = new cucumber_expressions_1.ParameterTypeRegistry();
        var expressionFactory = new cucumber_expressions_1.ExpressionFactory(registry);
        function defineParameterType(parameterType2) {
          try {
            registry.defineParameterType(parameterType2);
          } catch (err) {
            errors.push(err);
          }
        }
        try {
          for (var parameterTypes_1 = __values(parameterTypes), parameterTypes_1_1 = parameterTypes_1.next(); !parameterTypes_1_1.done; parameterTypes_1_1 = parameterTypes_1.next()) {
            var parameterType = parameterTypes_1_1.value;
            defineParameterType((0, helpers_js_1.makeParameterType)(parameterType.name, new RegExp(parameterType.regexp)));
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (parameterTypes_1_1 && !parameterTypes_1_1.done && (_a = parameterTypes_1.return))
              _a.call(parameterTypes_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var sourceAnalyser = new SourceAnalyzer_js_1.SourceAnalyzer(this.parserAdapter, sources);
        var parameterTypeMatches = sourceAnalyser.getSourceMatches(function(language2) {
          return language2.defineParameterTypeQueries;
        });
        var parameterTypeLinks = [];
        try {
          for (var _f = __values(parameterTypeMatches.entries()), _g = _f.next(); !_g.done; _g = _f.next()) {
            var _h = __read(_g.value, 2), language = _h[0], matches = _h[1];
            var links = language.buildParameterTypeLinks(matches);
            parameterTypeLinks = parameterTypeLinks.concat(links);
            try {
              for (var links_1 = (e_3 = void 0, __values(links)), links_1_1 = links_1.next(); !links_1_1.done; links_1_1 = links_1.next()) {
                var parameterType = links_1_1.value.parameterType;
                defineParameterType(parameterType);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (links_1_1 && !links_1_1.done && (_c = links_1.return))
                  _c.call(links_1);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (_g && !_g.done && (_b = _f.return))
              _b.call(_f);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
        var stepDefinitionMatches = sourceAnalyser.getSourceMatches(function(language2) {
          return language2.defineStepDefinitionQueries;
        });
        try {
          for (var _j = __values(stepDefinitionMatches.entries()), _k = _j.next(); !_k.done; _k = _j.next()) {
            var _l = __read(_k.value, 2), sourceMatches = _l[1];
            try {
              for (var sourceMatches_1 = (e_5 = void 0, __values(sourceMatches)), sourceMatches_1_1 = sourceMatches_1.next(); !sourceMatches_1_1.done; sourceMatches_1_1 = sourceMatches_1.next()) {
                var _m = sourceMatches_1_1.value, source = _m.source, match = _m.match;
                var expressionNode = (0, helpers_js_1.syntaxNode)(match, "expression");
                var rootNode = (0, helpers_js_1.syntaxNode)(match, "root");
                if (expressionNode && rootNode) {
                  var language = (0, languages_js_1.getLanguage)(source.languageName);
                  var stringOrRegexp = language.convertStepDefinitionExpression(expressionNode.text);
                  try {
                    var expression = expressionFactory.createExpression(stringOrRegexp);
                    var locationLink = (0, helpers_js_1.createLocationLink)(rootNode, expressionNode, source.uri);
                    expressionLinks.push({ expression, locationLink });
                  } catch (err) {
                    errors.push(err);
                  }
                }
              }
            } catch (e_5_1) {
              e_5 = { error: e_5_1 };
            } finally {
              try {
                if (sourceMatches_1_1 && !sourceMatches_1_1.done && (_e = sourceMatches_1.return))
                  _e.call(sourceMatches_1);
              } finally {
                if (e_5)
                  throw e_5.error;
              }
            }
          }
        } catch (e_4_1) {
          e_4 = { error: e_4_1 };
        } finally {
          try {
            if (_k && !_k.done && (_d = _j.return))
              _d.call(_j);
          } finally {
            if (e_4)
              throw e_4.error;
          }
        }
        return {
          expressionLinks: (0, helpers_js_1.sortLinks)(expressionLinks),
          parameterTypeLinks: (0, helpers_js_1.sortLinks)(parameterTypeLinks),
          errors: sourceAnalyser.getErrors().concat(errors),
          registry
        };
      };
      return ExpressionBuilder2;
    }();
    exports2.ExpressionBuilder = ExpressionBuilder;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/language/index.js
var require_language = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/language/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_ExpressionBuilder(), exports2);
    __exportStar(require_types(), exports2);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/helpers.js
var require_helpers2 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeKey = void 0;
    function makeKey(parameterType) {
      return parameterType.name || parameterType.regexpStrings.join("|");
    }
    exports2.makeKey = makeKey;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestionFromCucumberExpression.js
var require_buildSuggestionFromCucumberExpression = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestionFromCucumberExpression.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSuggestionFromCucumberExpression = void 0;
    var cucumber_expressions_1 = require_src5();
    var helpers_js_1 = require_helpers2();
    function buildSuggestionFromCucumberExpression(expression, registry, parameterChoices) {
      try {
        var compiledSegments = compile(expression.ast, registry, parameterChoices);
        var segments = flatten(compiledSegments);
        return {
          label: expression.source,
          segments,
          matched: true
        };
      } catch (err) {
        err.message += '\nUnable to compile Cucumber Expression "'.concat(expression.source, '"\nPlease submit an issue at https://github.com/cucumber/language-service/issues\n');
        throw err;
      }
    }
    exports2.buildSuggestionFromCucumberExpression = buildSuggestionFromCucumberExpression;
    function flatten(cr) {
      if (typeof cr === "string")
        return [cr];
      return cr.reduce(function(prev, curr) {
        var last = prev[prev.length - 1];
        if (typeof curr === "string") {
          if (typeof last === "string") {
            return prev.slice(0, prev.length - 1).concat([last + curr]);
          } else {
            return prev.concat(curr);
          }
        } else {
          var x = curr.flatMap(function(e) {
            if (typeof e === "string")
              return e;
            var e0 = e[0];
            if (!(typeof e0 === "string"))
              throw new Error("Unexpected array: " + JSON.stringify(e));
            return e0;
          });
          return prev.concat([x]);
        }
      }, []);
    }
    function compile(node, registry, parameterChoices) {
      switch (node.type) {
        case cucumber_expressions_1.NodeType.text:
          return node.text();
        case cucumber_expressions_1.NodeType.optional:
          return compileOptional(node);
        case cucumber_expressions_1.NodeType.alternation:
          return compileAlternation(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.alternative:
          return compileAlternative(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.parameter:
          return compileParameter(node, registry, parameterChoices);
        case cucumber_expressions_1.NodeType.expression:
          return compileExpression(node, registry, parameterChoices);
        default:
          throw new Error(node.type);
      }
    }
    function compileOptional(node) {
      if (node.nodes === void 0)
        throw new Error("No optional");
      return [node.nodes.map(function(node2) {
        return node2.text();
      }).join("")];
    }
    function compileAlternation(node, registry, parameterChoices) {
      return (node.nodes || []).map(function(node2) {
        return compile(node2, registry, parameterChoices);
      });
    }
    function compileAlternative(node, registry, parameterChoices) {
      return (node.nodes || []).map(function(node2) {
        return compile(node2, registry, parameterChoices);
      });
    }
    function compileParameter(node, registry, parameterChoices) {
      var parameterType = registry.lookupByTypeName(node.text());
      if (parameterType === void 0)
        throw new Error("No parameter type named ".concat(node.text()));
      var key = (0, helpers_js_1.makeKey)(parameterType);
      return parameterChoices[key] || defaultParameterChoices(parameterType) || [""];
    }
    function compileExpression(node, registry, parameterChoices) {
      return (node.nodes || []).reduce(function(prev, curr) {
        var child = compile(curr, registry, parameterChoices);
        if (curr.type === cucumber_expressions_1.NodeType.optional) {
          var last = prev[prev.length - 1];
          if (!Array.isArray(child)) {
            throw new Error("Expected an array, but was ".concat(JSON.stringify(child)));
          }
          if (typeof last !== "string" || last.trim() === "") {
            return prev.concat(child[0]);
          }
          return prev.slice(0, prev.length - 1).concat([[last, last + child[0]]]);
        } else {
          return prev.concat([child]);
        }
      }, []);
    }
    function defaultParameterChoices(parameterType) {
      if (parameterType.type === Number) {
        return ["0"];
      }
      return ["?"];
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestionsFromRegularExpression.js
var require_buildSuggestionsFromRegularExpression = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestionsFromRegularExpression.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSuggestionsFromRegularExpression = void 0;
    function buildSuggestionsFromRegularExpression(expression, registry, stepTexts, parameterChoices) {
      var e_1, _a;
      var segmentJsons = /* @__PURE__ */ new Set();
      try {
        for (var stepTexts_1 = __values(stepTexts), stepTexts_1_1 = stepTexts_1.next(); !stepTexts_1_1.done; stepTexts_1_1 = stepTexts_1.next()) {
          var text = stepTexts_1_1.value;
          var args = expression.match(text);
          if (args) {
            var parameterTypes = args.map(function(arg2) {
              return arg2.getParameterType();
            });
            var segments = [];
            var index = 0;
            for (var argIndex = 0; argIndex < args.length; argIndex++) {
              var arg = args[argIndex];
              var textSegment = text.substring(index, arg.group.start);
              segments.push(textSegment);
              var parameterType = parameterTypes[argIndex];
              var key = parameterType.regexpStrings.join("|");
              var parameterSegment = parameterChoices[key] || ["..."];
              segments.push(parameterSegment);
              if (arg.group.end !== void 0)
                index = arg.group.end;
            }
            var lastSegment = text.substring(index);
            if (lastSegment !== "") {
              segments.push(lastSegment);
            }
            segmentJsons.add(JSON.stringify(segments));
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (stepTexts_1_1 && !stepTexts_1_1.done && (_a = stepTexts_1.return))
            _a.call(stepTexts_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return __spreadArray([], __read(segmentJsons), false).sort().map(function(s, n) {
        return {
          segments: JSON.parse(s),
          label: n == 0 ? expression.source : "".concat(expression.source, " (").concat(n + 1, ")"),
          matched: true
        };
      });
    }
    exports2.buildSuggestionsFromRegularExpression = buildSuggestionsFromRegularExpression;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestions.js
var require_buildSuggestions = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/buildSuggestions.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildSuggestions = void 0;
    var cucumber_expressions_1 = require_src5();
    var buildSuggestionFromCucumberExpression_js_1 = require_buildSuggestionFromCucumberExpression();
    var buildSuggestionsFromRegularExpression_js_1 = require_buildSuggestionsFromRegularExpression();
    var helpers_js_1 = require_helpers2();
    function buildSuggestions(registry, stepTexts, expressions, maxChoices) {
      var e_1, _a, e_2, _b, e_3, _c, e_4, _d;
      if (maxChoices === void 0) {
        maxChoices = 10;
      }
      var suggestions = [];
      var parameterChoiceSets = {};
      var unmatchedStepTexts = new Set(stepTexts);
      try {
        for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
          var expression = expressions_1_1.value;
          try {
            for (var stepTexts_1 = (e_2 = void 0, __values(stepTexts)), stepTexts_1_1 = stepTexts_1.next(); !stepTexts_1_1.done; stepTexts_1_1 = stepTexts_1.next()) {
              var text = stepTexts_1_1.value;
              var args = expression.match(text);
              if (args) {
                var parameterTypes = args.map(function(arg2) {
                  return arg2.getParameterType();
                });
                for (var argIndex = 0; argIndex < args.length; argIndex++) {
                  var arg = args[argIndex];
                  var parameterType = parameterTypes[argIndex];
                  var key = (0, helpers_js_1.makeKey)(parameterType);
                  var choices = parameterChoiceSets[key];
                  if (!choices) {
                    parameterChoiceSets[key] = choices = /* @__PURE__ */ new Set();
                  }
                  if (arg.group.value !== void 0)
                    choices.add(arg.group.value);
                }
                unmatchedStepTexts.delete(text);
              }
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (stepTexts_1_1 && !stepTexts_1_1.done && (_b = stepTexts_1.return))
                _b.call(stepTexts_1);
            } finally {
              if (e_2)
                throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return))
            _a.call(expressions_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var parameterChoices = Object.fromEntries(Object.entries(parameterChoiceSets).map(function(_a2) {
        var _b2 = __read(_a2, 2), key2 = _b2[0], choices2 = _b2[1];
        return [
          key2,
          __spreadArray([], __read(choices2), false).sort().slice(0, maxChoices)
        ];
      }));
      try {
        for (var expressions_2 = __values(expressions), expressions_2_1 = expressions_2.next(); !expressions_2_1.done; expressions_2_1 = expressions_2.next()) {
          var expression = expressions_2_1.value;
          if (expression instanceof cucumber_expressions_1.CucumberExpression) {
            suggestions = suggestions.concat((0, buildSuggestionFromCucumberExpression_js_1.buildSuggestionFromCucumberExpression)(expression, registry, parameterChoices));
          }
          if (expression instanceof cucumber_expressions_1.RegularExpression) {
            suggestions = suggestions.concat((0, buildSuggestionsFromRegularExpression_js_1.buildSuggestionsFromRegularExpression)(expression, registry, stepTexts, parameterChoices));
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (expressions_2_1 && !expressions_2_1.done && (_c = expressions_2.return))
            _c.call(expressions_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      try {
        for (var unmatchedStepTexts_1 = __values(unmatchedStepTexts), unmatchedStepTexts_1_1 = unmatchedStepTexts_1.next(); !unmatchedStepTexts_1_1.done; unmatchedStepTexts_1_1 = unmatchedStepTexts_1.next()) {
          var stepText = unmatchedStepTexts_1_1.value;
          suggestions.push({
            label: stepText,
            segments: [stepText],
            matched: false
          });
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (unmatchedStepTexts_1_1 && !unmatchedStepTexts_1_1.done && (_d = unmatchedStepTexts_1.return))
            _d.call(unmatchedStepTexts_1);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
      return suggestions.sort(function(a, b) {
        return a.label.localeCompare(b.label);
      });
    }
    exports2.buildSuggestions = buildSuggestions;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/messages/MessagesBuilder.js
var require_MessagesBuilder = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/messages/MessagesBuilder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessagesBuilder = void 0;
    var cucumber_expressions_1 = require_src5();
    var messages_1 = require_src3();
    var extractStepTexts_js_1 = require_extractStepTexts();
    var buildSuggestions_js_1 = require_buildSuggestions();
    var MessagesBuilder = function() {
      function MessagesBuilder2() {
        this.parameterTypeRegistry = new cucumber_expressions_1.ParameterTypeRegistry();
        this.expressionFactory = new cucumber_expressions_1.ExpressionFactory(this.parameterTypeRegistry);
        this.expressions = [];
        this.stepTexts = [];
      }
      MessagesBuilder2.prototype.processEnvelope = function(envelope, errorHandler) {
        if (errorHandler === void 0) {
          errorHandler = function() {
            return void 0;
          };
        }
        if (envelope.parameterType) {
          var _a = envelope.parameterType, name_1 = _a.name, regularExpressions = _a.regularExpressions, useForSnippets = _a.useForSnippets, preferForRegularExpressionMatch = _a.preferForRegularExpressionMatch;
          try {
            this.parameterTypeRegistry.defineParameterType(new cucumber_expressions_1.ParameterType(name_1, regularExpressions, Object, function() {
              return void 0;
            }, useForSnippets, preferForRegularExpressionMatch));
          } catch (err) {
            errorHandler(err);
          }
        }
        if (envelope.stepDefinition) {
          var expr = envelope.stepDefinition.pattern.type === messages_1.StepDefinitionPatternType.CUCUMBER_EXPRESSION ? envelope.stepDefinition.pattern.source : new RegExp(envelope.stepDefinition.pattern.source);
          try {
            var expression = this.expressionFactory.createExpression(expr);
            this.expressions.push(expression);
          } catch (err) {
            errorHandler(err);
          }
        }
        if (envelope.gherkinDocument) {
          this.stepTexts = (0, extractStepTexts_js_1.extractStepTexts)(envelope.gherkinDocument, this.stepTexts);
        }
      };
      MessagesBuilder2.prototype.build = function() {
        return {
          suggestions: (0, buildSuggestions_js_1.buildSuggestions)(this.parameterTypeRegistry, this.stepTexts, this.expressions),
          expressions: this.expressions
        };
      };
      return MessagesBuilder2;
    }();
    exports2.MessagesBuilder = MessagesBuilder;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/messages/index.js
var require_messages4 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/messages/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_MessagesBuilder(), exports2);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/constants.js
var require_constants = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.diagnosticCodeUndefinedStep = void 0;
    exports2.diagnosticCodeUndefinedStep = "cucumber.undefined-step";
  }
});

// node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/mustache/mustache.js"(exports2, module2) {
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = global2 || self, global2.Mustache = factory());
    })(exports2, function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s) {
          return entityMap[s];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match = this.tail.match(re);
        if (!match || match.index !== 0)
          return "";
        var string = match[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match;
        switch (index) {
          case -1:
            match = this.tail;
            this.tail = "";
            break;
          case 0:
            match = "";
            break;
          default:
            match = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match.length;
        return match;
      };
      function Context(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context.prototype.push = function push(view) {
        return new Context(view, this);
      };
      Context.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render(template, view, partials, config) {
        var tags = this.getConfigTags(config);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context ? view : new Context(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#")
            value = this.renderSection(token, context, partials, originalTemplate, config);
          else if (symbol === "^")
            value = this.renderInverted(token, context, partials, originalTemplate, config);
          else if (symbol === ">")
            value = this.renderPartial(token, context, partials, config);
          else if (symbol === "&")
            value = this.unescapedValue(token, context);
          else if (symbol === "name")
            value = this.escapedValue(token, context, config);
          else if (symbol === "text")
            value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config);
        }
        if (!value)
          return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config) {
        if (!partials)
          return;
        var tags = this.getConfigTags(config);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config) {
        var escape = this.getConfigEscape(config) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config) {
        if (isArray(config)) {
          return config;
        } else if (config && typeof config === "object") {
          return config.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config) {
        if (config && typeof config === "object" && !isArray(config)) {
          return config.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.2.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render(template, view, partials, config) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context;
      mustache.Writer = Writer;
      return mustache;
    });
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/snippet/stepDefinitionSnippet.js
var require_stepDefinitionSnippet = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/snippet/stepDefinitionSnippet.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stepDefinitionSnippet = void 0;
    var mustache_1 = __importDefault(require_mustache());
    function toWords(expression) {
      return expression.replace(/{[^}]*}/g, " ").replace(/[^a-zA-Z_]+/g, " ").trim().split(/\s+/);
    }
    var camelize = function() {
      return function(text, render) {
        return toWords(render(text)).map(function(word, i) {
          return i === 0 ? word.toLowerCase() : word[0].toUpperCase() + word.slice(1);
        }).join("");
      };
    };
    var underscore = function() {
      return function(text, render) {
        return toWords(render(text)).map(function(word, i) {
          return i === 0 ? word : "_".concat(word);
        }).join("");
      };
    };
    var capitalize = function() {
      return function(text, render) {
        var rendered = render(text);
        return rendered[0].toUpperCase() + rendered.slice(1);
      };
    };
    var blurb = "Write code here that turns the phrase above into concrete actions";
    function stepDefinitionSnippet(keyword, generatedExpressions, mustacheTemplate, snippetParameters) {
      var generatedExpression = generatedExpressions[0];
      var _seenParameter = false;
      var context = {
        keyword: keyword.trim(),
        expression: generatedExpression.source,
        parameters: generatedExpression.parameterInfos.map(function(parameterInfo) {
          var snippetParameter = snippetParameters[parameterInfo.name || ""];
          var name = (snippetParameter === null || snippetParameter === void 0 ? void 0 : snippetParameter.name) || parameterInfo.name || snippetParameters[""].name;
          var type = (snippetParameter === null || snippetParameter === void 0 ? void 0 : snippetParameter.type) || parameterInfo.name || snippetParameters[""].type;
          return {
            name: "".concat(name).concat(parameterInfo.count === 1 ? "" : parameterInfo.count.toString()),
            type
          };
        }),
        seenParameter: function() {
          try {
            return _seenParameter;
          } finally {
            _seenParameter = true;
          }
        },
        blurb,
        camelize,
        underscore,
        capitalize
      };
      return mustache_1.default.render(mustacheTemplate, context);
    }
    exports2.stepDefinitionSnippet = stepDefinitionSnippet;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getGenerateSnippetCodeAction.js
var require_getGenerateSnippetCodeAction = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getGenerateSnippetCodeAction.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGenerateSnippetCodeAction = void 0;
    var cucumber_expressions_1 = require_src5();
    var vscode_languageserver_types_1 = require_main2();
    var languages_js_1 = require_languages();
    var constants_js_1 = require_constants();
    var stepDefinitionSnippet_js_1 = require_stepDefinitionSnippet();
    function getGenerateSnippetCodeAction(diagnostics, link, relativePath, createFile, mustacheTemplate, languageName, registry) {
      var _a, _b;
      var undefinedStepDiagnostic = diagnostics.find(function(d) {
        return d.code === constants_js_1.diagnosticCodeUndefinedStep;
      });
      var language = (0, languages_js_1.getLanguage)(languageName);
      var snippetKeyword = (_a = undefinedStepDiagnostic === null || undefinedStepDiagnostic === void 0 ? void 0 : undefinedStepDiagnostic.data) === null || _a === void 0 ? void 0 : _a.snippetKeyword;
      var stepText = (_b = undefinedStepDiagnostic === null || undefinedStepDiagnostic === void 0 ? void 0 : undefinedStepDiagnostic.data) === null || _b === void 0 ? void 0 : _b.stepText;
      if (!undefinedStepDiagnostic || !stepText) {
        return null;
      }
      var generator = new cucumber_expressions_1.CucumberExpressionGenerator(function() {
        return registry.parameterTypes;
      });
      var generatedExpressions = generator.generateExpressions(stepText);
      var snippet = (0, stepDefinitionSnippet_js_1.stepDefinitionSnippet)(snippetKeyword, generatedExpressions, mustacheTemplate || language.defaultSnippetTemplate, language.snippetParameters);
      var documentChanges = [];
      if (createFile) {
        documentChanges.push(vscode_languageserver_types_1.CreateFile.create(link.targetUri, {
          ignoreIfExists: true,
          overwrite: true
        }));
      }
      documentChanges.push(vscode_languageserver_types_1.TextDocumentEdit.create(vscode_languageserver_types_1.VersionedTextDocumentIdentifier.create(link.targetUri, 0), [
        vscode_languageserver_types_1.TextEdit.replace(link.targetRange, snippet)
      ]));
      return {
        title: "Define in ".concat(relativePath),
        diagnostics: [undefinedStepDiagnostic],
        kind: vscode_languageserver_types_1.CodeActionKind.QuickFix,
        edit: {
          documentChanges
        },
        isPreferred: true
      };
    }
    exports2.getGenerateSnippetCodeAction = getGenerateSnippetCodeAction;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/helpers.js
var require_helpers3 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStepRange = void 0;
    var gherkin_utils_1 = require_src2();
    var vscode_languageserver_types_1 = require_main2();
    var parseGherkinDocument_js_1 = require_parseGherkinDocument();
    function getStepRange(gherkinSource, position) {
      var gherkinDocument = (0, parseGherkinDocument_js_1.parseGherkinDocument)(gherkinSource).gherkinDocument;
      if (!gherkinDocument) {
        return void 0;
      }
      var stepKeyword = void 0;
      var stepText = void 0;
      var range = void 0;
      (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, void 0, {
        step: function(step) {
          if (step.location.line === position.line + 1 && step.location.column !== void 0) {
            stepText = step.text;
            stepKeyword = step.keyword;
            var startCharacter = step.location.column + step.keyword.length - 1;
            var endCharacter = startCharacter + stepText.length;
            range = vscode_languageserver_types_1.Range.create(position.line, startCharacter, position.line, endCharacter);
          }
        }
      });
      if (stepKeyword && stepText && range) {
        return {
          stepKeyword,
          stepText,
          range
        };
      }
    }
    exports2.getStepRange = getStepRange;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/snippet/lspCompletionSnippet.js
var require_lspCompletionSnippet = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/snippet/lspCompletionSnippet.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.lspCompletionSnippet = void 0;
    function lspCompletionSnippet(segments) {
      var n = 1;
      return segments.map(function(segment) {
        return Array.isArray(segment) ? lspPlaceholder(n++, segment) : segment;
      }).join("");
    }
    exports2.lspCompletionSnippet = lspCompletionSnippet;
    function lspPlaceholder(i, choices) {
      var escapedChoices = choices.filter(function(choice) {
        return choice !== "";
      }).map(function(choice) {
        return choice.replace(/([$\\},|])/g, "\\$1");
      });
      return "${".concat(i, "|").concat(escapedChoices.join(","), "|}");
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinCompletionItems.js
var require_getGherkinCompletionItems = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinCompletionItems.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGherkinCompletionItems = void 0;
    var vscode_languageserver_types_1 = require_main2();
    var helpers_js_1 = require_helpers3();
    var lspCompletionSnippet_js_1 = require_lspCompletionSnippet();
    function getGherkinCompletionItems(gherkinSource, position, index) {
      var stepRange = (0, helpers_js_1.getStepRange)(gherkinSource, position);
      if (!stepRange)
        return [];
      var suggestions = index(stepRange.stepText);
      return suggestions.map(function(suggestion, i) {
        var sortText = (suggestion.matched ? i + 1e3 : i + 2e3).toString();
        var item = {
          label: suggestion.label,
          insertTextFormat: vscode_languageserver_types_1.InsertTextFormat.Snippet,
          kind: vscode_languageserver_types_1.CompletionItemKind.Text,
          labelDetails: __assign({}, suggestion.matched ? {} : { detail: " (undefined step)" }),
          filterText: stepRange.stepText,
          sortText,
          textEdit: {
            newText: (0, lspCompletionSnippet_js_1.lspCompletionSnippet)(suggestion.segments),
            range: stepRange.range
          }
        };
        return item;
      });
    }
    exports2.getGherkinCompletionItems = getGherkinCompletionItems;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinDiagnostics.js
var require_getGherkinDiagnostics = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinDiagnostics.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __read = exports2 && exports2.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.makeUndefinedStepDiagnostic = exports2.getGherkinDiagnostics = void 0;
    var gherkin_1 = require_src4();
    var gherkin_utils_1 = require_src2();
    var vscode_languageserver_types_1 = require_main2();
    var parseGherkinDocument_js_1 = require_parseGherkinDocument();
    var constants_js_1 = require_constants();
    function getGherkinDiagnostics(gherkinSource, expressions) {
      var e_1, _a;
      var lines = gherkinSource.split(/\r?\n/);
      var _b = (0, parseGherkinDocument_js_1.parseGherkinDocument)(gherkinSource), gherkinDocument = _b.gherkinDocument, error = _b.error;
      var diagnostics = [];
      var errors = error instanceof gherkin_1.Errors.CompositeParserException ? error.errors : error ? [error] : [];
      try {
        for (var errors_1 = __values(errors), errors_1_1 = errors_1.next(); !errors_1_1.done; errors_1_1 = errors_1.next()) {
          var error_1 = errors_1_1.value;
          if (error_1 instanceof gherkin_1.Errors.GherkinException) {
            var line = error_1.location.line - 1;
            var character = error_1.location.column !== void 0 ? error_1.location.column - 1 : 0;
            var diagnostic = {
              severity: vscode_languageserver_types_1.DiagnosticSeverity.Error,
              range: {
                start: {
                  line,
                  character
                },
                end: {
                  line,
                  character: lines[line].length
                }
              },
              message: error_1.message,
              source: "Cucumber"
            };
            diagnostics.push(diagnostic);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (errors_1_1 && !errors_1_1.done && (_a = errors_1.return))
            _a.call(errors_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      if (!(gherkinDocument === null || gherkinDocument === void 0 ? void 0 : gherkinDocument.feature)) {
        return diagnostics;
      }
      var inScenarioOutline = false;
      var dialect = gherkin_1.dialects[gherkinDocument.feature.language];
      var noStars = function(keyword) {
        return keyword !== "* ";
      };
      var codeKeywords = __spreadArray(__spreadArray(__spreadArray([], __read(dialect.given), false), __read(dialect.when), false), __read(dialect.then), false).filter(noStars);
      var snippetKeyword = dialect.given.filter(noStars)[0];
      return (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, diagnostics, {
        scenario: function(scenario, diagnostics2) {
          inScenarioOutline = (scenario.examples || []).length > 0;
          return diagnostics2;
        },
        step: function(step, diagnostics2) {
          if (inScenarioOutline) {
            return diagnostics2;
          }
          if (codeKeywords.includes(step.keyword)) {
            snippetKeyword = step.keyword;
          }
          if (isUndefined(step.text, expressions) && step.location.column !== void 0) {
            var line2 = step.location.line - 1;
            var character2 = step.location.column - 1 + step.keyword.length;
            var diagnostic2 = makeUndefinedStepDiagnostic(line2, character2, step.keyword, step.text, snippetKeyword);
            return diagnostics2.concat(diagnostic2);
          }
          return diagnostics2;
        }
      });
    }
    exports2.getGherkinDiagnostics = getGherkinDiagnostics;
    function makeUndefinedStepDiagnostic(line, character, stepKeyword, stepText, snippetKeyword) {
      return {
        severity: vscode_languageserver_types_1.DiagnosticSeverity.Warning,
        range: {
          start: {
            line,
            character
          },
          end: {
            line,
            character: character + stepText.length
          }
        },
        message: "Undefined step: ".concat(stepText),
        source: "Cucumber",
        code: constants_js_1.diagnosticCodeUndefinedStep,
        codeDescription: {
          href: "https://cucumber.io/docs/cucumber/step-definitions/"
        },
        data: {
          snippetKeyword,
          stepText
        }
      };
    }
    exports2.makeUndefinedStepDiagnostic = makeUndefinedStepDiagnostic;
    function isUndefined(stepText, expressions) {
      var e_2, _a;
      try {
        for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
          var expression = expressions_1_1.value;
          if (expression.match(stepText))
            return false;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return))
            _a.call(expressions_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      return true;
    }
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinFormattingEdits.js
var require_getGherkinFormattingEdits = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinFormattingEdits.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGherkinFormattingEdits = void 0;
    var gherkin_utils_1 = require_src2();
    var parseGherkinDocument_js_1 = require_parseGherkinDocument();
    function getGherkinFormattingEdits(gherkinSource) {
      var gherkinDocument = (0, parseGherkinDocument_js_1.parseGherkinDocument)(gherkinSource).gherkinDocument;
      if (gherkinDocument === void 0)
        return [];
      var newText = (0, gherkin_utils_1.pretty)(gherkinDocument);
      var lines = gherkinSource.split(/\r?\n/);
      var line = lines.length - 1;
      var character = lines[line].length;
      var textEdit = {
        newText,
        range: {
          start: {
            line: 0,
            character: 0
          },
          end: {
            line,
            character
          }
        }
      };
      return [textEdit];
    }
    exports2.getGherkinFormattingEdits = getGherkinFormattingEdits;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinSemanticTokens.js
var require_getGherkinSemanticTokens = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getGherkinSemanticTokens.js"(exports2) {
    "use strict";
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGherkinSemanticTokens = exports2.semanticTokenTypes = void 0;
    var gherkin_utils_1 = require_src2();
    var vscode_languageserver_types_1 = require_main2();
    var parseGherkinDocument_js_1 = require_parseGherkinDocument();
    exports2.semanticTokenTypes = [
      vscode_languageserver_types_1.SemanticTokenTypes.keyword,
      vscode_languageserver_types_1.SemanticTokenTypes.parameter,
      vscode_languageserver_types_1.SemanticTokenTypes.string,
      vscode_languageserver_types_1.SemanticTokenTypes.type,
      vscode_languageserver_types_1.SemanticTokenTypes.variable,
      vscode_languageserver_types_1.SemanticTokenTypes.property
    ];
    var indexByType = Object.fromEntries(exports2.semanticTokenTypes.map(function(type, index) {
      return [type, index];
    }));
    function getGherkinSemanticTokens(gherkinSource, expressions) {
      var gherkinDocument = (0, parseGherkinDocument_js_1.parseGherkinDocument)(gherkinSource).gherkinDocument;
      if (!gherkinDocument) {
        return {
          data: []
        };
      }
      var lines = gherkinSource.split(/\r?\n/);
      var lastLineNumber = 0;
      var lastCharacter = 0;
      function makeLocationToken(location, token, type, data2) {
        var lineNumber = location.line - 1;
        if (location.column === void 0)
          throw new Error("Incomplete location: ".concat(JSON.stringify(location)));
        var character = location.column - 1;
        return makeToken(lineNumber, character, token, type, data2);
      }
      function makeToken(lineNumber, character, token, type, data2) {
        var charDelta = lineNumber === lastLineNumber ? character - lastCharacter : character;
        lastCharacter = character;
        var lineOffset = lineNumber - lastLineNumber;
        lastLineNumber = lineNumber;
        var length = token.length;
        var typeIndex = indexByType[type];
        return data2.concat([lineOffset, charDelta, length, typeIndex, 0]);
      }
      var inScenarioOutline = false;
      var inExamples = false;
      var data = (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, [], {
        tag: function(tag, arr) {
          return makeLocationToken(tag.location, tag.name, vscode_languageserver_types_1.SemanticTokenTypes.type, arr);
        },
        feature: function(feature, arr) {
          return makeLocationToken(feature.location, feature.keyword, vscode_languageserver_types_1.SemanticTokenTypes.keyword, arr);
        },
        rule: function(rule, arr) {
          return makeLocationToken(rule.location, rule.keyword, vscode_languageserver_types_1.SemanticTokenTypes.keyword, arr);
        },
        scenario: function(scenario, arr) {
          inScenarioOutline = (scenario.examples || []).length > 0;
          return makeLocationToken(scenario.location, scenario.keyword, vscode_languageserver_types_1.SemanticTokenTypes.keyword, arr);
        },
        examples: function(examples, arr) {
          inExamples = true;
          return makeLocationToken(examples.location, examples.keyword, vscode_languageserver_types_1.SemanticTokenTypes.keyword, arr);
        },
        step: function(step, arr) {
          var e_1, _a, e_2, _b;
          if (step.location.column === void 0)
            throw new Error("Incomplete location: ".concat(JSON.stringify(step.location)));
          inExamples = false;
          arr = makeLocationToken(step.location, step.keyword, vscode_languageserver_types_1.SemanticTokenTypes.keyword, arr);
          if (inScenarioOutline) {
            var regexp = /(<[^>]+>)/g;
            var match = null;
            while ((match = regexp.exec(step.text)) !== null) {
              var character = step.location.column - 1 + step.keyword.length + match.index;
              arr = makeToken(step.location.line - 1, character, match[0], vscode_languageserver_types_1.SemanticTokenTypes.variable, arr);
            }
          } else {
            try {
              for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                var expression = expressions_1_1.value;
                var args = expression.match(step.text);
                if (args) {
                  try {
                    for (var args_1 = (e_2 = void 0, __values(args)), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                      var arg = args_1_1.value;
                      if (arg.group.start === void 0)
                        throw new Error("Incomplete group: ".concat(JSON.stringify(arg.group)));
                      var character = step.location.column - 1 + step.keyword.length + arg.group.start;
                      arr = makeToken(step.location.line - 1, character, arg.group.value, vscode_languageserver_types_1.SemanticTokenTypes.parameter, arr);
                    }
                  } catch (e_2_1) {
                    e_2 = { error: e_2_1 };
                  } finally {
                    try {
                      if (args_1_1 && !args_1_1.done && (_b = args_1.return))
                        _b.call(args_1);
                    } finally {
                      if (e_2)
                        throw e_2.error;
                    }
                  }
                  break;
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return))
                  _a.call(expressions_1);
              } finally {
                if (e_1)
                  throw e_1.error;
              }
            }
          }
          return arr;
        },
        docString: function(docString, arr) {
          arr = makeLocationToken(docString.location, docString.delimiter, vscode_languageserver_types_1.SemanticTokenTypes.string, arr);
          if (docString.mediaType) {
            if (docString.location.column === void 0)
              throw new Error("Incomplete location: ".concat(JSON.stringify(docString.location)));
            var character = docString.location.column - 1 + docString.delimiter.length;
            arr = makeToken(docString.location.line - 1, character, docString.mediaType, vscode_languageserver_types_1.SemanticTokenTypes.type, arr);
          }
          var maxLineNumber = docString.location.line + docString.content.split(/\r?\n/).length;
          for (var lineNumber = docString.location.line; lineNumber <= maxLineNumber; lineNumber++) {
            var spaceContent = /^(\s*)(.*)$/.exec(lines[lineNumber]);
            if (spaceContent === null)
              throw new Error("No match for ".concat(lines[lineNumber]));
            var startChar = spaceContent[1].length;
            var token = spaceContent[2];
            arr = makeToken(lineNumber, startChar, token, vscode_languageserver_types_1.SemanticTokenTypes.string, arr);
          }
          return arr;
        },
        tableRow: function(tableRow, arr) {
          var e_3, _a;
          var type = inExamples ? vscode_languageserver_types_1.SemanticTokenTypes.property : vscode_languageserver_types_1.SemanticTokenTypes.string;
          try {
            for (var _b = __values(tableRow.cells), _c = _b.next(); !_c.done; _c = _b.next()) {
              var cell = _c.value;
              arr = makeLocationToken(cell.location, cell.value, type, arr);
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (_c && !_c.done && (_a = _b.return))
                _a.call(_b);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          inExamples = false;
          return arr;
        }
      });
      return {
        data
      };
    }
    exports2.getGherkinSemanticTokens = getGherkinSemanticTokens;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/getStepDefinitionLocationLinks.js
var require_getStepDefinitionLocationLinks = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/getStepDefinitionLocationLinks.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p))
              t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __values = exports2 && exports2.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStepDefinitionLocationLinks = void 0;
    var helpers_js_1 = require_helpers3();
    function getStepDefinitionLocationLinks(gherkinSource, position, expressionLinks) {
      var e_1, _a;
      var stepRange = (0, helpers_js_1.getStepRange)(gherkinSource, position);
      if (!stepRange)
        return [];
      var locationLinks = [];
      try {
        for (var expressionLinks_1 = __values(expressionLinks), expressionLinks_1_1 = expressionLinks_1.next(); !expressionLinks_1_1.done; expressionLinks_1_1 = expressionLinks_1.next()) {
          var expressionLink = expressionLinks_1_1.value;
          if (expressionLink.expression.match(stepRange.stepText)) {
            var locationLink = __assign(__assign({}, expressionLink.locationLink), { originSelectionRange: stepRange.range });
            locationLinks.push(locationLink);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (expressionLinks_1_1 && !expressionLinks_1_1.done && (_a = expressionLinks_1.return))
            _a.call(expressionLinks_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return locationLinks;
    }
    exports2.getStepDefinitionLocationLinks = getStepDefinitionLocationLinks;
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/service/index.js
var require_service = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/service/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_getGenerateSnippetCodeAction(), exports2);
    __exportStar(require_getGherkinCompletionItems(), exports2);
    __exportStar(require_getGherkinDiagnostics(), exports2);
    __exportStar(require_getGherkinFormattingEdits(), exports2);
    __exportStar(require_getGherkinSemanticTokens(), exports2);
    __exportStar(require_getStepDefinitionLocationLinks(), exports2);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/types.js
var require_types3 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/suggestions/index.js
var require_suggestions = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/suggestions/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_buildSuggestions(), exports2);
    __exportStar(require_types3(), exports2);
  }
});

// node_modules/@cucumber/language-service/dist/cjs/src/index.js
var require_src6 = __commonJS({
  "node_modules/@cucumber/language-service/dist/cjs/src/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_gherkin(), exports2);
    __exportStar(require_index(), exports2);
    __exportStar(require_language(), exports2);
    __exportStar(require_messages4(), exports2);
    __exportStar(require_service(), exports2);
    __exportStar(require_suggestions(), exports2);
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/buildStepTexts.js
var require_buildStepTexts = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/buildStepTexts.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.buildStepTexts = void 0;
    var gherkin_utils_1 = require_src2();
    var language_service_1 = require_src6();
    function buildStepTexts(gherkinSource) {
      const { gherkinDocument } = (0, language_service_1.parseGherkinDocument)(gherkinSource);
      if (!gherkinDocument) {
        return [];
      }
      const stepTexts = [];
      (0, gherkin_utils_1.walkGherkinDocument)(gherkinDocument, void 0, {
        step(step) {
          stepTexts.push(step.text);
        }
      });
      return stepTexts;
    }
    exports2.buildStepTexts = buildStepTexts;
  }
});

// node_modules/fast-glob/out/utils/array.js
var require_array = __commonJS({
  "node_modules/fast-glob/out/utils/array.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.splitWhen = exports2.flatten = void 0;
    function flatten(items) {
      return items.reduce((collection, item) => [].concat(collection, item), []);
    }
    exports2.flatten = flatten;
    function splitWhen(items, predicate) {
      const result = [[]];
      let groupIndex = 0;
      for (const item of items) {
        if (predicate(item)) {
          groupIndex++;
          result[groupIndex] = [];
        } else {
          result[groupIndex].push(item);
        }
      }
      return result;
    }
    exports2.splitWhen = splitWhen;
  }
});

// node_modules/fast-glob/out/utils/errno.js
var require_errno = __commonJS({
  "node_modules/fast-glob/out/utils/errno.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEnoentCodeError = void 0;
    function isEnoentCodeError(error) {
      return error.code === "ENOENT";
    }
    exports2.isEnoentCodeError = isEnoentCodeError;
  }
});

// node_modules/fast-glob/out/utils/fs.js
var require_fs = __commonJS({
  "node_modules/fast-glob/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/fast-glob/out/utils/path.js
var require_path = __commonJS({
  "node_modules/fast-glob/out/utils/path.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeLeadingDotSegment = exports2.escape = exports2.makeAbsolute = exports2.unixify = void 0;
    var path = require("path");
    var LEADING_DOT_SEGMENT_CHARACTERS_COUNT = 2;
    var UNESCAPED_GLOB_SYMBOLS_RE = /(\\?)([()*?[\]{|}]|^!|[!+@](?=\())/g;
    function unixify(filepath) {
      return filepath.replace(/\\/g, "/");
    }
    exports2.unixify = unixify;
    function makeAbsolute(cwd, filepath) {
      return path.resolve(cwd, filepath);
    }
    exports2.makeAbsolute = makeAbsolute;
    function escape(pattern) {
      return pattern.replace(UNESCAPED_GLOB_SYMBOLS_RE, "\\$2");
    }
    exports2.escape = escape;
    function removeLeadingDotSegment(entry) {
      if (entry.charAt(0) === ".") {
        const secondCharactery = entry.charAt(1);
        if (secondCharactery === "/" || secondCharactery === "\\") {
          return entry.slice(LEADING_DOT_SEGMENT_CHARACTERS_COUNT);
        }
      }
      return entry;
    }
    exports2.removeLeadingDotSegment = removeLeadingDotSegment;
  }
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS({
  "node_modules/is-extglob/index.js"(exports2, module2) {
    module2.exports = function isExtglob(str) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      var match;
      while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
        if (match[2])
          return true;
        str = str.slice(match.index + match[0].length);
      }
      return false;
    };
  }
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS({
  "node_modules/is-glob/index.js"(exports2, module2) {
    var isExtglob = require_is_extglob();
    var chars = { "{": "}", "(": ")", "[": "]" };
    var strictCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      var pipeIndex = -2;
      var closeSquareIndex = -2;
      var closeCurlyIndex = -2;
      var closeParenIndex = -2;
      var backSlashIndex = -2;
      while (index < str.length) {
        if (str[index] === "*") {
          return true;
        }
        if (str[index + 1] === "?" && /[\].+)]/.test(str[index])) {
          return true;
        }
        if (closeSquareIndex !== -1 && str[index] === "[" && str[index + 1] !== "]") {
          if (closeSquareIndex < index) {
            closeSquareIndex = str.indexOf("]", index);
          }
          if (closeSquareIndex > index) {
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeSquareIndex) {
              return true;
            }
          }
        }
        if (closeCurlyIndex !== -1 && str[index] === "{" && str[index + 1] !== "}") {
          closeCurlyIndex = str.indexOf("}", index);
          if (closeCurlyIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeCurlyIndex) {
              return true;
            }
          }
        }
        if (closeParenIndex !== -1 && str[index] === "(" && str[index + 1] === "?" && /[:!=]/.test(str[index + 2]) && str[index + 3] !== ")") {
          closeParenIndex = str.indexOf(")", index);
          if (closeParenIndex > index) {
            backSlashIndex = str.indexOf("\\", index);
            if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
              return true;
            }
          }
        }
        if (pipeIndex !== -1 && str[index] === "(" && str[index + 1] !== "|") {
          if (pipeIndex < index) {
            pipeIndex = str.indexOf("|", index);
          }
          if (pipeIndex !== -1 && str[pipeIndex + 1] !== ")") {
            closeParenIndex = str.indexOf(")", pipeIndex);
            if (closeParenIndex > pipeIndex) {
              backSlashIndex = str.indexOf("\\", pipeIndex);
              if (backSlashIndex === -1 || backSlashIndex > closeParenIndex) {
                return true;
              }
            }
          }
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    var relaxedCheck = function(str) {
      if (str[0] === "!") {
        return true;
      }
      var index = 0;
      while (index < str.length) {
        if (/[*?{}()[\]]/.test(str[index])) {
          return true;
        }
        if (str[index] === "\\") {
          var open = str[index + 1];
          index += 2;
          var close = chars[open];
          if (close) {
            var n = str.indexOf(close, index);
            if (n !== -1) {
              index = n + 1;
            }
          }
          if (str[index] === "!") {
            return true;
          }
        } else {
          index++;
        }
      }
      return false;
    };
    module2.exports = function isGlob(str, options) {
      if (typeof str !== "string" || str === "") {
        return false;
      }
      if (isExtglob(str)) {
        return true;
      }
      var check = strictCheck;
      if (options && options.strict === false) {
        check = relaxedCheck;
      }
      return check(str);
    };
  }
});

// node_modules/fast-glob/node_modules/glob-parent/index.js
var require_glob_parent = __commonJS({
  "node_modules/fast-glob/node_modules/glob-parent/index.js"(exports2, module2) {
    "use strict";
    var isGlob = require_is_glob();
    var pathPosixDirname = require("path").posix.dirname;
    var isWin32 = require("os").platform() === "win32";
    var slash = "/";
    var backslash = /\\/g;
    var enclosure = /[\{\[].*[\}\]]$/;
    var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
    var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
    module2.exports = function globParent(str, opts) {
      var options = Object.assign({ flipBackslashes: true }, opts);
      if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
        str = str.replace(backslash, slash);
      }
      if (enclosure.test(str)) {
        str += slash;
      }
      str += "a";
      do {
        str = pathPosixDirname(str);
      } while (isGlob(str) || globby.test(str));
      return str.replace(escaped, "$1");
    };
  }
});

// node_modules/braces/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min, max, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min) || !exports2.isInteger(max))
        return false;
      return (Number(max) - Number(min)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n = 0, type) => {
      let node = block.nodes[n];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i = 0; i < arr.length; i++) {
          let ele = arr[i];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber = require_is_number();
    var toRegexRange = (min, max, options) => {
      if (isNumber(min) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max === void 0 || min === max) {
        return String(min);
      }
      if (isNumber(max) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a = Math.min(min, max);
      let b = Math.max(min, max);
      if (Math.abs(a - b) === 1) {
        let result = min + "|" + max;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min) || hasPadding(max);
      let state = { min, max, a, b };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a < 0) {
        let newMin = b < 0 ? Math.abs(b) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
        a = state.a = 0;
      }
      if (b >= 0) {
        positives = splitToPatterns(a, b, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min, max) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min, nines);
      let stops = /* @__PURE__ */ new Set([max]);
      while (min <= stop && stop <= max) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min, nines);
      }
      stop = countZeros(max + 1, zeros) - 1;
      while (min < stop && stop <= max) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start, stop, options) {
      if (start === stop) {
        return { pattern: start, count: [], digits: 0 };
      }
      let zipped = zip(start, stop);
      let digits = zipped.length;
      let pattern = "";
      let count = 0;
      for (let i = 0; i < digits; i++) {
        let [startDigit, stopDigit] = zipped[i];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count++;
        }
      }
      if (count) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count], digits };
    }
    function splitToPatterns(min, max, tok, options) {
      let ranges = splitToRanges(min, max);
      let tokens = [];
      let start = min;
      let prev;
      for (let i = 0; i < ranges.length; i++) {
        let max2 = ranges[i];
        let obj = rangeToPattern(String(start), String(max2), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start = max2 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max2, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens.push(obj);
        start = max2 + 1;
        prev = obj;
      }
      return tokens;
    }
    function filterPatterns(arr, comparison, prefix, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string } = ele;
        if (!intersection && !contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
        if (intersection && contains(comparison, "string", string)) {
          result.push(prefix + string);
        }
      }
      return result;
    }
    function zip(a, b) {
      let arr = [];
      for (let i = 0; i < a.length; i++)
        arr.push([a[i], b[i]]);
      return arr;
    }
    function compare(a, b) {
      return a > b ? 1 : b > a ? -1 : 0;
    }
    function contains(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min, len) {
      return Number(String(min).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start = 0, stop = ""] = digits;
      if (stop || start > 1) {
        return `{${start + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a, b, options) {
      return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff}}` : `0{${diff}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var toRegexRange = require_to_regex_range();
    var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber) => {
      return (value) => toNumber === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index] === "0")
        ;
      return index > 0;
    };
    var stringify = (start, end, options) => {
      if (typeof start === "string" || typeof end === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad = (input, maxLength, toNumber) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
      let prefix = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix}${result})`;
      }
      return result;
    };
    var toRange = (a, b, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a, b, { wrap: false, ...options });
      }
      let start = String.fromCharCode(a);
      if (a === b)
        return start;
      let stop = String.fromCharCode(b);
      return `[${start}-${stop}]`;
    };
    var toRegex = (start, end, options) => {
      if (Array.isArray(start)) {
        let wrap = options.wrap === true;
        let prefix = options.capture ? "" : "?:";
        return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
      }
      return toRegexRange(start, end, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util.inspect(...args));
    };
    var invalidRange = (start, end, options) => {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start, end, step = 1, options = {}) => {
      let a = Number(start);
      let b = Number(end);
      if (!Number.isInteger(a) || !Number.isInteger(b)) {
        if (options.strictRanges === true)
          throw rangeError([start, end]);
        return [];
      }
      if (a === 0)
        a = 0;
      if (b === 0)
        b = 0;
      let descending = a > b;
      let startString = String(start);
      let endString = String(end);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber = padded === false && stringify(start, end, options) === false;
      let format = options.transform || transform(toNumber);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        if (options.toRegex === true && step > 1) {
          push(a);
        } else {
          range.push(pad(format(a, index), maxLen, toNumber));
        }
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start, end, step = 1, options = {}) => {
      if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
        return invalidRange(start, end, options);
      }
      let format = options.transform || ((val) => String.fromCharCode(val));
      let a = `${start}`.charCodeAt(0);
      let b = `${end}`.charCodeAt(0);
      let descending = a > b;
      let min = Math.min(a, b);
      let max = Math.max(a, b);
      if (options.toRegex && step === 1) {
        return toRange(min, max, false, options);
      }
      let range = [];
      let index = 0;
      while (descending ? a >= b : a <= b) {
        range.push(format(a, index));
        a = descending ? a - step : a + step;
        index++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start, end, step, options = {}) => {
      if (end == null && isValidValue(start)) {
        return [start];
      }
      if (!isValidValue(start) || !isValidValue(end)) {
        return invalidRange(start, end, options);
      }
      if (typeof step === "function") {
        return fill(start, end, 1, { transform: step });
      }
      if (isObject(step)) {
        return fill(start, end, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber(step)) {
        if (step != null && !isObject(step))
          return invalidStep(step, opts);
        return fill(start, end, 1, step);
      }
      if (isNumber(start) && isNumber(end)) {
        return fillNumbers(start, end, step, opts);
      }
      return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils3();
    var compile = (ast, options = {}) => {
      let walk = (node, parent = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix + node.value;
        }
        if (node.isClose === true) {
          return prefix + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify2();
    var utils = require_utils3();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent = {}) => {
        node.queue = [];
        let p = parent;
        let q = parent.queue;
        while (p.type !== "brace" && p.type !== "root" && p.parent) {
          p = p.parent;
          q = p.queue;
        }
        if (node.invalid || node.dollar) {
          q.push(append(q.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q.push(append(q.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q.push(append(q.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i = 0; i < node.nodes.length; i++) {
          let child = node.nodes[i];
          if (child.type === "comma" && node.type === "brace") {
            if (i === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q.push(append(q.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand;
  }
});

// node_modules/braces/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      CHAR_0: "0",
      CHAR_9: "9",
      CHAR_UPPERCASE_A: "A",
      CHAR_LOWERCASE_A: "a",
      CHAR_UPPERCASE_Z: "Z",
      CHAR_LOWERCASE_Z: "z",
      CHAR_LEFT_PARENTHESES: "(",
      CHAR_RIGHT_PARENTHESES: ")",
      CHAR_ASTERISK: "*",
      CHAR_AMPERSAND: "&",
      CHAR_AT: "@",
      CHAR_BACKSLASH: "\\",
      CHAR_BACKTICK: "`",
      CHAR_CARRIAGE_RETURN: "\r",
      CHAR_CIRCUMFLEX_ACCENT: "^",
      CHAR_COLON: ":",
      CHAR_COMMA: ",",
      CHAR_DOLLAR: "$",
      CHAR_DOT: ".",
      CHAR_DOUBLE_QUOTE: '"',
      CHAR_EQUAL: "=",
      CHAR_EXCLAMATION_MARK: "!",
      CHAR_FORM_FEED: "\f",
      CHAR_FORWARD_SLASH: "/",
      CHAR_HASH: "#",
      CHAR_HYPHEN_MINUS: "-",
      CHAR_LEFT_ANGLE_BRACKET: "<",
      CHAR_LEFT_CURLY_BRACE: "{",
      CHAR_LEFT_SQUARE_BRACKET: "[",
      CHAR_LINE_FEED: "\n",
      CHAR_NO_BREAK_SPACE: "\xA0",
      CHAR_PERCENT: "%",
      CHAR_PLUS: "+",
      CHAR_QUESTION_MARK: "?",
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      CHAR_RIGHT_CURLY_BRACE: "}",
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      CHAR_SEMICOLON: ";",
      CHAR_SINGLE_QUOTE: "'",
      CHAR_SPACE: " ",
      CHAR_TAB: "	",
      CHAR_UNDERSCORE: "_",
      CHAR_VERTICAL_LINE: "|",
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      CHAR_BACKTICK,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_LEFT_PARENTHESES,
      CHAR_RIGHT_PARENTHESES,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_RIGHT_SQUARE_BRACKET,
      CHAR_DOUBLE_QUOTE,
      CHAR_SINGLE_QUOTE,
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants2();
    var parse = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index = 0;
      let depth = 0;
      let value;
      let memo = {};
      const advance = () => input[index++];
      const push = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push({ type: "bos" });
      while (index < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push({ type: "paren", nodes: [] });
          stack.push(block);
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push(brace);
          stack.push(block);
          push({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push({ type: "dot", value });
          continue;
        }
        push({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent = stack[stack.length - 1];
          let index2 = parent.nodes.indexOf(block);
          parent.nodes.splice(index2, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push({ type: "eos" });
      return ast;
    };
    module2.exports = parse;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify2();
    var compile = require_compile2();
    var expand = require_expand();
    var parse = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants3 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      CHAR_0: 48,
      CHAR_9: 57,
      CHAR_UPPERCASE_A: 65,
      CHAR_LOWERCASE_A: 97,
      CHAR_UPPERCASE_Z: 90,
      CHAR_LOWERCASE_Z: 122,
      CHAR_LEFT_PARENTHESES: 40,
      CHAR_RIGHT_PARENTHESES: 41,
      CHAR_ASTERISK: 42,
      CHAR_AMPERSAND: 38,
      CHAR_AT: 64,
      CHAR_BACKWARD_SLASH: 92,
      CHAR_CARRIAGE_RETURN: 13,
      CHAR_CIRCUMFLEX_ACCENT: 94,
      CHAR_COLON: 58,
      CHAR_COMMA: 44,
      CHAR_DOT: 46,
      CHAR_DOUBLE_QUOTE: 34,
      CHAR_EQUAL: 61,
      CHAR_EXCLAMATION_MARK: 33,
      CHAR_FORM_FEED: 12,
      CHAR_FORWARD_SLASH: 47,
      CHAR_GRAVE_ACCENT: 96,
      CHAR_HASH: 35,
      CHAR_HYPHEN_MINUS: 45,
      CHAR_LEFT_ANGLE_BRACKET: 60,
      CHAR_LEFT_CURLY_BRACE: 123,
      CHAR_LEFT_SQUARE_BRACKET: 91,
      CHAR_LINE_FEED: 10,
      CHAR_NO_BREAK_SPACE: 160,
      CHAR_PERCENT: 37,
      CHAR_PLUS: 43,
      CHAR_QUESTION_MARK: 63,
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      CHAR_RIGHT_CURLY_BRACE: 125,
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      CHAR_SEMICOLON: 59,
      CHAR_SINGLE_QUOTE: 39,
      CHAR_SPACE: 32,
      CHAR_TAB: 9,
      CHAR_UNDERSCORE: 95,
      CHAR_VERTICAL_LINE: 124,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      SEP: path.sep,
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils4 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require("path");
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants3();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
        return match === "\\" ? "" : match;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils4();
    var {
      CHAR_ASTERISK,
      CHAR_AT,
      CHAR_BACKWARD_SLASH,
      CHAR_COMMA,
      CHAR_DOT,
      CHAR_EXCLAMATION_MARK,
      CHAR_FORWARD_SLASH,
      CHAR_LEFT_CURLY_BRACE,
      CHAR_LEFT_PARENTHESES,
      CHAR_LEFT_SQUARE_BRACKET,
      CHAR_PLUS,
      CHAR_QUESTION_MARK,
      CHAR_RIGHT_CURLY_BRACE,
      CHAR_RIGHT_PARENTHESES,
      CHAR_RIGHT_SQUARE_BRACKET
    } = require_constants3();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token) => {
      if (token.isPrefix !== true) {
        token.depth = token.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens = [];
      const parts = [];
      let str = input;
      let index = -1;
      let start = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token = { value: "", depth: 0, isGlob: false };
      const eos = () => index >= length;
      const peek = () => str.charCodeAt(index + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index);
      };
      while (index < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token.isBrace = true;
              isGlob = token.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index);
          tokens.push(token);
          token = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index === start + 1) {
            start += 2;
            continue;
          }
          lastIndex = index + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token.isGlob = true;
            isExtglob = token.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index === start) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token.isGlobstar = true;
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token.isBracket = true;
              isGlob = token.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index === start) {
          negated = token.negated = true;
          start++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix = "";
      let glob = "";
      if (start > 0) {
        prefix = str.slice(0, start);
        str = str.slice(start);
        lastIndex -= start;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix,
        input,
        start,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens.push(token);
        }
        state.tokens = tokens;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n = prevIndex ? prevIndex + 1 : start;
          const i = slashes[idx];
          const value = input.slice(n, i);
          if (opts.tokens) {
            if (idx === 0 && start !== 0) {
              tokens[idx].isPrefix = true;
              tokens[idx].value = prefix;
            } else {
              tokens[idx].value = value;
            }
            depth(tokens[idx]);
            state.maxDepth += tokens[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens[tokens.length - 1].value = value;
            depth(tokens[tokens.length - 1]);
            state.maxDepth += tokens[tokens.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants3();
    var utils = require_utils4();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v) => utils.escapeRegex(v)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n = 1) => input[state.index + n];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token) => {
        state.output += token.output != null ? token.output : token.value;
        consume(token.value);
      };
      const negate = () => {
        let count = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count++;
        }
        if (count % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token.prev = prev;
        token.parens = state.parens;
        token.output = state.output;
        const output = (opts.capture ? "(" : "") + token.open;
        increment("parens");
        push({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token);
      };
      const extglobClose = (token) => {
        let output = token.close + (opts.capture ? ")" : "");
        let rest;
        if (token.type === "negate") {
          let extglobStar = star;
          if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token.close = `)$))${extglobStar}`;
          }
          if (token.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse(rest, { ...options, fastpaths: false }).output;
            output = token.close = `)${expression})${extglobStar})`;
          }
          if (token.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
          if (first === "\\") {
            backslashes = true;
            return m;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m : `\\${m}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m) => {
              return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push({ type: "text", value });
            continue;
          }
          const match = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match && match[0].length > 2) {
            slashes = match[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens.slice();
            const range = [];
            for (let i = arr.length - 1; i >= 0; i--) {
              tokens.pop();
              if (arr[i].type === "brace") {
                break;
              }
              if (arr[i].type !== "dots") {
                range.unshift(arr[i].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t of toks) {
              state.output += t.output || t.value;
            }
          }
          push({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens.pop();
            prev = bos;
            continue;
          }
          push({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push({ type: "plus", value });
            continue;
          }
          push({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match) {
            value += match[0];
            state.index += match[0].length;
          }
          push({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token = { type: "star", value, output: star };
        if (opts.bash === true) {
          token.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token.output = nodot + token.output;
          }
          push(token);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token.output = value;
          push(token);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push(token);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token of state.tokens) {
          state.output += token.output != null ? token.output : token.value;
          if (token.suffix) {
            state.output += token.suffix;
          }
        }
      }
      return state;
    };
    parse.fastpaths = (input, options) => {
      const opts = { ...options };
      const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match = /^(.*?)\.(\w+)$/.exec(str);
            if (!match)
              return;
            const source2 = create(match[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var scan = require_scan();
    var parse = require_parse3();
    var utils = require_utils4();
    var constants = require_constants3();
    var isObject = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format = opts.format || (posix ? utils.toPosixSlashes : null);
      let match = input === glob;
      let output = match && format ? format(input) : input;
      if (match === false) {
        output = format ? format(input) : input;
        match = output === glob;
      }
      if (match === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match = picomatch.matchBase(input, regex, options, posix);
        } else {
          match = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match), match, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p) => picomatch.parse(p, options));
      return parse(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util = require("util");
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils4();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i = 0; i < patterns.length; i++) {
        let isMatch = picomatch(String(patterns[i]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match = negated ? !matched.isMatch : matched.isMatch;
          if (!match)
            continue;
          if (negated) {
            omit.add(matched.output);
          } else {
            omit.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch.match = micromatch;
    micromatch.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch.any = micromatch.isMatch;
    micromatch.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p) => micromatch.contains(str, p, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys = micromatch(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys)
        res[key] = obj[key];
      return res;
    };
    micromatch.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
      }
      return [].concat(patterns).every((p) => picomatch(p, options)(str));
    };
    micromatch.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match) {
        return match.slice(1).map((v) => v === void 0 ? "" : v);
      }
    };
    micromatch.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch.scan = (...args) => picomatch.scan(...args);
    micromatch.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch;
  }
});

// node_modules/fast-glob/out/utils/pattern.js
var require_pattern = __commonJS({
  "node_modules/fast-glob/out/utils/pattern.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.matchAny = exports2.convertPatternsToRe = exports2.makeRe = exports2.getPatternParts = exports2.expandBraceExpansion = exports2.expandPatternsWithBraceExpansion = exports2.isAffectDepthOfReadingPattern = exports2.endsWithSlashGlobStar = exports2.hasGlobStar = exports2.getBaseDirectory = exports2.isPatternRelatedToParentDirectory = exports2.getPatternsOutsideCurrentDirectory = exports2.getPatternsInsideCurrentDirectory = exports2.getPositivePatterns = exports2.getNegativePatterns = exports2.isPositivePattern = exports2.isNegativePattern = exports2.convertToNegativePattern = exports2.convertToPositivePattern = exports2.isDynamicPattern = exports2.isStaticPattern = void 0;
    var path = require("path");
    var globParent = require_glob_parent();
    var micromatch = require_micromatch();
    var GLOBSTAR = "**";
    var ESCAPE_SYMBOL = "\\";
    var COMMON_GLOB_SYMBOLS_RE = /[*?]|^!/;
    var REGEX_CHARACTER_CLASS_SYMBOLS_RE = /\[[^[]*]/;
    var REGEX_GROUP_SYMBOLS_RE = /(?:^|[^!*+?@])\([^(]*\|[^|]*\)/;
    var GLOB_EXTENSION_SYMBOLS_RE = /[!*+?@]\([^(]*\)/;
    var BRACE_EXPANSION_SEPARATORS_RE = /,|\.\./;
    function isStaticPattern(pattern, options = {}) {
      return !isDynamicPattern(pattern, options);
    }
    exports2.isStaticPattern = isStaticPattern;
    function isDynamicPattern(pattern, options = {}) {
      if (pattern === "") {
        return false;
      }
      if (options.caseSensitiveMatch === false || pattern.includes(ESCAPE_SYMBOL)) {
        return true;
      }
      if (COMMON_GLOB_SYMBOLS_RE.test(pattern) || REGEX_CHARACTER_CLASS_SYMBOLS_RE.test(pattern) || REGEX_GROUP_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.extglob !== false && GLOB_EXTENSION_SYMBOLS_RE.test(pattern)) {
        return true;
      }
      if (options.braceExpansion !== false && hasBraceExpansion(pattern)) {
        return true;
      }
      return false;
    }
    exports2.isDynamicPattern = isDynamicPattern;
    function hasBraceExpansion(pattern) {
      const openingBraceIndex = pattern.indexOf("{");
      if (openingBraceIndex === -1) {
        return false;
      }
      const closingBraceIndex = pattern.indexOf("}", openingBraceIndex + 1);
      if (closingBraceIndex === -1) {
        return false;
      }
      const braceContent = pattern.slice(openingBraceIndex, closingBraceIndex);
      return BRACE_EXPANSION_SEPARATORS_RE.test(braceContent);
    }
    function convertToPositivePattern(pattern) {
      return isNegativePattern(pattern) ? pattern.slice(1) : pattern;
    }
    exports2.convertToPositivePattern = convertToPositivePattern;
    function convertToNegativePattern(pattern) {
      return "!" + pattern;
    }
    exports2.convertToNegativePattern = convertToNegativePattern;
    function isNegativePattern(pattern) {
      return pattern.startsWith("!") && pattern[1] !== "(";
    }
    exports2.isNegativePattern = isNegativePattern;
    function isPositivePattern(pattern) {
      return !isNegativePattern(pattern);
    }
    exports2.isPositivePattern = isPositivePattern;
    function getNegativePatterns(patterns) {
      return patterns.filter(isNegativePattern);
    }
    exports2.getNegativePatterns = getNegativePatterns;
    function getPositivePatterns(patterns) {
      return patterns.filter(isPositivePattern);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getPatternsInsideCurrentDirectory(patterns) {
      return patterns.filter((pattern) => !isPatternRelatedToParentDirectory(pattern));
    }
    exports2.getPatternsInsideCurrentDirectory = getPatternsInsideCurrentDirectory;
    function getPatternsOutsideCurrentDirectory(patterns) {
      return patterns.filter(isPatternRelatedToParentDirectory);
    }
    exports2.getPatternsOutsideCurrentDirectory = getPatternsOutsideCurrentDirectory;
    function isPatternRelatedToParentDirectory(pattern) {
      return pattern.startsWith("..") || pattern.startsWith("./..");
    }
    exports2.isPatternRelatedToParentDirectory = isPatternRelatedToParentDirectory;
    function getBaseDirectory(pattern) {
      return globParent(pattern, { flipBackslashes: false });
    }
    exports2.getBaseDirectory = getBaseDirectory;
    function hasGlobStar(pattern) {
      return pattern.includes(GLOBSTAR);
    }
    exports2.hasGlobStar = hasGlobStar;
    function endsWithSlashGlobStar(pattern) {
      return pattern.endsWith("/" + GLOBSTAR);
    }
    exports2.endsWithSlashGlobStar = endsWithSlashGlobStar;
    function isAffectDepthOfReadingPattern(pattern) {
      const basename = path.basename(pattern);
      return endsWithSlashGlobStar(pattern) || isStaticPattern(basename);
    }
    exports2.isAffectDepthOfReadingPattern = isAffectDepthOfReadingPattern;
    function expandPatternsWithBraceExpansion(patterns) {
      return patterns.reduce((collection, pattern) => {
        return collection.concat(expandBraceExpansion(pattern));
      }, []);
    }
    exports2.expandPatternsWithBraceExpansion = expandPatternsWithBraceExpansion;
    function expandBraceExpansion(pattern) {
      return micromatch.braces(pattern, {
        expand: true,
        nodupes: true
      });
    }
    exports2.expandBraceExpansion = expandBraceExpansion;
    function getPatternParts(pattern, options) {
      let { parts } = micromatch.scan(pattern, Object.assign(Object.assign({}, options), { parts: true }));
      if (parts.length === 0) {
        parts = [pattern];
      }
      if (parts[0].startsWith("/")) {
        parts[0] = parts[0].slice(1);
        parts.unshift("");
      }
      return parts;
    }
    exports2.getPatternParts = getPatternParts;
    function makeRe(pattern, options) {
      return micromatch.makeRe(pattern, options);
    }
    exports2.makeRe = makeRe;
    function convertPatternsToRe(patterns, options) {
      return patterns.map((pattern) => makeRe(pattern, options));
    }
    exports2.convertPatternsToRe = convertPatternsToRe;
    function matchAny(entry, patternsRe) {
      return patternsRe.some((patternRe) => patternRe.test(entry));
    }
    exports2.matchAny = matchAny;
  }
});

// node_modules/merge2/index.js
var require_merge2 = __commonJS({
  "node_modules/merge2/index.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    var PassThrough = Stream.PassThrough;
    var slice = Array.prototype.slice;
    module2.exports = merge2;
    function merge2() {
      const streamsQueue = [];
      const args = slice.call(arguments);
      let merging = false;
      let options = args[args.length - 1];
      if (options && !Array.isArray(options) && options.pipe == null) {
        args.pop();
      } else {
        options = {};
      }
      const doEnd = options.end !== false;
      const doPipeError = options.pipeError === true;
      if (options.objectMode == null) {
        options.objectMode = true;
      }
      if (options.highWaterMark == null) {
        options.highWaterMark = 64 * 1024;
      }
      const mergedStream = PassThrough(options);
      function addStream() {
        for (let i = 0, len = arguments.length; i < len; i++) {
          streamsQueue.push(pauseStreams(arguments[i], options));
        }
        mergeStream();
        return this;
      }
      function mergeStream() {
        if (merging) {
          return;
        }
        merging = true;
        let streams = streamsQueue.shift();
        if (!streams) {
          process.nextTick(endStream);
          return;
        }
        if (!Array.isArray(streams)) {
          streams = [streams];
        }
        let pipesCount = streams.length + 1;
        function next() {
          if (--pipesCount > 0) {
            return;
          }
          merging = false;
          mergeStream();
        }
        function pipe(stream) {
          function onend() {
            stream.removeListener("merge2UnpipeEnd", onend);
            stream.removeListener("end", onend);
            if (doPipeError) {
              stream.removeListener("error", onerror);
            }
            next();
          }
          function onerror(err) {
            mergedStream.emit("error", err);
          }
          if (stream._readableState.endEmitted) {
            return next();
          }
          stream.on("merge2UnpipeEnd", onend);
          stream.on("end", onend);
          if (doPipeError) {
            stream.on("error", onerror);
          }
          stream.pipe(mergedStream, { end: false });
          stream.resume();
        }
        for (let i = 0; i < streams.length; i++) {
          pipe(streams[i]);
        }
        next();
      }
      function endStream() {
        merging = false;
        mergedStream.emit("queueDrain");
        if (doEnd) {
          mergedStream.end();
        }
      }
      mergedStream.setMaxListeners(0);
      mergedStream.add = addStream;
      mergedStream.on("unpipe", function(stream) {
        stream.emit("merge2UnpipeEnd");
      });
      if (args.length) {
        addStream.apply(null, args);
      }
      return mergedStream;
    }
    function pauseStreams(streams, options) {
      if (!Array.isArray(streams)) {
        if (!streams._readableState && streams.pipe) {
          streams = streams.pipe(PassThrough(options));
        }
        if (!streams._readableState || !streams.pause || !streams.pipe) {
          throw new Error("Only readable stream can be merged.");
        }
        streams.pause();
      } else {
        for (let i = 0, len = streams.length; i < len; i++) {
          streams[i] = pauseStreams(streams[i], options);
        }
      }
      return streams;
    }
  }
});

// node_modules/fast-glob/out/utils/stream.js
var require_stream = __commonJS({
  "node_modules/fast-glob/out/utils/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.merge = void 0;
    var merge2 = require_merge2();
    function merge(streams) {
      const mergedStream = merge2(streams);
      streams.forEach((stream) => {
        stream.once("error", (error) => mergedStream.emit("error", error));
      });
      mergedStream.once("close", () => propagateCloseEventToSources(streams));
      mergedStream.once("end", () => propagateCloseEventToSources(streams));
      return mergedStream;
    }
    exports2.merge = merge;
    function propagateCloseEventToSources(streams) {
      streams.forEach((stream) => stream.emit("close"));
    }
  }
});

// node_modules/fast-glob/out/utils/string.js
var require_string = __commonJS({
  "node_modules/fast-glob/out/utils/string.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isEmpty = exports2.isString = void 0;
    function isString(input) {
      return typeof input === "string";
    }
    exports2.isString = isString;
    function isEmpty(input) {
      return input === "";
    }
    exports2.isEmpty = isEmpty;
  }
});

// node_modules/fast-glob/out/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/fast-glob/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.string = exports2.stream = exports2.pattern = exports2.path = exports2.fs = exports2.errno = exports2.array = void 0;
    var array = require_array();
    exports2.array = array;
    var errno = require_errno();
    exports2.errno = errno;
    var fs = require_fs();
    exports2.fs = fs;
    var path = require_path();
    exports2.path = path;
    var pattern = require_pattern();
    exports2.pattern = pattern;
    var stream = require_stream();
    exports2.stream = stream;
    var string = require_string();
    exports2.string = string;
  }
});

// node_modules/fast-glob/out/managers/tasks.js
var require_tasks = __commonJS({
  "node_modules/fast-glob/out/managers/tasks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.convertPatternGroupToTask = exports2.convertPatternGroupsToTasks = exports2.groupPatternsByBaseDirectory = exports2.getNegativePatternsAsPositive = exports2.getPositivePatterns = exports2.convertPatternsToTasks = exports2.generate = void 0;
    var utils = require_utils5();
    function generate(patterns, settings) {
      const positivePatterns = getPositivePatterns(patterns);
      const negativePatterns = getNegativePatternsAsPositive(patterns, settings.ignore);
      const staticPatterns = positivePatterns.filter((pattern) => utils.pattern.isStaticPattern(pattern, settings));
      const dynamicPatterns = positivePatterns.filter((pattern) => utils.pattern.isDynamicPattern(pattern, settings));
      const staticTasks = convertPatternsToTasks(staticPatterns, negativePatterns, false);
      const dynamicTasks = convertPatternsToTasks(dynamicPatterns, negativePatterns, true);
      return staticTasks.concat(dynamicTasks);
    }
    exports2.generate = generate;
    function convertPatternsToTasks(positive, negative, dynamic) {
      const tasks = [];
      const patternsOutsideCurrentDirectory = utils.pattern.getPatternsOutsideCurrentDirectory(positive);
      const patternsInsideCurrentDirectory = utils.pattern.getPatternsInsideCurrentDirectory(positive);
      const outsideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsOutsideCurrentDirectory);
      const insideCurrentDirectoryGroup = groupPatternsByBaseDirectory(patternsInsideCurrentDirectory);
      tasks.push(...convertPatternGroupsToTasks(outsideCurrentDirectoryGroup, negative, dynamic));
      if ("." in insideCurrentDirectoryGroup) {
        tasks.push(convertPatternGroupToTask(".", patternsInsideCurrentDirectory, negative, dynamic));
      } else {
        tasks.push(...convertPatternGroupsToTasks(insideCurrentDirectoryGroup, negative, dynamic));
      }
      return tasks;
    }
    exports2.convertPatternsToTasks = convertPatternsToTasks;
    function getPositivePatterns(patterns) {
      return utils.pattern.getPositivePatterns(patterns);
    }
    exports2.getPositivePatterns = getPositivePatterns;
    function getNegativePatternsAsPositive(patterns, ignore) {
      const negative = utils.pattern.getNegativePatterns(patterns).concat(ignore);
      const positive = negative.map(utils.pattern.convertToPositivePattern);
      return positive;
    }
    exports2.getNegativePatternsAsPositive = getNegativePatternsAsPositive;
    function groupPatternsByBaseDirectory(patterns) {
      const group = {};
      return patterns.reduce((collection, pattern) => {
        const base = utils.pattern.getBaseDirectory(pattern);
        if (base in collection) {
          collection[base].push(pattern);
        } else {
          collection[base] = [pattern];
        }
        return collection;
      }, group);
    }
    exports2.groupPatternsByBaseDirectory = groupPatternsByBaseDirectory;
    function convertPatternGroupsToTasks(positive, negative, dynamic) {
      return Object.keys(positive).map((base) => {
        return convertPatternGroupToTask(base, positive[base], negative, dynamic);
      });
    }
    exports2.convertPatternGroupsToTasks = convertPatternGroupsToTasks;
    function convertPatternGroupToTask(base, positive, negative, dynamic) {
      return {
        dynamic,
        positive,
        negative,
        base,
        patterns: [].concat(positive, negative.map(utils.pattern.convertToNegativePattern))
      };
    }
    exports2.convertPatternGroupToTask = convertPatternGroupToTask;
  }
});

// node_modules/fast-glob/out/managers/patterns.js
var require_patterns = __commonJS({
  "node_modules/fast-glob/out/managers/patterns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeDuplicateSlashes = exports2.transform = void 0;
    var DOUBLE_SLASH_RE = /(?!^)\/{2,}/g;
    function transform(patterns) {
      return patterns.map((pattern) => removeDuplicateSlashes(pattern));
    }
    exports2.transform = transform;
    function removeDuplicateSlashes(pattern) {
      return pattern.replace(DOUBLE_SLASH_RE, "/");
    }
    exports2.removeDuplicateSlashes = removeDuplicateSlashes;
  }
});

// node_modules/@nodelib/fs.stat/out/providers/async.js
var require_async = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read2(path, settings, callback) {
      settings.fs.lstat(path, (lstatError, lstat) => {
        if (lstatError !== null) {
          callFailureCallback(callback, lstatError);
          return;
        }
        if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
          callSuccessCallback(callback, lstat);
          return;
        }
        settings.fs.stat(path, (statError, stat) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              callFailureCallback(callback, statError);
              return;
            }
            callSuccessCallback(callback, lstat);
            return;
          }
          if (settings.markSymbolicLink) {
            stat.isSymbolicLink = () => true;
          }
          callSuccessCallback(callback, stat);
        });
      });
    }
    exports2.read = read2;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.stat/out/providers/sync.js
var require_sync = __commonJS({
  "node_modules/@nodelib/fs.stat/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.read = void 0;
    function read2(path, settings) {
      const lstat = settings.fs.lstatSync(path);
      if (!lstat.isSymbolicLink() || !settings.followSymbolicLink) {
        return lstat;
      }
      try {
        const stat = settings.fs.statSync(path);
        if (settings.markSymbolicLink) {
          stat.isSymbolicLink = () => true;
        }
        return stat;
      } catch (error) {
        if (!settings.throwErrorOnBrokenSymbolicLink) {
          return lstat;
        }
        throw error;
      }
    }
    exports2.read = read2;
  }
});

// node_modules/@nodelib/fs.stat/out/adapters/fs.js
var require_fs2 = __commonJS({
  "node_modules/@nodelib/fs.stat/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.stat/out/settings.js
var require_settings = __commonJS({
  "node_modules/@nodelib/fs.stat/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fs = require_fs2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLink = this._getValue(this._options.followSymbolicLink, true);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.markSymbolicLink = this._getValue(this._options.markSymbolicLink, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.stat/out/index.js
var require_out = __commonJS({
  "node_modules/@nodelib/fs.stat/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.statSync = exports2.stat = exports2.Settings = void 0;
    var async = require_async();
    var sync = require_sync();
    var settings_1 = require_settings();
    exports2.Settings = settings_1.default;
    function stat(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.stat = stat;
    function statSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.statSync = statSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/run-parallel/index.js
var require_run_parallel = __commonJS({
  "node_modules/run-parallel/index.js"(exports2, module2) {
    module2.exports = runParallel;
    var queueMicrotask2 = require_queue_microtask();
    function runParallel(tasks, cb) {
      let results, pending, keys;
      let isSync = true;
      if (Array.isArray(tasks)) {
        results = [];
        pending = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (--pending === 0 || err) {
          done(err);
        }
      }
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.forEach(function(key) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
        });
      } else {
        tasks.forEach(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
        });
      }
      isSync = false;
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/constants.js
var require_constants4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = void 0;
    var NODE_PROCESS_VERSION_PARTS = process.versions.node.split(".");
    if (NODE_PROCESS_VERSION_PARTS[0] === void 0 || NODE_PROCESS_VERSION_PARTS[1] === void 0) {
      throw new Error(`Unexpected behavior. The 'process.versions.node' variable has invalid value: ${process.versions.node}`);
    }
    var MAJOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[0], 10);
    var MINOR_VERSION = Number.parseInt(NODE_PROCESS_VERSION_PARTS[1], 10);
    var SUPPORTED_MAJOR_VERSION = 10;
    var SUPPORTED_MINOR_VERSION = 10;
    var IS_MATCHED_BY_MAJOR = MAJOR_VERSION > SUPPORTED_MAJOR_VERSION;
    var IS_MATCHED_BY_MAJOR_AND_MINOR = MAJOR_VERSION === SUPPORTED_MAJOR_VERSION && MINOR_VERSION >= SUPPORTED_MINOR_VERSION;
    exports2.IS_SUPPORT_READDIR_WITH_FILE_TYPES = IS_MATCHED_BY_MAJOR || IS_MATCHED_BY_MAJOR_AND_MINOR;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/fs.js
var require_fs3 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createDirentFromStats = void 0;
    var DirentFromStats = class {
      constructor(name, stats) {
        this.name = name;
        this.isBlockDevice = stats.isBlockDevice.bind(stats);
        this.isCharacterDevice = stats.isCharacterDevice.bind(stats);
        this.isDirectory = stats.isDirectory.bind(stats);
        this.isFIFO = stats.isFIFO.bind(stats);
        this.isFile = stats.isFile.bind(stats);
        this.isSocket = stats.isSocket.bind(stats);
        this.isSymbolicLink = stats.isSymbolicLink.bind(stats);
      }
    };
    function createDirentFromStats(name, stats) {
      return new DirentFromStats(name, stats);
    }
    exports2.createDirentFromStats = createDirentFromStats;
  }
});

// node_modules/@nodelib/fs.scandir/out/utils/index.js
var require_utils6 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/utils/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fs = void 0;
    var fs = require_fs3();
    exports2.fs = fs;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/common.js
var require_common = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = void 0;
    function joinPathSegments(a, b, separator) {
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/async.js
var require_async2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var rpl = require_run_parallel();
    var constants_1 = require_constants4();
    var utils = require_utils6();
    var common = require_common();
    function read2(directory, settings, callback) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        readdirWithFileTypes(directory, settings, callback);
        return;
      }
      readdir(directory, settings, callback);
    }
    exports2.read = read2;
    function readdirWithFileTypes(directory, settings, callback) {
      settings.fs.readdir(directory, { withFileTypes: true }, (readdirError, dirents) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const entries = dirents.map((dirent) => ({
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        }));
        if (!settings.followSymbolicLinks) {
          callSuccessCallback(callback, entries);
          return;
        }
        const tasks = entries.map((entry) => makeRplTaskEntry(entry, settings));
        rpl(tasks, (rplError, rplEntries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, rplEntries);
        });
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function makeRplTaskEntry(entry, settings) {
      return (done) => {
        if (!entry.dirent.isSymbolicLink()) {
          done(null, entry);
          return;
        }
        settings.fs.stat(entry.path, (statError, stats) => {
          if (statError !== null) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              done(statError);
              return;
            }
            done(null, entry);
            return;
          }
          entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          done(null, entry);
        });
      };
    }
    function readdir(directory, settings, callback) {
      settings.fs.readdir(directory, (readdirError, names) => {
        if (readdirError !== null) {
          callFailureCallback(callback, readdirError);
          return;
        }
        const tasks = names.map((name) => {
          const path = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
          return (done) => {
            fsStat.stat(path, settings.fsStatSettings, (error, stats) => {
              if (error !== null) {
                done(error);
                return;
              }
              const entry = {
                name,
                path,
                dirent: utils.fs.createDirentFromStats(name, stats)
              };
              if (settings.stats) {
                entry.stats = stats;
              }
              done(null, entry);
            });
          };
        });
        rpl(tasks, (rplError, entries) => {
          if (rplError !== null) {
            callFailureCallback(callback, rplError);
            return;
          }
          callSuccessCallback(callback, entries);
        });
      });
    }
    exports2.readdir = readdir;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, result) {
      callback(null, result);
    }
  }
});

// node_modules/@nodelib/fs.scandir/out/providers/sync.js
var require_sync2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.readdir = exports2.readdirWithFileTypes = exports2.read = void 0;
    var fsStat = require_out();
    var constants_1 = require_constants4();
    var utils = require_utils6();
    var common = require_common();
    function read2(directory, settings) {
      if (!settings.stats && constants_1.IS_SUPPORT_READDIR_WITH_FILE_TYPES) {
        return readdirWithFileTypes(directory, settings);
      }
      return readdir(directory, settings);
    }
    exports2.read = read2;
    function readdirWithFileTypes(directory, settings) {
      const dirents = settings.fs.readdirSync(directory, { withFileTypes: true });
      return dirents.map((dirent) => {
        const entry = {
          dirent,
          name: dirent.name,
          path: common.joinPathSegments(directory, dirent.name, settings.pathSegmentSeparator)
        };
        if (entry.dirent.isSymbolicLink() && settings.followSymbolicLinks) {
          try {
            const stats = settings.fs.statSync(entry.path);
            entry.dirent = utils.fs.createDirentFromStats(entry.name, stats);
          } catch (error) {
            if (settings.throwErrorOnBrokenSymbolicLink) {
              throw error;
            }
          }
        }
        return entry;
      });
    }
    exports2.readdirWithFileTypes = readdirWithFileTypes;
    function readdir(directory, settings) {
      const names = settings.fs.readdirSync(directory);
      return names.map((name) => {
        const entryPath = common.joinPathSegments(directory, name, settings.pathSegmentSeparator);
        const stats = fsStat.statSync(entryPath, settings.fsStatSettings);
        const entry = {
          name,
          path: entryPath,
          dirent: utils.fs.createDirentFromStats(name, stats)
        };
        if (settings.stats) {
          entry.stats = stats;
        }
        return entry;
      });
    }
    exports2.readdir = readdir;
  }
});

// node_modules/@nodelib/fs.scandir/out/adapters/fs.js
var require_fs4 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/adapters/fs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createFileSystemAdapter = exports2.FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    exports2.FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      stat: fs.stat,
      lstatSync: fs.lstatSync,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    function createFileSystemAdapter(fsMethods) {
      if (fsMethods === void 0) {
        return exports2.FILE_SYSTEM_ADAPTER;
      }
      return Object.assign(Object.assign({}, exports2.FILE_SYSTEM_ADAPTER), fsMethods);
    }
    exports2.createFileSystemAdapter = createFileSystemAdapter;
  }
});

// node_modules/@nodelib/fs.scandir/out/settings.js
var require_settings2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var fs = require_fs4();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, false);
        this.fs = fs.createFileSystemAdapter(this._options.fs);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.stats = this._getValue(this._options.stats, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, true);
        this.fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this.followSymbolicLinks,
          fs: this.fs,
          throwErrorOnBrokenSymbolicLink: this.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.scandir/out/index.js
var require_out2 = __commonJS({
  "node_modules/@nodelib/fs.scandir/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.scandirSync = exports2.scandir = void 0;
    var async = require_async2();
    var sync = require_sync2();
    var settings_1 = require_settings2();
    exports2.Settings = settings_1.default;
    function scandir(path, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        async.read(path, getSettings(), optionsOrSettingsOrCallback);
        return;
      }
      async.read(path, getSettings(optionsOrSettingsOrCallback), callback);
    }
    exports2.scandir = scandir;
    function scandirSync(path, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      return sync.read(path, settings);
    }
    exports2.scandirSync = scandirSync;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/reusify/reusify.js
var require_reusify = __commonJS({
  "node_modules/reusify/reusify.js"(exports2, module2) {
    "use strict";
    function reusify(Constructor) {
      var head = new Constructor();
      var tail = head;
      function get() {
        var current = head;
        if (current.next) {
          head = current.next;
        } else {
          head = new Constructor();
          tail = head;
        }
        current.next = null;
        return current;
      }
      function release(obj) {
        tail.next = obj;
        tail = obj;
      }
      return {
        get,
        release
      };
    }
    module2.exports = reusify;
  }
});

// node_modules/fastq/queue.js
var require_queue = __commonJS({
  "node_modules/fastq/queue.js"(exports2, module2) {
    "use strict";
    var reusify = require_reusify();
    function fastqueue(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      if (concurrency < 1) {
        throw new Error("fastqueue concurrency must be greater than 1");
      }
      var cache = reusify(Task);
      var queueHead = null;
      var queueTail = null;
      var _running = 0;
      var errorHandler = null;
      var self2 = {
        push,
        drain: noop,
        saturated: noop,
        pause,
        paused: false,
        concurrency,
        running,
        resume,
        idle,
        length,
        getQueue,
        unshift,
        empty: noop,
        kill,
        killAndDrain,
        error
      };
      return self2;
      function running() {
        return _running;
      }
      function pause() {
        self2.paused = true;
      }
      function length() {
        var current = queueHead;
        var counter = 0;
        while (current) {
          current = current.next;
          counter++;
        }
        return counter;
      }
      function getQueue() {
        var current = queueHead;
        var tasks = [];
        while (current) {
          tasks.push(current.value);
          current = current.next;
        }
        return tasks;
      }
      function resume() {
        if (!self2.paused)
          return;
        self2.paused = false;
        for (var i = 0; i < self2.concurrency; i++) {
          _running++;
          release();
        }
      }
      function idle() {
        return _running === 0 && self2.length() === 0;
      }
      function push(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        current.errorHandler = errorHandler;
        if (_running === self2.concurrency || self2.paused) {
          if (queueTail) {
            queueTail.next = current;
            queueTail = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function unshift(value, done) {
        var current = cache.get();
        current.context = context;
        current.release = release;
        current.value = value;
        current.callback = done || noop;
        if (_running === self2.concurrency || self2.paused) {
          if (queueHead) {
            current.next = queueHead;
            queueHead = current;
          } else {
            queueHead = current;
            queueTail = current;
            self2.saturated();
          }
        } else {
          _running++;
          worker.call(context, current.value, current.worked);
        }
      }
      function release(holder) {
        if (holder) {
          cache.release(holder);
        }
        var next = queueHead;
        if (next) {
          if (!self2.paused) {
            if (queueTail === queueHead) {
              queueTail = null;
            }
            queueHead = next.next;
            next.next = null;
            worker.call(context, next.value, next.worked);
            if (queueTail === null) {
              self2.empty();
            }
          } else {
            _running--;
          }
        } else if (--_running === 0) {
          self2.drain();
        }
      }
      function kill() {
        queueHead = null;
        queueTail = null;
        self2.drain = noop;
      }
      function killAndDrain() {
        queueHead = null;
        queueTail = null;
        self2.drain();
        self2.drain = noop;
      }
      function error(handler) {
        errorHandler = handler;
      }
    }
    function noop() {
    }
    function Task() {
      this.value = null;
      this.callback = noop;
      this.next = null;
      this.release = noop;
      this.context = null;
      this.errorHandler = null;
      var self2 = this;
      this.worked = function worked(err, result) {
        var callback = self2.callback;
        var errorHandler = self2.errorHandler;
        var val = self2.value;
        self2.value = null;
        self2.callback = noop;
        if (self2.errorHandler) {
          errorHandler(err, val);
        }
        callback.call(self2.context, err, result);
        self2.release(self2);
      };
    }
    function queueAsPromised(context, worker, concurrency) {
      if (typeof context === "function") {
        concurrency = worker;
        worker = context;
        context = null;
      }
      function asyncWrapper(arg, cb) {
        worker.call(this, arg).then(function(res) {
          cb(null, res);
        }, cb);
      }
      var queue = fastqueue(context, asyncWrapper, concurrency);
      var pushCb = queue.push;
      var unshiftCb = queue.unshift;
      queue.push = push;
      queue.unshift = unshift;
      queue.drained = drained;
      return queue;
      function push(value) {
        var p = new Promise(function(resolve, reject) {
          pushCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function unshift(value) {
        var p = new Promise(function(resolve, reject) {
          unshiftCb(value, function(err, result) {
            if (err) {
              reject(err);
              return;
            }
            resolve(result);
          });
        });
        p.catch(noop);
        return p;
      }
      function drained() {
        var previousDrain = queue.drain;
        var p = new Promise(function(resolve) {
          queue.drain = function() {
            previousDrain();
            resolve();
          };
        });
        return p;
      }
    }
    module2.exports = fastqueue;
    module2.exports.promise = queueAsPromised;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/common.js
var require_common2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/common.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.joinPathSegments = exports2.replacePathSegmentSeparator = exports2.isAppliedFilter = exports2.isFatalError = void 0;
    function isFatalError(settings, error) {
      if (settings.errorFilter === null) {
        return true;
      }
      return !settings.errorFilter(error);
    }
    exports2.isFatalError = isFatalError;
    function isAppliedFilter(filter, value) {
      return filter === null || filter(value);
    }
    exports2.isAppliedFilter = isAppliedFilter;
    function replacePathSegmentSeparator(filepath, separator) {
      return filepath.split(/[/\\]/).join(separator);
    }
    exports2.replacePathSegmentSeparator = replacePathSegmentSeparator;
    function joinPathSegments(a, b, separator) {
      if (a === "") {
        return b;
      }
      if (a.endsWith(separator)) {
        return a + b;
      }
      return a + separator + b;
    }
    exports2.joinPathSegments = joinPathSegments;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/reader.js
var require_reader = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var common = require_common2();
    var Reader = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._root = common.replacePathSegmentSeparator(_root, _settings.pathSegmentSeparator);
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/async.js
var require_async3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var events_1 = require("events");
    var fsScandir = require_out2();
    var fastq = require_queue();
    var common = require_common2();
    var reader_1 = require_reader();
    var AsyncReader = class extends reader_1.default {
      constructor(_root, _settings) {
        super(_root, _settings);
        this._settings = _settings;
        this._scandir = fsScandir.scandir;
        this._emitter = new events_1.EventEmitter();
        this._queue = fastq(this._worker.bind(this), this._settings.concurrency);
        this._isFatalError = false;
        this._isDestroyed = false;
        this._queue.drain = () => {
          if (!this._isFatalError) {
            this._emitter.emit("end");
          }
        };
      }
      read() {
        this._isFatalError = false;
        this._isDestroyed = false;
        setImmediate(() => {
          this._pushToQueue(this._root, this._settings.basePath);
        });
        return this._emitter;
      }
      get isDestroyed() {
        return this._isDestroyed;
      }
      destroy() {
        if (this._isDestroyed) {
          throw new Error("The reader is already destroyed");
        }
        this._isDestroyed = true;
        this._queue.killAndDrain();
      }
      onEntry(callback) {
        this._emitter.on("entry", callback);
      }
      onError(callback) {
        this._emitter.once("error", callback);
      }
      onEnd(callback) {
        this._emitter.once("end", callback);
      }
      _pushToQueue(directory, base) {
        const queueItem = { directory, base };
        this._queue.push(queueItem, (error) => {
          if (error !== null) {
            this._handleError(error);
          }
        });
      }
      _worker(item, done) {
        this._scandir(item.directory, this._settings.fsScandirSettings, (error, entries) => {
          if (error !== null) {
            done(error, void 0);
            return;
          }
          for (const entry of entries) {
            this._handleEntry(entry, item.base);
          }
          done(null, void 0);
        });
      }
      _handleError(error) {
        if (this._isDestroyed || !common.isFatalError(this._settings, error)) {
          return;
        }
        this._isFatalError = true;
        this._isDestroyed = true;
        this._emitter.emit("error", error);
      }
      _handleEntry(entry, base) {
        if (this._isDestroyed || this._isFatalError) {
          return;
        }
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._emitEntry(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _emitEntry(entry) {
        this._emitter.emit("entry", entry);
      }
    };
    exports2.default = AsyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/async.js
var require_async4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var async_1 = require_async3();
    var AsyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._storage = [];
      }
      read(callback) {
        this._reader.onError((error) => {
          callFailureCallback(callback, error);
        });
        this._reader.onEntry((entry) => {
          this._storage.push(entry);
        });
        this._reader.onEnd(() => {
          callSuccessCallback(callback, this._storage);
        });
        this._reader.read();
      }
    };
    exports2.default = AsyncProvider;
    function callFailureCallback(callback, error) {
      callback(error);
    }
    function callSuccessCallback(callback, entries) {
      callback(null, entries);
    }
  }
});

// node_modules/@nodelib/fs.walk/out/providers/stream.js
var require_stream2 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var async_1 = require_async3();
    var StreamProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new async_1.default(this._root, this._settings);
        this._stream = new stream_1.Readable({
          objectMode: true,
          read: () => {
          },
          destroy: () => {
            if (!this._reader.isDestroyed) {
              this._reader.destroy();
            }
          }
        });
      }
      read() {
        this._reader.onError((error) => {
          this._stream.emit("error", error);
        });
        this._reader.onEntry((entry) => {
          this._stream.push(entry);
        });
        this._reader.onEnd(() => {
          this._stream.push(null);
        });
        this._reader.read();
        return this._stream;
      }
    };
    exports2.default = StreamProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/readers/sync.js
var require_sync3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsScandir = require_out2();
    var common = require_common2();
    var reader_1 = require_reader();
    var SyncReader = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._scandir = fsScandir.scandirSync;
        this._storage = [];
        this._queue = /* @__PURE__ */ new Set();
      }
      read() {
        this._pushToQueue(this._root, this._settings.basePath);
        this._handleQueue();
        return this._storage;
      }
      _pushToQueue(directory, base) {
        this._queue.add({ directory, base });
      }
      _handleQueue() {
        for (const item of this._queue.values()) {
          this._handleDirectory(item.directory, item.base);
        }
      }
      _handleDirectory(directory, base) {
        try {
          const entries = this._scandir(directory, this._settings.fsScandirSettings);
          for (const entry of entries) {
            this._handleEntry(entry, base);
          }
        } catch (error) {
          this._handleError(error);
        }
      }
      _handleError(error) {
        if (!common.isFatalError(this._settings, error)) {
          return;
        }
        throw error;
      }
      _handleEntry(entry, base) {
        const fullpath = entry.path;
        if (base !== void 0) {
          entry.path = common.joinPathSegments(base, entry.name, this._settings.pathSegmentSeparator);
        }
        if (common.isAppliedFilter(this._settings.entryFilter, entry)) {
          this._pushToStorage(entry);
        }
        if (entry.dirent.isDirectory() && common.isAppliedFilter(this._settings.deepFilter, entry)) {
          this._pushToQueue(fullpath, base === void 0 ? void 0 : entry.path);
        }
      }
      _pushToStorage(entry) {
        this._storage.push(entry);
      }
    };
    exports2.default = SyncReader;
  }
});

// node_modules/@nodelib/fs.walk/out/providers/sync.js
var require_sync4 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync3();
    var SyncProvider = class {
      constructor(_root, _settings) {
        this._root = _root;
        this._settings = _settings;
        this._reader = new sync_1.default(this._root, this._settings);
      }
      read() {
        return this._reader.read();
      }
    };
    exports2.default = SyncProvider;
  }
});

// node_modules/@nodelib/fs.walk/out/settings.js
var require_settings3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsScandir = require_out2();
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.basePath = this._getValue(this._options.basePath, void 0);
        this.concurrency = this._getValue(this._options.concurrency, Number.POSITIVE_INFINITY);
        this.deepFilter = this._getValue(this._options.deepFilter, null);
        this.entryFilter = this._getValue(this._options.entryFilter, null);
        this.errorFilter = this._getValue(this._options.errorFilter, null);
        this.pathSegmentSeparator = this._getValue(this._options.pathSegmentSeparator, path.sep);
        this.fsScandirSettings = new fsScandir.Settings({
          followSymbolicLinks: this._options.followSymbolicLinks,
          fs: this._options.fs,
          pathSegmentSeparator: this._options.pathSegmentSeparator,
          stats: this._options.stats,
          throwErrorOnBrokenSymbolicLink: this._options.throwErrorOnBrokenSymbolicLink
        });
      }
      _getValue(option, value) {
        return option !== null && option !== void 0 ? option : value;
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/@nodelib/fs.walk/out/index.js
var require_out3 = __commonJS({
  "node_modules/@nodelib/fs.walk/out/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Settings = exports2.walkStream = exports2.walkSync = exports2.walk = void 0;
    var async_1 = require_async4();
    var stream_1 = require_stream2();
    var sync_1 = require_sync4();
    var settings_1 = require_settings3();
    exports2.Settings = settings_1.default;
    function walk(directory, optionsOrSettingsOrCallback, callback) {
      if (typeof optionsOrSettingsOrCallback === "function") {
        new async_1.default(directory, getSettings()).read(optionsOrSettingsOrCallback);
        return;
      }
      new async_1.default(directory, getSettings(optionsOrSettingsOrCallback)).read(callback);
    }
    exports2.walk = walk;
    function walkSync(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new sync_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkSync = walkSync;
    function walkStream(directory, optionsOrSettings) {
      const settings = getSettings(optionsOrSettings);
      const provider = new stream_1.default(directory, settings);
      return provider.read();
    }
    exports2.walkStream = walkStream;
    function getSettings(settingsOrOptions = {}) {
      if (settingsOrOptions instanceof settings_1.default) {
        return settingsOrOptions;
      }
      return new settings_1.default(settingsOrOptions);
    }
  }
});

// node_modules/fast-glob/out/readers/reader.js
var require_reader2 = __commonJS({
  "node_modules/fast-glob/out/readers/reader.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var fsStat = require_out();
    var utils = require_utils5();
    var Reader = class {
      constructor(_settings) {
        this._settings = _settings;
        this._fsStatSettings = new fsStat.Settings({
          followSymbolicLink: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          throwErrorOnBrokenSymbolicLink: this._settings.followSymbolicLinks
        });
      }
      _getFullEntryPath(filepath) {
        return path.resolve(this._settings.cwd, filepath);
      }
      _makeEntry(stats, pattern) {
        const entry = {
          name: pattern,
          path: pattern,
          dirent: utils.fs.createDirentFromStats(pattern, stats)
        };
        if (this._settings.stats) {
          entry.stats = stats;
        }
        return entry;
      }
      _isFatalError(error) {
        return !utils.errno.isEnoentCodeError(error) && !this._settings.suppressErrors;
      }
    };
    exports2.default = Reader;
  }
});

// node_modules/fast-glob/out/readers/stream.js
var require_stream3 = __commonJS({
  "node_modules/fast-glob/out/readers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderStream = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkStream = fsWalk.walkStream;
        this._stat = fsStat.stat;
      }
      dynamic(root, options) {
        return this._walkStream(root, options);
      }
      static(patterns, options) {
        const filepaths = patterns.map(this._getFullEntryPath, this);
        const stream = new stream_1.PassThrough({ objectMode: true });
        stream._write = (index, _enc, done) => {
          return this._getEntry(filepaths[index], patterns[index], options).then((entry) => {
            if (entry !== null && options.entryFilter(entry)) {
              stream.push(entry);
            }
            if (index === filepaths.length - 1) {
              stream.end();
            }
            done();
          }).catch(done);
        };
        for (let i = 0; i < filepaths.length; i++) {
          stream.write(i);
        }
        return stream;
      }
      _getEntry(filepath, pattern, options) {
        return this._getStat(filepath).then((stats) => this._makeEntry(stats, pattern)).catch((error) => {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        });
      }
      _getStat(filepath) {
        return new Promise((resolve, reject) => {
          this._stat(filepath, this._fsStatSettings, (error, stats) => {
            return error === null ? resolve(stats) : reject(error);
          });
        });
      }
    };
    exports2.default = ReaderStream;
  }
});

// node_modules/fast-glob/out/providers/matchers/matcher.js
var require_matcher = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/matcher.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils5();
    var Matcher = class {
      constructor(_patterns, _settings, _micromatchOptions) {
        this._patterns = _patterns;
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this._storage = [];
        this._fillStorage();
      }
      _fillStorage() {
        const patterns = utils.pattern.expandPatternsWithBraceExpansion(this._patterns);
        for (const pattern of patterns) {
          const segments = this._getPatternSegments(pattern);
          const sections = this._splitSegmentsIntoSections(segments);
          this._storage.push({
            complete: sections.length <= 1,
            pattern,
            segments,
            sections
          });
        }
      }
      _getPatternSegments(pattern) {
        const parts = utils.pattern.getPatternParts(pattern, this._micromatchOptions);
        return parts.map((part) => {
          const dynamic = utils.pattern.isDynamicPattern(part, this._settings);
          if (!dynamic) {
            return {
              dynamic: false,
              pattern: part
            };
          }
          return {
            dynamic: true,
            pattern: part,
            patternRe: utils.pattern.makeRe(part, this._micromatchOptions)
          };
        });
      }
      _splitSegmentsIntoSections(segments) {
        return utils.array.splitWhen(segments, (segment) => segment.dynamic && utils.pattern.hasGlobStar(segment.pattern));
      }
    };
    exports2.default = Matcher;
  }
});

// node_modules/fast-glob/out/providers/matchers/partial.js
var require_partial = __commonJS({
  "node_modules/fast-glob/out/providers/matchers/partial.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var matcher_1 = require_matcher();
    var PartialMatcher = class extends matcher_1.default {
      match(filepath) {
        const parts = filepath.split("/");
        const levels = parts.length;
        const patterns = this._storage.filter((info) => !info.complete || info.segments.length > levels);
        for (const pattern of patterns) {
          const section = pattern.sections[0];
          if (!pattern.complete && levels > section.length) {
            return true;
          }
          const match = parts.every((part, index) => {
            const segment = pattern.segments[index];
            if (segment.dynamic && segment.patternRe.test(part)) {
              return true;
            }
            if (!segment.dynamic && segment.pattern === part) {
              return true;
            }
            return false;
          });
          if (match) {
            return true;
          }
        }
        return false;
      }
    };
    exports2.default = PartialMatcher;
  }
});

// node_modules/fast-glob/out/providers/filters/deep.js
var require_deep = __commonJS({
  "node_modules/fast-glob/out/providers/filters/deep.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils5();
    var partial_1 = require_partial();
    var DeepFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
      }
      getFilter(basePath, positive, negative) {
        const matcher = this._getMatcher(positive);
        const negativeRe = this._getNegativePatternsRe(negative);
        return (entry) => this._filter(basePath, entry, matcher, negativeRe);
      }
      _getMatcher(patterns) {
        return new partial_1.default(patterns, this._settings, this._micromatchOptions);
      }
      _getNegativePatternsRe(patterns) {
        const affectDepthOfReadingPatterns = patterns.filter(utils.pattern.isAffectDepthOfReadingPattern);
        return utils.pattern.convertPatternsToRe(affectDepthOfReadingPatterns, this._micromatchOptions);
      }
      _filter(basePath, entry, matcher, negativeRe) {
        if (this._isSkippedByDeep(basePath, entry.path)) {
          return false;
        }
        if (this._isSkippedSymbolicLink(entry)) {
          return false;
        }
        const filepath = utils.path.removeLeadingDotSegment(entry.path);
        if (this._isSkippedByPositivePatterns(filepath, matcher)) {
          return false;
        }
        return this._isSkippedByNegativePatterns(filepath, negativeRe);
      }
      _isSkippedByDeep(basePath, entryPath) {
        if (this._settings.deep === Infinity) {
          return false;
        }
        return this._getEntryLevel(basePath, entryPath) >= this._settings.deep;
      }
      _getEntryLevel(basePath, entryPath) {
        const entryPathDepth = entryPath.split("/").length;
        if (basePath === "") {
          return entryPathDepth;
        }
        const basePathDepth = basePath.split("/").length;
        return entryPathDepth - basePathDepth;
      }
      _isSkippedSymbolicLink(entry) {
        return !this._settings.followSymbolicLinks && entry.dirent.isSymbolicLink();
      }
      _isSkippedByPositivePatterns(entryPath, matcher) {
        return !this._settings.baseNameMatch && !matcher.match(entryPath);
      }
      _isSkippedByNegativePatterns(entryPath, patternsRe) {
        return !utils.pattern.matchAny(entryPath, patternsRe);
      }
    };
    exports2.default = DeepFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/entry.js
var require_entry = __commonJS({
  "node_modules/fast-glob/out/providers/filters/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils5();
    var EntryFilter = class {
      constructor(_settings, _micromatchOptions) {
        this._settings = _settings;
        this._micromatchOptions = _micromatchOptions;
        this.index = /* @__PURE__ */ new Map();
      }
      getFilter(positive, negative) {
        const positiveRe = utils.pattern.convertPatternsToRe(positive, this._micromatchOptions);
        const negativeRe = utils.pattern.convertPatternsToRe(negative, this._micromatchOptions);
        return (entry) => this._filter(entry, positiveRe, negativeRe);
      }
      _filter(entry, positiveRe, negativeRe) {
        if (this._settings.unique && this._isDuplicateEntry(entry)) {
          return false;
        }
        if (this._onlyFileFilter(entry) || this._onlyDirectoryFilter(entry)) {
          return false;
        }
        if (this._isSkippedByAbsoluteNegativePatterns(entry.path, negativeRe)) {
          return false;
        }
        const filepath = this._settings.baseNameMatch ? entry.name : entry.path;
        const isMatched = this._isMatchToPatterns(filepath, positiveRe) && !this._isMatchToPatterns(entry.path, negativeRe);
        if (this._settings.unique && isMatched) {
          this._createIndexRecord(entry);
        }
        return isMatched;
      }
      _isDuplicateEntry(entry) {
        return this.index.has(entry.path);
      }
      _createIndexRecord(entry) {
        this.index.set(entry.path, void 0);
      }
      _onlyFileFilter(entry) {
        return this._settings.onlyFiles && !entry.dirent.isFile();
      }
      _onlyDirectoryFilter(entry) {
        return this._settings.onlyDirectories && !entry.dirent.isDirectory();
      }
      _isSkippedByAbsoluteNegativePatterns(entryPath, patternsRe) {
        if (!this._settings.absolute) {
          return false;
        }
        const fullpath = utils.path.makeAbsolute(this._settings.cwd, entryPath);
        return utils.pattern.matchAny(fullpath, patternsRe);
      }
      _isMatchToPatterns(entryPath, patternsRe) {
        const filepath = utils.path.removeLeadingDotSegment(entryPath);
        return utils.pattern.matchAny(filepath, patternsRe) || utils.pattern.matchAny(filepath + "/", patternsRe);
      }
    };
    exports2.default = EntryFilter;
  }
});

// node_modules/fast-glob/out/providers/filters/error.js
var require_error = __commonJS({
  "node_modules/fast-glob/out/providers/filters/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils5();
    var ErrorFilter = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getFilter() {
        return (error) => this._isNonFatalError(error);
      }
      _isNonFatalError(error) {
        return utils.errno.isEnoentCodeError(error) || this._settings.suppressErrors;
      }
    };
    exports2.default = ErrorFilter;
  }
});

// node_modules/fast-glob/out/providers/transformers/entry.js
var require_entry2 = __commonJS({
  "node_modules/fast-glob/out/providers/transformers/entry.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils5();
    var EntryTransformer = class {
      constructor(_settings) {
        this._settings = _settings;
      }
      getTransformer() {
        return (entry) => this._transform(entry);
      }
      _transform(entry) {
        let filepath = entry.path;
        if (this._settings.absolute) {
          filepath = utils.path.makeAbsolute(this._settings.cwd, filepath);
          filepath = utils.path.unixify(filepath);
        }
        if (this._settings.markDirectories && entry.dirent.isDirectory()) {
          filepath += "/";
        }
        if (!this._settings.objectMode) {
          return filepath;
        }
        return Object.assign(Object.assign({}, entry), { path: filepath });
      }
    };
    exports2.default = EntryTransformer;
  }
});

// node_modules/fast-glob/out/providers/provider.js
var require_provider = __commonJS({
  "node_modules/fast-glob/out/providers/provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var path = require("path");
    var deep_1 = require_deep();
    var entry_1 = require_entry();
    var error_1 = require_error();
    var entry_2 = require_entry2();
    var Provider = class {
      constructor(_settings) {
        this._settings = _settings;
        this.errorFilter = new error_1.default(this._settings);
        this.entryFilter = new entry_1.default(this._settings, this._getMicromatchOptions());
        this.deepFilter = new deep_1.default(this._settings, this._getMicromatchOptions());
        this.entryTransformer = new entry_2.default(this._settings);
      }
      _getRootDirectory(task) {
        return path.resolve(this._settings.cwd, task.base);
      }
      _getReaderOptions(task) {
        const basePath = task.base === "." ? "" : task.base;
        return {
          basePath,
          pathSegmentSeparator: "/",
          concurrency: this._settings.concurrency,
          deepFilter: this.deepFilter.getFilter(basePath, task.positive, task.negative),
          entryFilter: this.entryFilter.getFilter(task.positive, task.negative),
          errorFilter: this.errorFilter.getFilter(),
          followSymbolicLinks: this._settings.followSymbolicLinks,
          fs: this._settings.fs,
          stats: this._settings.stats,
          throwErrorOnBrokenSymbolicLink: this._settings.throwErrorOnBrokenSymbolicLink,
          transform: this.entryTransformer.getTransformer()
        };
      }
      _getMicromatchOptions() {
        return {
          dot: this._settings.dot,
          matchBase: this._settings.baseNameMatch,
          nobrace: !this._settings.braceExpansion,
          nocase: !this._settings.caseSensitiveMatch,
          noext: !this._settings.extglob,
          noglobstar: !this._settings.globstar,
          posix: true,
          strictSlashes: false
        };
      }
    };
    exports2.default = Provider;
  }
});

// node_modules/fast-glob/out/providers/async.js
var require_async5 = __commonJS({
  "node_modules/fast-glob/out/providers/async.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require_stream3();
    var provider_1 = require_provider();
    var ProviderAsync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = [];
        return new Promise((resolve, reject) => {
          const stream = this.api(root, task, options);
          stream.once("error", reject);
          stream.on("data", (entry) => entries.push(options.transform(entry)));
          stream.once("end", () => resolve(entries));
        });
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderAsync;
  }
});

// node_modules/fast-glob/out/providers/stream.js
var require_stream4 = __commonJS({
  "node_modules/fast-glob/out/providers/stream.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stream_1 = require("stream");
    var stream_2 = require_stream3();
    var provider_1 = require_provider();
    var ProviderStream = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new stream_2.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const source = this.api(root, task, options);
        const destination = new stream_1.Readable({ objectMode: true, read: () => {
        } });
        source.once("error", (error) => destination.emit("error", error)).on("data", (entry) => destination.emit("data", options.transform(entry))).once("end", () => destination.emit("end"));
        destination.once("close", () => source.destroy());
        return destination;
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderStream;
  }
});

// node_modules/fast-glob/out/readers/sync.js
var require_sync5 = __commonJS({
  "node_modules/fast-glob/out/readers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var fsStat = require_out();
    var fsWalk = require_out3();
    var reader_1 = require_reader2();
    var ReaderSync = class extends reader_1.default {
      constructor() {
        super(...arguments);
        this._walkSync = fsWalk.walkSync;
        this._statSync = fsStat.statSync;
      }
      dynamic(root, options) {
        return this._walkSync(root, options);
      }
      static(patterns, options) {
        const entries = [];
        for (const pattern of patterns) {
          const filepath = this._getFullEntryPath(pattern);
          const entry = this._getEntry(filepath, pattern, options);
          if (entry === null || !options.entryFilter(entry)) {
            continue;
          }
          entries.push(entry);
        }
        return entries;
      }
      _getEntry(filepath, pattern, options) {
        try {
          const stats = this._getStat(filepath);
          return this._makeEntry(stats, pattern);
        } catch (error) {
          if (options.errorFilter(error)) {
            return null;
          }
          throw error;
        }
      }
      _getStat(filepath) {
        return this._statSync(filepath, this._fsStatSettings);
      }
    };
    exports2.default = ReaderSync;
  }
});

// node_modules/fast-glob/out/providers/sync.js
var require_sync6 = __commonJS({
  "node_modules/fast-glob/out/providers/sync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var sync_1 = require_sync5();
    var provider_1 = require_provider();
    var ProviderSync = class extends provider_1.default {
      constructor() {
        super(...arguments);
        this._reader = new sync_1.default(this._settings);
      }
      read(task) {
        const root = this._getRootDirectory(task);
        const options = this._getReaderOptions(task);
        const entries = this.api(root, task, options);
        return entries.map(options.transform);
      }
      api(root, task, options) {
        if (task.dynamic) {
          return this._reader.dynamic(root, options);
        }
        return this._reader.static(task.patterns, options);
      }
    };
    exports2.default = ProviderSync;
  }
});

// node_modules/fast-glob/out/settings.js
var require_settings4 = __commonJS({
  "node_modules/fast-glob/out/settings.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = void 0;
    var fs = require("fs");
    var os = require("os");
    var CPU_COUNT = Math.max(os.cpus().length, 1);
    exports2.DEFAULT_FILE_SYSTEM_ADAPTER = {
      lstat: fs.lstat,
      lstatSync: fs.lstatSync,
      stat: fs.stat,
      statSync: fs.statSync,
      readdir: fs.readdir,
      readdirSync: fs.readdirSync
    };
    var Settings = class {
      constructor(_options = {}) {
        this._options = _options;
        this.absolute = this._getValue(this._options.absolute, false);
        this.baseNameMatch = this._getValue(this._options.baseNameMatch, false);
        this.braceExpansion = this._getValue(this._options.braceExpansion, true);
        this.caseSensitiveMatch = this._getValue(this._options.caseSensitiveMatch, true);
        this.concurrency = this._getValue(this._options.concurrency, CPU_COUNT);
        this.cwd = this._getValue(this._options.cwd, process.cwd());
        this.deep = this._getValue(this._options.deep, Infinity);
        this.dot = this._getValue(this._options.dot, false);
        this.extglob = this._getValue(this._options.extglob, true);
        this.followSymbolicLinks = this._getValue(this._options.followSymbolicLinks, true);
        this.fs = this._getFileSystemMethods(this._options.fs);
        this.globstar = this._getValue(this._options.globstar, true);
        this.ignore = this._getValue(this._options.ignore, []);
        this.markDirectories = this._getValue(this._options.markDirectories, false);
        this.objectMode = this._getValue(this._options.objectMode, false);
        this.onlyDirectories = this._getValue(this._options.onlyDirectories, false);
        this.onlyFiles = this._getValue(this._options.onlyFiles, true);
        this.stats = this._getValue(this._options.stats, false);
        this.suppressErrors = this._getValue(this._options.suppressErrors, false);
        this.throwErrorOnBrokenSymbolicLink = this._getValue(this._options.throwErrorOnBrokenSymbolicLink, false);
        this.unique = this._getValue(this._options.unique, true);
        if (this.onlyDirectories) {
          this.onlyFiles = false;
        }
        if (this.stats) {
          this.objectMode = true;
        }
      }
      _getValue(option, value) {
        return option === void 0 ? value : option;
      }
      _getFileSystemMethods(methods = {}) {
        return Object.assign(Object.assign({}, exports2.DEFAULT_FILE_SYSTEM_ADAPTER), methods);
      }
    };
    exports2.default = Settings;
  }
});

// node_modules/fast-glob/out/index.js
var require_out4 = __commonJS({
  "node_modules/fast-glob/out/index.js"(exports2, module2) {
    "use strict";
    var taskManager = require_tasks();
    var patternManager = require_patterns();
    var async_1 = require_async5();
    var stream_1 = require_stream4();
    var sync_1 = require_sync6();
    var settings_1 = require_settings4();
    var utils = require_utils5();
    async function FastGlob(source, options) {
      assertPatternsInput(source);
      const works = getWorks(source, async_1.default, options);
      const result = await Promise.all(works);
      return utils.array.flatten(result);
    }
    (function(FastGlob2) {
      function sync(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, sync_1.default, options);
        return utils.array.flatten(works);
      }
      FastGlob2.sync = sync;
      function stream(source, options) {
        assertPatternsInput(source);
        const works = getWorks(source, stream_1.default, options);
        return utils.stream.merge(works);
      }
      FastGlob2.stream = stream;
      function generateTasks(source, options) {
        assertPatternsInput(source);
        const patterns = patternManager.transform([].concat(source));
        const settings = new settings_1.default(options);
        return taskManager.generate(patterns, settings);
      }
      FastGlob2.generateTasks = generateTasks;
      function isDynamicPattern(source, options) {
        assertPatternsInput(source);
        const settings = new settings_1.default(options);
        return utils.pattern.isDynamicPattern(source, settings);
      }
      FastGlob2.isDynamicPattern = isDynamicPattern;
      function escapePath(source) {
        assertPatternsInput(source);
        return utils.path.escape(source);
      }
      FastGlob2.escapePath = escapePath;
    })(FastGlob || (FastGlob = {}));
    function getWorks(source, _Provider, options) {
      const patterns = patternManager.transform([].concat(source));
      const settings = new settings_1.default(options);
      const tasks = taskManager.generate(patterns, settings);
      const provider = new _Provider(settings);
      return tasks.map(provider.read, provider);
    }
    function assertPatternsInput(input) {
      const source = [].concat(input);
      const isValidSource = source.every((item) => utils.string.isString(item) && !utils.string.isEmpty(item));
      if (!isValidSource) {
        throw new TypeError("Patterns must be a string (non empty) or an array of strings");
      }
    }
    module2.exports = FastGlob;
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/fs.js
var require_fs5 = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/fs.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findPaths = exports2.loadGherkinSources = exports2.getLanguage = exports2.loadGlueSources = exports2.glueExtByLanguageName = void 0;
    var fast_glob_1 = __importDefault(require_out4());
    var promises_1 = __importDefault(require("fs/promises"));
    var path_1 = require("path");
    exports2.glueExtByLanguageName = {
      typescript: ".ts",
      java: ".java",
      c_sharp: ".cs",
      php: ".php",
      ruby: ".rb"
    };
    var glueLanguageNameByExt = Object.fromEntries(Object.entries(exports2.glueExtByLanguageName).map(([language, ext]) => [ext, language]));
    var glueExtensions = new Set(Object.keys(glueLanguageNameByExt));
    function loadGlueSources(globs) {
      return __awaiter(this, void 0, void 0, function* () {
        return loadSources(globs, glueExtensions, glueLanguageNameByExt);
      });
    }
    exports2.loadGlueSources = loadGlueSources;
    function getLanguage(ext) {
      return glueLanguageNameByExt[ext];
    }
    exports2.getLanguage = getLanguage;
    function loadGherkinSources(globs) {
      return __awaiter(this, void 0, void 0, function* () {
        return loadSources(globs, /* @__PURE__ */ new Set([".feature"]), { ".feature": "gherkin" });
      });
    }
    exports2.loadGherkinSources = loadGherkinSources;
    function findPaths(globs) {
      return __awaiter(this, void 0, void 0, function* () {
        const pathPromises = globs.reduce((prev, glob) => {
          return prev.concat((0, fast_glob_1.default)(glob, { caseSensitiveMatch: false, onlyFiles: true }));
        }, []);
        const pathArrays = yield Promise.all(pathPromises);
        const paths = pathArrays.flatMap((paths2) => paths2);
        return [...new Set(paths).values()].sort();
      });
    }
    exports2.findPaths = findPaths;
    function loadSources(globs, extensions, languageNameByExt) {
      return __awaiter(this, void 0, void 0, function* () {
        const paths = yield findPaths(globs);
        return Promise.all(paths.filter((path) => extensions.has((0, path_1.extname)(path))).map((path) => new Promise((resolve) => {
          const languageName = languageNameByExt[(0, path_1.extname)(path)];
          return promises_1.default.readFile(path, "utf-8").then((content) => resolve({
            languageName,
            content,
            uri: `file://${(0, path_1.resolve)(path)}`
          }));
        })));
      });
    }
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/getStepDefinitionSnippetLinks.js
var require_getStepDefinitionSnippetLinks = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/getStepDefinitionSnippetLinks.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getStepDefinitionSnippetLinks = void 0;
    var vscode_languageserver_types_1 = require_main2();
    function getStepDefinitionSnippetLinks(links) {
      const linksByFile = {};
      for (const link of links) {
        const targetRange = vscode_languageserver_types_1.Range.create(link.targetRange.end.line + 1, 0, link.targetRange.end.line + 1, 0);
        linksByFile[link.targetUri] = {
          targetUri: link.targetUri,
          targetRange,
          targetSelectionRange: targetRange
        };
      }
      return Object.values(linksByFile).sort((a, b) => a.targetUri.localeCompare(b.targetUri));
    }
    exports2.getStepDefinitionSnippetLinks = getStepDefinitionSnippetLinks;
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/version.js
var require_version3 = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/version.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.version = void 0;
    exports2.version = "0.12.10";
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/CucumberLanguageServer.js
var require_CucumberLanguageServer = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/CucumberLanguageServer.js"(exports2) {
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CucumberLanguageServer = void 0;
    var language_service_1 = require_src6();
    var fs_1 = require("fs");
    var path_1 = require("path");
    var util_1 = require("util");
    var vscode_languageserver_1 = require_main4();
    var buildStepTexts_js_1 = require_buildStepTexts();
    var fs_js_1 = require_fs5();
    var getStepDefinitionSnippetLinks_js_1 = require_getStepDefinitionSnippetLinks();
    var version_js_1 = require_version3();
    var stat = (0, util_1.promisify)(fs_1.stat);
    var defaultSettings = {
      features: ["src/test/**/*.feature", "features/**/*.feature"],
      glue: [
        "src/test/**/*.java",
        "features/**/*.ts",
        "features/**/*.php",
        "features/**/*.rb",
        "*specs*/**/.cs"
      ],
      parameterTypes: [],
      snippetTemplates: {}
    };
    var CucumberLanguageServer = class {
      constructor(connection, documents, parserAdapter) {
        this.connection = connection;
        this.documents = documents;
        this.expressionBuilderResult = void 0;
        this.expressionBuilder = new language_service_1.ExpressionBuilder(parserAdapter);
        connection.onInitialize((params) => __awaiter(this, void 0, void 0, function* () {
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
          yield parserAdapter.init();
          if (params.clientInfo) {
            connection.console.info(`Initializing connection from ${params.clientInfo.name} ${params.clientInfo.version}`);
          } else {
            connection.console.info(`Initializing connection from unknown client`);
          }
          if (params.rootPath) {
            this.rootPath = params.rootPath;
          } else if (params.workspaceFolders && params.workspaceFolders.length > 0) {
            this.rootPath = new URL(params.workspaceFolders[0].uri).pathname;
          } else {
            connection.console.error(`Client did not send rootPath or workspaceFolders`);
          }
          connection.console.info(`Root path   : ${this.rootPath}`);
          connection.console.info(`Current dir : ${process.cwd()}`);
          if ((_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) {
            connection.onDidChangeConfiguration((params2) => {
              this.connection.console.info(`Client sent workspace/configuration`);
              this.reindex(params2.settings).catch((err) => {
                connection.console.error(`Failed to reindex: ${err.stack}`);
              });
            });
            try {
              yield connection.client.register(vscode_languageserver_1.DidChangeConfigurationNotification.type);
            } catch (err) {
              connection.console.info(`Client does not support client/registerCapability. This is OK.`);
            }
          } else {
            this.connection.console.info("onDidChangeConfiguration is disabled");
          }
          if ((_c = (_b = params.capabilities.workspace) === null || _b === void 0 ? void 0 : _b.didChangeWatchedFiles) === null || _c === void 0 ? void 0 : _c.dynamicRegistration) {
            connection.onDidChangeWatchedFiles(() => __awaiter(this, void 0, void 0, function* () {
              connection.console.info(`onDidChangeWatchedFiles`);
            }));
          } else {
            connection.console.info("onDidChangeWatchedFiles is disabled");
          }
          if ((_d = params.capabilities.textDocument) === null || _d === void 0 ? void 0 : _d.semanticTokens) {
            connection.languages.semanticTokens.onDelta(() => {
              return {
                data: []
              };
            });
            connection.languages.semanticTokens.onRange(() => {
              return {
                data: []
              };
            });
            connection.languages.semanticTokens.on((semanticTokenParams) => {
              var _a2;
              const doc = documents.get(semanticTokenParams.textDocument.uri);
              if (!doc)
                return { data: [] };
              const gherkinSource = doc.getText();
              return (0, language_service_1.getGherkinSemanticTokens)(gherkinSource, (((_a2 = this.expressionBuilderResult) === null || _a2 === void 0 ? void 0 : _a2.expressionLinks) || []).map((l) => l.expression));
            });
          } else {
            connection.console.info("semanticTokens is disabled");
          }
          if ((_g = (_f = (_e = params.capabilities.textDocument) === null || _e === void 0 ? void 0 : _e.completion) === null || _f === void 0 ? void 0 : _f.completionItem) === null || _g === void 0 ? void 0 : _g.snippetSupport) {
            connection.onCompletion((params2) => {
              if (!this.searchIndex)
                return [];
              const doc = documents.get(params2.textDocument.uri);
              if (!doc)
                return [];
              const gherkinSource = doc.getText();
              return (0, language_service_1.getGherkinCompletionItems)(gherkinSource, params2.position, this.searchIndex).slice();
            });
            connection.onCompletionResolve((item) => item);
          } else {
            connection.console.info("onCompletion is disabled");
          }
          if ((_h = params.capabilities.textDocument) === null || _h === void 0 ? void 0 : _h.formatting) {
            connection.onDocumentFormatting((params2) => {
              const doc = documents.get(params2.textDocument.uri);
              if (!doc)
                return [];
              const gherkinSource = doc.getText();
              return (0, language_service_1.getGherkinFormattingEdits)(gherkinSource);
            });
          } else {
            connection.console.info("onDocumentFormatting is disabled");
          }
          if ((_j = params.capabilities.textDocument) === null || _j === void 0 ? void 0 : _j.codeAction) {
            connection.onCodeAction((params2) => __awaiter(this, void 0, void 0, function* () {
              const diagnostics = params2.context.diagnostics;
              if (this.rootPath && this.expressionBuilderResult) {
                const settings = yield this.getSettings();
                const links = (0, getStepDefinitionSnippetLinks_js_1.getStepDefinitionSnippetLinks)(this.expressionBuilderResult.expressionLinks.map((l) => l.locationLink));
                if (links.length === 0) {
                  connection.console.info(`Unable to generate step definition. Please create one first manually.`);
                  return [];
                }
                const codeActions = [];
                for (const link of links) {
                  const languageName = (0, fs_js_1.getLanguage)((0, path_1.extname)(link.targetUri));
                  if (!languageName) {
                    connection.console.info(`Unable to generate step definition snippet for unknown extension ${link}`);
                    return [];
                  }
                  const mustacheTemplate = settings.snippetTemplates[languageName];
                  let createFile = false;
                  try {
                    yield stat(new URL(link.targetUri));
                  } catch (_l) {
                    createFile = true;
                  }
                  const relativePath = (0, path_1.relative)(this.rootPath, new URL(link.targetUri).pathname);
                  const codeAction = (0, language_service_1.getGenerateSnippetCodeAction)(diagnostics, link, relativePath, createFile, mustacheTemplate, languageName, this.expressionBuilderResult.registry);
                  if (codeAction) {
                    codeActions.push(codeAction);
                  }
                }
                return codeActions;
              }
              return [];
            }));
          } else {
            connection.console.info("onCodeAction is disabled");
          }
          if ((_k = params.capabilities.textDocument) === null || _k === void 0 ? void 0 : _k.definition) {
            connection.onDefinition((params2) => {
              const doc = documents.get(params2.textDocument.uri);
              if (!doc || !this.expressionBuilderResult)
                return [];
              const gherkinSource = doc.getText();
              return (0, language_service_1.getStepDefinitionLocationLinks)(gherkinSource, params2.position, this.expressionBuilderResult.expressionLinks);
            });
          } else {
            connection.console.info("onDefinition is disabled");
          }
          return {
            capabilities: this.capabilities(),
            serverInfo: this.info()
          };
        }));
        connection.onInitialized(() => {
          connection.console.info(`${this.info().name} ${this.info().version} initialized`);
          this.reindex().catch((err) => connection.console.error(err.message));
        });
        documents.listen(connection);
        documents.onDidChangeContent((change) => __awaiter(this, void 0, void 0, function* () {
          this.scheduleReindexing();
          if (change.document.uri.match(/\.feature$/)) {
            yield this.sendDiagnostics(change.document);
          }
        }));
      }
      capabilities() {
        return {
          textDocumentSync: vscode_languageserver_1.TextDocumentSyncKind.Incremental,
          completionProvider: {
            resolveProvider: false
          },
          codeActionProvider: {
            resolveProvider: false,
            workDoneProgress: false,
            codeActionKinds: [vscode_languageserver_1.CodeActionKind.QuickFix]
          },
          workspace: {
            workspaceFolders: {
              changeNotifications: true,
              supported: true
            }
          },
          semanticTokensProvider: {
            range: false,
            full: {
              delta: false
            },
            legend: {
              tokenTypes: language_service_1.semanticTokenTypes,
              tokenModifiers: []
            }
          },
          documentFormattingProvider: true,
          definitionProvider: true
        };
      }
      info() {
        return {
          name: "Cucumber Language Server",
          version: version_js_1.version
        };
      }
      sendDiagnostics(textDocument) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
          const diagnostics = (0, language_service_1.getGherkinDiagnostics)(textDocument.getText(), (((_a = this.expressionBuilderResult) === null || _a === void 0 ? void 0 : _a.expressionLinks) || []).map((l) => l.expression));
          yield this.connection.sendDiagnostics({ uri: textDocument.uri, diagnostics });
        });
      }
      scheduleReindexing() {
        clearTimeout(this.reindexingTimeout);
        const timeoutMillis = 3e3;
        this.connection.console.info(`Scheduling reindexing in ${timeoutMillis} ms`);
        this.reindexingTimeout = setTimeout(() => {
          this.reindex().catch((err) => this.connection.console.error(`Failed to reindex: ${err.message}`));
        }, timeoutMillis);
      }
      getSettings() {
        return __awaiter(this, void 0, void 0, function* () {
          try {
            const config = yield this.connection.sendRequest(vscode_languageserver_1.ConfigurationRequest.type, {
              items: [
                {
                  section: "cucumber"
                }
              ]
            });
            if (config && config.length === 1) {
              const settings = config[0];
              return {
                features: getArray(settings === null || settings === void 0 ? void 0 : settings.features, defaultSettings.features),
                glue: getArray(settings === null || settings === void 0 ? void 0 : settings.glue, defaultSettings.glue),
                parameterTypes: getArray(settings === null || settings === void 0 ? void 0 : settings.parameterTypes, defaultSettings.parameterTypes),
                snippetTemplates: {}
              };
            } else {
              this.connection.console.error(`The client responded with a config we cannot process: ${JSON.stringify(config, null, 2)}`);
              this.connection.console.error(`Using default settings`);
              return defaultSettings;
            }
          } catch (err) {
            this.connection.console.error(`Failed to request configuration: ${err.message}`);
            this.connection.console.error(`Using default settings`);
            return defaultSettings;
          }
        });
      }
      reindex(settings) {
        return __awaiter(this, void 0, void 0, function* () {
          if (!settings) {
            settings = yield this.getSettings();
          }
          this.connection.console.info(`Reindexing...`);
          const gherkinSources = yield (0, fs_js_1.loadGherkinSources)(settings.features);
          this.connection.console.info(`* Found ${gherkinSources.length} feature file(s) in ${JSON.stringify(settings.features)}`);
          const stepTexts = gherkinSources.reduce((prev, gherkinSource) => prev.concat((0, buildStepTexts_js_1.buildStepTexts)(gherkinSource.content)), []);
          this.connection.console.info(`* Found ${stepTexts.length} steps in those feature files`);
          const glueSources = yield (0, fs_js_1.loadGlueSources)(settings.glue);
          this.connection.console.info(`* Found ${glueSources.length} glue file(s) in ${JSON.stringify(settings.glue)}`);
          this.expressionBuilderResult = this.expressionBuilder.build(glueSources, settings.parameterTypes);
          this.connection.console.info(`* Found ${this.expressionBuilderResult.parameterTypeLinks.length} parameter types in those glue files`);
          for (const parameterTypeLink of this.expressionBuilderResult.parameterTypeLinks) {
            this.connection.console.info(`  * {${parameterTypeLink.parameterType.name}} = ${parameterTypeLink.parameterType.regexpStrings}`);
          }
          this.connection.console.info(`* Found ${this.expressionBuilderResult.expressionLinks.length} step definitions in those glue files`);
          for (const error of this.expressionBuilderResult.errors) {
            this.connection.console.error(`* Step Definition errors: ${error.message}`);
          }
          const gherkinDocuments = this.documents.all().filter((doc) => doc.uri.match(/\.feature$/));
          yield Promise.all(gherkinDocuments.map((doc) => this.sendDiagnostics(doc).catch((err) => this.connection.console.error(`Error: ${err.message}`))));
          this.connection.languages.semanticTokens.refresh();
          try {
            const suggestions = (0, language_service_1.buildSuggestions)(this.expressionBuilderResult.registry, stepTexts, this.expressionBuilderResult.expressionLinks.map((l) => l.expression));
            this.connection.console.info(`* Built ${suggestions.length} suggestions for auto complete`);
            this.searchIndex = (0, language_service_1.jsSearchIndex)(suggestions);
          } catch (err) {
            this.connection.console.error(err.stack);
            this.connection.console.error("Please report an issue at https://github.com/cucumber/language-service/issues with the above stack trace");
          }
        });
      }
    };
    exports2.CucumberLanguageServer = CucumberLanguageServer;
    function getArray(arr, defaultArr) {
      if (!Array.isArray(arr) || arr.length === 0)
        return defaultArr;
      return arr;
    }
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/startServer.js
var require_startServer = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/startServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startServer = void 0;
    var vscode_languageserver_1 = require_main4();
    var node_1 = require_node3();
    var vscode_languageserver_textdocument_1 = require_main5();
    var CucumberLanguageServer_js_1 = require_CucumberLanguageServer();
    var version_js_1 = require_version3();
    function startServer(adapter) {
      const connection = (0, node_1.createConnection)(node_1.ProposedFeatures.all);
      const documents = new vscode_languageserver_1.TextDocuments(vscode_languageserver_textdocument_1.TextDocument);
      new CucumberLanguageServer_js_1.CucumberLanguageServer(connection, documents, adapter);
      connection.listen();
      process.on("unhandledRejection", (reason, p) => {
        connection.console.error(`Cucumber Language Server ${version_js_1.version}: Unhandled Rejection at promise: ${p}, reason: ${reason}`);
      });
    }
    exports2.startServer = startServer;
  }
});

// node_modules/@cucumber/language-server/dist/cjs/src/wasm/startWasmServer.js
var require_startWasmServer = __commonJS({
  "node_modules/@cucumber/language-server/dist/cjs/src/wasm/startWasmServer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.startWasmServer = void 0;
    var wasm_12 = require_WasmParserAdapter();
    var startServer_1 = require_startServer();
    function startWasmServer(wasmBaseUrl) {
      (0, startServer_1.startServer)(new wasm_12.WasmParserAdapter(wasmBaseUrl));
    }
    exports2.startWasmServer = startWasmServer;
  }
});

// dist/src/cucumber-language-server.js
Object.defineProperty(exports, "__esModule", { value: true });
var wasm_1 = require_startWasmServer();
(0, wasm_1.startWasmServer)(__dirname);
/*!
 * fill-range <https://github.com/jonschlinkert/fill-range>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-extglob <https://github.com/jonschlinkert/is-extglob>
 *
 * Copyright (c) 2014-2016, Jon Schlinkert.
 * Licensed under the MIT License.
 */
/*!
 * is-glob <https://github.com/jonschlinkert/is-glob>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * is-number <https://github.com/jonschlinkert/is-number>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */
/*!
 * to-regex-range <https://github.com/micromatch/to-regex-range>
 *
 * Copyright (c) 2015-present, Jon Schlinkert.
 * Released under the MIT License.
 */
/*!
Copyright 2019 Ron Buckton

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/
/*! *****************************************************************************
Copyright (C) Microsoft. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
//# sourceMappingURL=cucumber-language-server.js.map
